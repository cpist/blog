1:"$Sreact.fragment"
5:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
6:"$Sreact.suspense"
0:{"buildId":"dJr9jTVTTddpYidNiSCaf","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/etc","style":{"textDecoration":"none"},"children":["/","etc"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"알아두면 쓸데있는 기초 지식들"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2026-01-03"}],["$","p",null,{"style":{"color":"#333"},"children":"Simple Questions"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"툴체인(Toolchain) 이라는게 정확히 무엇일까?\n툴체인은 소프트웨어 개발 과정에서 소스 코드가 실행 가능한 바이너리가 되기까지 필요한 **도구들의 연결 고리(Chain)**를 의미"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["컴파일러 하나만을 지칭하는 것이 아닌, 다음의 구성요소들이 유기적으로 엮여 있음.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Compiler (Frontend/Backend): 소스 코드를 중간 표현(IR)이나 어셈블리로 변환 (Clang, LLVM 등)"}],"\n",["$","li",null,{"children":"Assembler: 어셈블리 코드를 기계어(Object File)로 변환"}],"\n",["$","li",null,{"children":"Linker: 여러 개의 오브젝트 파일과 라이브러리를 하나로 묶어 실행 파일 생성 (lld, gold 등)"}],"\n",["$","li",null,{"children":"C/C++ Runtime Libraries: libc++, libstdc++ 등 기본 기능을 제공하는 라이브러리"}],"\n",["$","li",null,{"children":"Debugger/Profiler: 디버깅과 성능 분석 도구 (LLDB, GDB)\n이 도구들이 서로의 출력을 입력으로 받으며 체인처럼 이어져 있기 때문에 툴체인이라고 부름."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":["프로젝트 정적 검증의 원리\n기본적으로 컴파일러 기반의 정적 검증 도구(Clang Static Analyzer 등)는 번역 단위(Translation Unit, TU) 별로 동작함","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"보통 .c나 .cpp 파일 하나가 하나의 TU가 됨."}],"\n",["$","li",null,{"children":"개별 검증: 파일 A를 검증할 때 파일 B의 내부 로직은 알지 못하는 것이 기본"}],"\n",["$","li",null,{"children":["전역 검증 (Inter-procedural Analysis): 최근에는 여러 파일 간의 호출 관계를 분석하기 위해 'Cross-Translation Unit (CTU) Analysis' 기능을 사용하기도 한다.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 경우 프로젝트 전체의 인덱스를 먼저 생성한 뒤 검증을 수행"}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["그렇다면 Import(Include) 파일은 어떻게 처리 할까?\nC/C++에서 #include는 **전처리기(Preprocessor)**가 처리","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"텍스트 치환: 검증 도구가 돌아가기 전, 전처리기는 #include 문을 해당 헤더 파일의 실제 내용으로 통째로 복사해 넣음"}],"\n",["$","li",null,{"children":"거대 파일화: 결과적으로 검증 도구는 헤더 내용이 모두 포함된 하나의 커다란 소스 코드(Preprocessed source)를 읽게 됨"}],"\n",["$","li",null,{"children":"의존성 해결: 따라서 헤더 파일에 선언된 함수나 클래스 정보는 이미 하나의 파일 안에 합쳐진 상태이므로, 검증 도구는 이를 자연스럽게 인식 가능"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":["LLVM과 MLIR의 처리 flow (Flow comparison)\n두 기술의 가장 큰 차이점은 ",["$","strong",null,{"children":"\"추상화의 단계(Level of Abstraction)\""}]," 임."]}],"\n"]}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"[LLVM Flow: 전통적인 3단계 구조]\nLLVM은 보통 단일 수준의 IR(LLVM IR)을 중심으로 동작"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Frontend (Clang): C/C++ 코드를 읽어 구문 분석(AST) 후 LLVM IR로 변환"}],"\n",["$","li",null,{"children":"Optimizer (LLVM Opt): 생성된 LLVM IR을 대상으로 하드웨어 독립적인 최적화(Dead code elimination, Loop unrolling 등)를 수행"}],"\n",["$","li",null,{"children":"Backend (LLVM CodeGen): LLVM IR을 특정 타겟(x86, ARM, RISC-V 등)의 기계어로 변환"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"[MLIR Flow: 다중 계층 구조]\nMLIR은 LLVM IR 하나로 모든 것을 표현하기엔 너무 정보 손실이 크다는 문제에서 출발"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Frontend: 소스 코드를 읽어 가장 높은 수준의 Dialect(예: Toy, TOSA, Linalg 등)로 변환"}],"\n",["$","li",null,{"children":["Progressive Lowering (점진적 하향): * 한 번에 기계어로 가는 게 아니라, High-level Dialect $\\rightarrow$ Mid-level Dialect $\\rightarrow$ Low-level Dialect 순서로 단계적으로 변환","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"예: \"행렬 곱셈\" 연산이 있다면, 이를 처음엔 'Matmul'이라는 고수준 개념으로 최적화하고, 다음 단계에서 'Loop'로 풀고, 마지막에 'LLVM Dialect'로 내림"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"Conversion to LLVM IR: 최종적으로 LLVM Dialect가 된 코드를 LLVM IR로 Export 함."}],"\n",["$","li",null,{"children":"LLVM Backend: 이후는 기존 LLVM flow를 타고 기계어가 생성"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"정리해 보자면"}],"\n"]}],"\n",["$","ul",null,{"children":["\n","$L2","\n","$L3","\n"]}]]}]]}],null,"$L4"]}],"loading":null,"isPartial":false}
2:["$","li",null,{"children":"LLVM은 \"모든 언어를 하나의 공통 IR로 모아서 최적화하자\"는 주의"}]
3:["$","li",null,{"children":"MLIR은 \"도메인에 맞는 여러 단계의 IR(Dialect)을 거치며 단계별로 최적화하자\"는 주의"}]
4:["$","$L5",null,{"children":["$","$6",null,{"name":"Next.MetadataOutlet","children":"$@7"}]}]
7:null
