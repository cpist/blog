<!DOCTYPE html><!--LVGkH5hFRtoNYTtLcmSxK--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><title>알아두면 쓸데있는 기초 지식들 - CPIST&#x27;s blog</title><meta name="description" content="Simple Questions"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/etc" style="text-decoration:none">/<!-- -->etc</a></div><h2 style="margin-top:0">알아두면 쓸데있는 기초 지식들</h2><div style="color:#666;margin-bottom:18px">2026-01-03</div><p style="color:#333">Simple Questions</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>1) 툴체인(Toolchain) 이라는게 정확히 무엇일까?
툴체인은 소프트웨어 개발 과정에서 소스 코드가 실행 가능한 바이너리가 되기까지 필요한 **도구들의 연결 고리(Chain)**를 의미</p>
<ul>
<li>컴파일러 하나만을 지칭하는 것이 아닌, 다음의 구성요소들이 유기적으로 엮여 있음.<!-- -->
<ul>
<li>Compiler (Frontend/Backend): 소스 코드를 중간 표현(IR)이나 어셈블리로 변환 (Clang, LLVM 등)</li>
<li>Assembler: 어셈블리 코드를 기계어(Object File)로 변환</li>
<li>Linker: 여러 개의 오브젝트 파일과 라이브러리를 하나로 묶어 실행 파일 생성 (lld, gold 등)</li>
<li>C/C++ Runtime Libraries: libc++, libstdc++ 등 기본 기능을 제공하는 라이브러리</li>
<li>Debugger/Profiler: 디버깅과 성능 분석 도구 (LLDB, GDB)
이 도구들이 서로의 출력을 입력으로 받으며 체인처럼 이어져 있기 때문에 툴체인이라고 부름.</li>
</ul>
</li>
</ul>
<p>2) 프로젝트 정적 검증의 원리
기본적으로 컴파일러 기반의 정적 검증 도구(Clang Static Analyzer 등)는 번역 단위(Translation Unit, TU) 별로 동작함</p>
<ul>
<li>보통 .c나 .cpp 파일 하나가 하나의 TU가 됨.</li>
<li>개별 검증: 파일 A를 검증할 때 파일 B의 내부 로직은 알지 못하는 것이 기본</li>
<li>전역 검증 (Inter-procedural Analysis): 최근에는 여러 파일 간의 호출 관계를 분석하기 위해 &#x27;Cross-Translation Unit (CTU) Analysis&#x27; 기능을 사용하기도 한다.<!-- -->
<ul>
<li>이 경우 프로젝트 전체의 인덱스를 먼저 생성한 뒤 검증을 수행</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>그렇다면 Import(Include) 파일은 어떻게 처리 할까?
C/C++에서 #include는 **전처리기(Preprocessor)**가 처리</p>
<ul>
<li>텍스트 치환: 검증 도구가 돌아가기 전, 전처리기는 #include 문을 해당 헤더 파일의 실제 내용으로 통째로 복사해 넣음</li>
<li>거대 파일화: 결과적으로 검증 도구는 헤더 내용이 모두 포함된 하나의 커다란 소스 코드(Preprocessed source)를 읽게 됨</li>
<li>의존성 해결: 따라서 헤더 파일에 선언된 함수나 클래스 정보는 이미 하나의 파일 안에 합쳐진 상태이므로, 검증 도구는 이를 자연스럽게 인식 가능</li>
</ul>
</li>
<li>
<p>당연한 소리지만, 텍스트 복사에는 한계가 있음</p>
<ul>
<li>C/C++의 #include는 단순히 파일 내용을 복사해서 붙여넣는 방식임.</li>
<li>따라서 헤더 파일이 수십 개 층으로 얽혀 있다면, 전처리가 끝난 후 실제 컴파일러가 읽어야 할 소스 코드(Translation Unit)는 수십만 라인으로 불어나게 됨.</li>
<li>당연히 중복 분석의 낭비가 생김.<!-- -->
<ul>
<li>예를 들어 파일 A와 B가 모두 common.h를 포함하고 있다면, 컴파일러는 각 파일을 컴파일할 때마다 common.h를 매번 다시 파싱하고 분석해야 함.</li>
</ul>
</li>
<li>일반적으로는 PCH (Precompiled Headers): 자주 바뀌지 않는 헤더들을 미리 바이너리 형태로 구워놓고 재사용 함.<!-- -->
<ul>
<li>C++20 Modules: #include 대신 import를 사용하여, 한 번 분석된 결과를 바이너리(BMI)로 저장해 두고 재사용함으로써 컴파일 속도를 혁신적으로 줄임.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3) CTU (Cross-Translation Unit) Analysis의 상세 메커니즘
위에서 언급한 전통적인 정적 검증은 &quot;파일 단위&quot;로만 돌아가기 때문에, 다른 파일에 정의된 함수의 리턴값이 무엇인지 알 수 없어 검증에 구멍이 생김.
이를 해결하는 CTU는 보통 다음과 같은 2-Pass 방식으로 동작</p>
<ol>
<li>
<p>인덱싱 및 요약 (Indexing &amp; Summary Generation)
프로젝트 전체를 한 번 훑음.
실제 검증을 수행하는 것이 아니라, 다음 정보를 추출</p>
<ul>
<li>Global Call Graph: 어떤 파일의 어떤 함수가 다른 파일의 무엇을 호출하는지 지도를 그림.</li>
<li>Function Summaries: 각 함수의 특징(예: &quot;이 함수는 NULL을 리턴할 수 있음&quot;, &quot;이 함수는 메모리를 할당함&quot;)을 추상화하여 저장</li>
<li>AST Serialization: 각 파일의 추상 구문 트리(AST)를 바이너리 형태로 덤프(Dump)해 둠</li>
</ul>
</li>
<li>
<p>실제 검증 (Global Analysis)
이제 각 파일을 검증할 때, 외부 함수 호출을 만나면 미리 덤프해둔 AST를 메모리에 로드하거나 Summary를 참조하여 문맥을 파악</p>
</li>
</ol>
<ul>
<li>참고로 이건 연구 주제임.<!-- -->
<ul>
<li>전체 AST를 다 불러오면 메모리가 터지고</li>
<li>Summary만 쓰자니 정확도가 떨어짐</li>
<li>따라서 **&quot;최소한의 메모리로 최대한의 정확도를 뽑아내는 요약 기법&quot;**과 **&quot;증분 분석(변경된 부분만 분석)&quot;**이 학계와 산업계(LLVM/Clang 커뮤니티 등)의 핵심 화두</li>
</ul>
</li>
</ul>
<p>4) LLVM과 MLIR의 처리 flow (Flow comparison)
두 기술의 가장 큰 차이점은 <strong>&quot;추상화의 단계(Level of Abstraction)&quot;</strong> 임.</p>
<ol>
<li>
<p>[LLVM Flow: 전통적인 3단계 구조]
LLVM은 보통 단일 수준의 IR(LLVM IR)을 중심으로 동작</p>
<ul>
<li>Frontend (Clang): C/C++ 코드를 읽어 구문 분석(AST) 후 LLVM IR로 변환</li>
<li>Optimizer (LLVM Opt): 생성된 LLVM IR을 대상으로 하드웨어 독립적인 최적화(Dead code elimination, Loop unrolling 등)를 수행</li>
<li>Backend (LLVM CodeGen): LLVM IR을 특정 타겟(x86, ARM, RISC-V 등)의 기계어로 변환</li>
</ul>
</li>
<li>
<p>[MLIR Flow: 다중 계층 구조]
MLIR은 LLVM IR 하나로 모든 것을 표현하기엔 너무 정보 손실이 크다는 문제에서 출발</p>
<ul>
<li>Frontend: 소스 코드를 읽어 가장 높은 수준의 Dialect(예: Toy, TOSA, Linalg 등)로 변환</li>
<li>Progressive Lowering (점진적 하향): * 한 번에 기계어로 가는 게 아니라, High-level Dialect $\rightarrow$ Mid-level Dialect $\rightarrow$ Low-level Dialect 순서로 단계적으로 변환<!-- -->
<ul>
<li>예: &quot;행렬 곱셈&quot; 연산이 있다면, 이를 처음엔 &#x27;Matmul&#x27;이라는 고수준 개념으로 최적화하고, 다음 단계에서 &#x27;Loop&#x27;로 풀고, 마지막에 &#x27;LLVM Dialect&#x27;로 내림</li>
</ul>
</li>
<li>Conversion to LLVM IR: 최종적으로 LLVM Dialect가 된 코드를 LLVM IR로 Export 함.</li>
<li>LLVM Backend: 이후는 기존 LLVM flow를 타고 기계어가 생성</li>
</ul>
</li>
</ol>
<ul>
<li>정리해 보자면</li>
</ul>
<ul>
<li>LLVM은 &quot;모든 언어를 하나의 공통 IR로 모아서 최적화하자&quot;는 주의</li>
<li>MLIR은 &quot;도메인에 맞는 여러 단계의 IR(Dialect)을 거치며 단계별로 최적화하자&quot;는 주의</li>
</ul>
<p>5) Coverity 같은 상용툴의 동작 방식
사용 툴들도 정적 검증 원리를 동일하게 사용하긴 하는데, 환경 재현과 분석 엔진에서 상용 툴만의 노하우가 들어감.</p>
<ol>
<li>빌드 인터셉션 (Build Interception)</li>
</ol>
<ul>
<li>Coverity는 보통 cov-build라는 래퍼(Wrapper)를 사용<!-- -->
<ul>
<li>사용자가 make나 cmake로 빌드할 때, Coverity가 그 호출을 가로챔</li>
<li>컴파일러 설정 복제: 실제 빌드에 쓰인 컴파일러(gcc, armcc 등)가 무엇인지, 어떤 매크로(-DDEBUG)와 인클루드 경로(-I/usr/include)를 썼는지 그대로 캡처</li>
<li>Emit: 캡처한 정보를 바탕으로 소스 코드를 Coverity 전용 중간 언어(Intermediate Representation, 주로 SIR)로 변환하여 로컬 DB에 저장</li>
</ul>
</li>
</ul>
<ol start="2">
<li>컴파일러 Configuration이 중요한 이유</li>
</ol>
<ul>
<li>정적 검증 도구가 코드를 제대로 해석하려면, 실제 타겟 환경의 컴파일러와 똑같이 생각해야 하기 때문<!-- -->
<ul>
<li>int가 16비트인가 32비트 인가</li>
<li>컴파일러가 기본으로 정의해둔 내장 매크로(<strong>linux</strong> 등)는 무엇인가<!-- -->
<ul>
<li>이를 맞추지 못하면 정적 검증 도구는 코드를 읽다가 에러(Parse Error)를 내뱉거나 엉뚱한 경로를 분석</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>상용툴의 경우</li>
</ol>
<ul>
<li>LLVM 기반의 오픈소스 도구보다 훨씬 더 강력한 Global Dataflow Analysis 엔진을 가짐</li>
<li>수백만 라인의 코드에서도 메모리 릭이나 레이스 컨디션을 찾아내기 위해 고도로 최적화된 Symbolic Execution 기법을 적용</li>
<li>오탐(False Positive)을 줄이기 위한 방대한 체커(Checker) 로직을 보유</li>
</ul></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"LVGkH5hFRtoNYTtLcmSxK\",\"c\":[\"\",\"posts\",\"etc\",\"Questions\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"etc/Questions\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/etc\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"etc\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"알아두면 쓸데있는 기초 지식들\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2026-01-03\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Simple Questions\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"1) 툴체인(Toolchain) 이라는게 정확히 무엇일까?\\n툴체인은 소프트웨어 개발 과정에서 소스 코드가 실행 가능한 바이너리가 되기까지 필요한 **도구들의 연결 고리(Chain)**를 의미\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"컴파일러 하나만을 지칭하는 것이 아닌, 다음의 구성요소들이 유기적으로 엮여 있음.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Compiler (Frontend/Backend): 소스 코드를 중간 표현(IR)이나 어셈블리로 변환 (Clang, LLVM 등)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Assembler: 어셈블리 코드를 기계어(Object File)로 변환\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Linker: 여러 개의 오브젝트 파일과 라이브러리를 하나로 묶어 실행 파일 생성 (lld, gold 등)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"C/C++ Runtime Libraries: libc++, libstdc++ 등 기본 기능을 제공하는 라이브러리\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Debugger/Profiler: 디버깅과 성능 분석 도구 (LLDB, GDB)\\n이 도구들이 서로의 출력을 입력으로 받으며 체인처럼 이어져 있기 때문에 툴체인이라고 부름.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) 프로젝트 정적 검증의 원리\\n기본적으로 컴파일러 기반의 정적 검증 도구(Clang Static Analyzer 등)는 번역 단위(Translation Unit, TU) 별로 동작함\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"보통 .c나 .cpp 파일 하나가 하나의 TU가 됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"개별 검증: 파일 A를 검증할 때 파일 B의 내부 로직은 알지 못하는 것이 기본\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"전역 검증 (Inter-procedural Analysis): 최근에는 여러 파일 간의 호출 관계를 분석하기 위해 'Cross-Translation Unit (CTU) Analysis' 기능을 사용하기도 한다.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 경우 프로젝트 전체의 인덱스를 먼저 생성한 뒤 검증을 수행\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"그렇다면 Import(Include) 파일은 어떻게 처리 할까?\\nC/C++에서 #include는 **전처리기(Preprocessor)**가 처리\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"텍스트 치환: 검증 도구가 돌아가기 전, 전처리기는 #include 문을 해당 헤더 파일의 실제 내용으로 통째로 복사해 넣음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"거대 파일화: 결과적으로 검증 도구는 헤더 내용이 모두 포함된 하나의 커다란 소스 코드(Preprocessed source)를 읽게 됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"의존성 해결: 따라서 헤더 파일에 선언된 함수나 클래스 정보는 이미 하나의 파일 안에 합쳐진 상태이므로, 검증 도구는 이를 자연스럽게 인식 가능\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"당연한 소리지만, 텍스트 복사에는 한계가 있음\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"C/C++의 #include는 단순히 파일 내용을 복사해서 붙여넣는 방식임.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"따라서 헤더 파일이 수십 개 층으로 얽혀 있다면, 전처리가 끝난 후 실제 컴파일러가 읽어야 할 소스 코드(Translation Unit)는 수십만 라인으로 불어나게 됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"당연히 중복 분석의 낭비가 생김.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"예를 들어 파일 A와 B가 모두 common.h를 포함하고 있다면, 컴파일러는 각 파일을 컴파일할 때마다 common.h를 매번 다시 파싱하고 분석해야 함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"일반적으로는 PCH (Precompiled Headers): 자주 바뀌지 않는 헤더들을 미리 바이너리 형태로 구워놓고 재사용 함.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"C++20 Modules: #include 대신 import를 사용하여, 한 번 분석된 결과를 바이너리(BMI)로 저장해 두고 재사용함으로써 컴파일 속도를 혁신적으로 줄임.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3) CTU (Cross-Translation Unit) Analysis의 상세 메커니즘\\n위에서 언급한 전통적인 정적 검증은 \\\"파일 단위\\\"로만 돌아가기 때문에, 다른 파일에 정의된 함수의 리턴값이 무엇인지 알 수 없어 검증에 구멍이 생김.\\n이를 해결하는 CTU는 보통 다음과 같은 2-Pass 방식으로 동작\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"인덱싱 및 요약 (Indexing \u0026 Summary Generation)\\n프로젝트 전체를 한 번 훑음.\\n실제 검증을 수행하는 것이 아니라, 다음 정보를 추출\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Global Call Graph: 어떤 파일의 어떤 함수가 다른 파일의 무엇을 호출하는지 지도를 그림.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Function Summaries: 각 함수의 특징(예: \\\"이 함수는 NULL을 리턴할 수 있음\\\", \\\"이 함수는 메모리를 할당함\\\")을 추상화하여 저장\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AST Serialization: 각 파일의 추상 구문 트리(AST)를 바이너리 형태로 덤프(Dump)해 둠\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"실제 검증 (Global Analysis)\\n이제 각 파일을 검증할 때, 외부 함수 호출을 만나면 미리 덤프해둔 AST를 메모리에 로드하거나 Summary를 참조하여 문맥을 파악\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\"]}],\"$L1a\",\"$L1b\"]}]\n"])</script><script>self.__next_f.push([1,"1c:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"참고로 이건 연구 주제임.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"전체 AST를 다 불러오면 메모리가 터지고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Summary만 쓰자니 정확도가 떨어짐\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"따라서 **\\\"최소한의 메모리로 최대한의 정확도를 뽑아내는 요약 기법\\\"**과 **\\\"증분 분석(변경된 부분만 분석)\\\"**이 학계와 산업계(LLVM/Clang 커뮤니티 등)의 핵심 화두\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\nf:[\"$\",\"p\",null,{\"children\":[\"4) LLVM과 MLIR의 처리 flow (Flow comparison)\\n두 기술의 가장 큰 차이점은 \",[\"$\",\"strong\",null,{\"children\":\"\\\"추상화의 단계(Level of Abstraction)\\\"\"}],\" 임.\"]}]\n"])</script><script>self.__next_f.push([1,"10:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"[LLVM Flow: 전통적인 3단계 구조]\\nLLVM은 보통 단일 수준의 IR(LLVM IR)을 중심으로 동작\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Frontend (Clang): C/C++ 코드를 읽어 구문 분석(AST) 후 LLVM IR로 변환\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Optimizer (LLVM Opt): 생성된 LLVM IR을 대상으로 하드웨어 독립적인 최적화(Dead code elimination, Loop unrolling 등)를 수행\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Backend (LLVM CodeGen): LLVM IR을 특정 타겟(x86, ARM, RISC-V 등)의 기계어로 변환\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"[MLIR Flow: 다중 계층 구조]\\nMLIR은 LLVM IR 하나로 모든 것을 표현하기엔 너무 정보 손실이 크다는 문제에서 출발\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Frontend: 소스 코드를 읽어 가장 높은 수준의 Dialect(예: Toy, TOSA, Linalg 등)로 변환\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Progressive Lowering (점진적 하향): * 한 번에 기계어로 가는 게 아니라, High-level Dialect $\\\\rightarrow$ Mid-level Dialect $\\\\rightarrow$ Low-level Dialect 순서로 단계적으로 변환\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"예: \\\"행렬 곱셈\\\" 연산이 있다면, 이를 처음엔 'Matmul'이라는 고수준 개념으로 최적화하고, 다음 단계에서 'Loop'로 풀고, 마지막에 'LLVM Dialect'로 내림\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Conversion to LLVM IR: 최종적으로 LLVM Dialect가 된 코드를 LLVM IR로 Export 함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM Backend: 이후는 기존 LLVM flow를 타고 기계어가 생성\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n"])</script><script>self.__next_f.push([1,"11:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"정리해 보자면\"}],\"\\n\"]}]\n12:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM은 \\\"모든 언어를 하나의 공통 IR로 모아서 최적화하자\\\"는 주의\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR은 \\\"도메인에 맞는 여러 단계의 IR(Dialect)을 거치며 단계별로 최적화하자\\\"는 주의\"}],\"\\n\"]}]\n13:[\"$\",\"p\",null,{\"children\":\"5) Coverity 같은 상용툴의 동작 방식\\n사용 툴들도 정적 검증 원리를 동일하게 사용하긴 하는데, 환경 재현과 분석 엔진에서 상용 툴만의 노하우가 들어감.\"}]\n14:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"빌드 인터셉션 (Build Interception)\"}],\"\\n\"]}]\n15:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Coverity는 보통 cov-build라는 래퍼(Wrapper)를 사용\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"사용자가 make나 cmake로 빌드할 때, Coverity가 그 호출을 가로챔\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"컴파일러 설정 복제: 실제 빌드에 쓰인 컴파일러(gcc, armcc 등)가 무엇인지, 어떤 매크로(-DDEBUG)와 인클루드 경로(-I/usr/include)를 썼는지 그대로 캡처\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Emit: 캡처한 정보를 바탕으로 소스 코드를 Coverity 전용 중간 언어(Intermediate Representation, 주로 SIR)로 변환하여 로컬 DB에 저장\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n16:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"컴파일러 Configuration이 중요한 이유\"}],\"\\n\"]}]\n17:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"정적 검증 도구가 코드를 제대로 해석하려면, 실제 타겟 환경의 컴파일러와 똑같이 생각해야 하기 때문\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"int가 16비트인가 32비트 인가\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"컴파일러가 기본으로 정의해둔 내장 매크로(\",[\"$\",\"strong\",null,{\"children\":\"linux\"}],\" 등)는 무엇인가\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이를 맞추지 못하면 정적 검증 도구는 코드를 읽다가 에러(Parse Error)를 내뱉거나 엉뚱한 경로를 분석\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n18:[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"상용툴의 경우\"}],\"\\n\"]}]\n19:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM 기반의 오픈소스 도구보다 훨씬 더 강력한 Global Dataflow Analysis 엔진을 가짐\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"수백만 라인의 코드에서도 메모리 릭이나 레이스 컨디션을 찾아내기 위해 고도로 최적화된 Symbolic Execution 기법을 적용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"오탐(False Positive)을 줄이기 위한 방대한 체커(Checker) 로직을 보유\"}],\"\\n\"]}]\n1a:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n1b:[\"$\",\"$L1c\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"1d:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"알아두면 쓸데있는 기초 지식들 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Simple Questions\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L1d\",\"3\",{}]]\n8:null\n"])</script></body></html>