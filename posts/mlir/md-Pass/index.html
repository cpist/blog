<!DOCTYPE html><!--TI0pD73CnhalHln6RXV_z--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><title>MLIR docs PassManagement 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Pass Infrastructure"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR docs PassManagement 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-12-20</div><p style="color:#333">Pass Infrastructure</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>1) Operation Pass가 기본 단위임.</p>
<ul>
<li>MLIR에서 변환 / 최적화의 기본 추상화 단위는 Operation 이고, 패스는 &quot;현재 operation(current operation)&quot; 을 기준으로 동작함.</li>
<li>모든 패스는 OperationPass 에서 파생되며, 멀티스레드/중첩 실행을 안전하게 하려고 강한 제약을 가짐.</li>
</ul>
<ul>
<li>OperationPass 공통 제약(중요한 부분)
패스가 runOnOperation() 을 실행할 때</li>
</ul>
<ul>
<li>형제(sibling) operation을 보면 안된다.<!-- -->
<ul>
<li>형제 및 그 아래에도 접근 하면 안됨.</li>
<li>다른 스레드가 병렬로 수정 중일 수도 있음</li>
<li>단, 조상(ancestor/parent) operation을 읽는 것은 허용함.</li>
</ul>
</li>
<li>현재 operation 아래에 중첩 된 것들만 수정이 가능함<!-- -->
<ul>
<li>조상 / 부모 blcok에 다른 op를 추가/삭제/변경 하는 것은 안됨</li>
<li>예외 : 현재 operation의 attribute는 자유롭게 수정이 가능함<!-- -->
<ul>
<li>이말인 즉슨, 현재 op를 직접 바꿀 수 있는 유일한 통로라는 것</li>
</ul>
</li>
</ul>
</li>
<li>runOnOperation 호출 간 mutable 한 패스 상태를 유지하면 안됨<!-- -->
<ul>
<li>여러 op에 대해 실행 순서 보장이 없음</li>
<li>멀티스레딩 에서는 어떤 패스 인스턴스가 모든 op를 다 처리한다는 보장도 없음</li>
</ul>
</li>
<li>전역 mutable 상태를 금지함 - static 변수 같은</li>
<li>copy-constructible 이어야 한다.<!-- -->
<ul>
<li>패스 매니저가 병렬 처리를 위해 패스 인스턴스를 복제 가능</li>
</ul>
</li>
</ul>
<p>2) Operation Pass 의 종류와 필터링에 대하여</p>
<ol>
<li>Op-Agnostic Pass (기본)</li>
</ol>
<ul>
<li>기본은 op-agnostic : 어떤 operation 타입이든 패스 매니저가 대상으로 삼는 타입에서 실행이 됨.</li>
<li>이런 패스는 자기가 어떤 op에서 돌지 가정을 하면 안된다. (canonicalize, cse)</li>
<li>구현 포인트는 <code>OperationPass&lt;&gt;</code> (탬플릿 인자 X) + runOnOperation() 오버라이드</li>
</ul>
<ol start="2">
<li>Filtered Operation Pass
필요하면 이 패스는 특정한 op/컨텍스트 에서만 실행 되도록 추가 필터링을 적용할 수 있다.
A - 정적 스케줄 필터링 : canScheduleOn</li>
</ol>
<ul>
<li>bool canScheduleOn(RegisteredOperationName opInfo) const 로 어떤 op 타입에 스케줄 가능한지 제약을 선언함</li>
<li>FunctionOpInterface 를 구현한 op에서만 실행함.
아주 중요한 상속 규칙은</li>
<li>이 필터가 걸린 패스를 op-agnostic pass manager에 넣으면 그 pass manager(안의 모든 패스 포함)가 그 제약을 상속한다.</li>
<li>그래서 any(cse, my-function-pass) 같은 파이프라인ㄷ 실제로는 FunctionOpInterface op들만 대상으로 cse 까지 같이 돌아버린다.</li>
</ul>
<p>B - 정적 필터링</p>
<ul>
<li>Op 타입 1개로 제한함 : <code>OperationPass&lt;func::FuncOp&gt;</code> 처럼 템플릿에 op 타입을 넣으면 자동 필터링이 됨</li>
<li>인터페이스로 제한함 : <code>InterfacePass&lt;FunctionOpInterface&gt;</code> 기반으로 작성하면 자동 필터링이 됨</li>
</ul>
<p>3) Dependent Dialects</p>
<ul>
<li>패스가 어떤 dialect의 entity(ops/types/attrs 등)를 새로 만들 수 있다면, 그 dialect가 미리 로드 되어 있어야 함.<!-- -->
<ul>
<li>특히 멀티 스레드 pipline 시작 전</li>
</ul>
</li>
<li>이를 위해 패스는 getDependentDialects() 를 Override 해서 필요 dialect 목록을 명시적으로 선언해야 함.<!-- -->
<ul>
<li>TableGen에서도 dependentDialects 필드로 선언이 가능</li>
</ul>
</li>
</ul>
<p>4) Pass Initialization hook</p>
<ul>
<li>패스가 런타임에 만들면 비싼 상태를 갖는 경우<!-- -->
<ul>
<li>예시로 PDL Pattern bytecode compile case</li>
<li>LogicalResult initialize(MLIRContext *context) 를 override 해 pipeline 1회 실행당 1번 초기화 가능</li>
</ul>
</li>
<li>여기서는 getContext / getOperation / getAnalysis 같은 per-run API 사용 금지 (현재 op가 없기 때문)<!-- -->
<ul>
<li>제공된 context 로만 작업 해야 함.</li>
</ul>
</li>
<li>실패 시 진단 메시지 출력 후 failure() 반환 : Pipeline 중단</li>
</ul>
<p>5) Analysis Management (분석) 모델</p>
<ul>
<li>분석은 변환 패스가 아니라 독립 클래스로, 요청 시 lazy 계산 + Cache 됨</li>
<li>분석 클래스 요구사항<!-- -->
<ul>
<li>생성자 : (Operation*) 또는 (Operation*, AnalysisManager&amp;)</li>
<li>대상 operation을 수정하면 안 됨</li>
<li>AnalysisManager&amp; 를 통해 의존 분석을 요청 가능</li>
</ul>
</li>
</ul>
<ol>
<li>분석 무효화(invalidation) 제어</li>
</ol>
<ul>
<li>bool isInvalidated(const PreservedAnalyses&amp;) 로 보존 세트에 없더라도 실제로는 무효화할지를 더 정교하게 결정이 가능함</li>
<li>의존 분석이 있다면 그 무효화도 함께 확인해야 한다.</li>
</ul>
<ol start="2">
<li>패스에서 분석 조회 API</li>
</ol>
<ul>
<li>OperationPass가 제공함</li>
</ul>
<pre><code>  - getAnalysis&lt;&gt; (없으면 생성)
  - getCachedAnalysis&lt;&gt; (있을 경우에만)
  - getCachedParentAnalysis&lt;&gt;
  - getCachedChildAnalysis&lt;&gt;
  - getChildAnalysis&lt;&gt; (없으면 생성함)
</code></pre>
<ol start="3">
<li>분석 보존 (PreservedAnalyses)</li>
</ol>
<ul>
<li>기본적으로 패스가 지나가면 분석은 다 무효화된다고 가정</li>
<li>바뀌지 않았거나 유지됨을 보장하면 패스가 명시적으로 표시해야 함<!-- -->
<ul>
<li>markAllAnalysesPreserved()</li>
<li><code>markAnalysesPreserved&lt;A, B...&gt;()</code></li>
</ul>
</li>
</ul>
<p>6) Pass failure</p>
<ul>
<li>패스는 graceful fail이 가능함</li>
<li>불변식이 깨져 IR이 유효하지 않을 수 있으면 signalPassFailure() 호출</li>
<li>실패가 발생하면<!-- -->
<ul>
<li>파이프라인의 나머지 패스 실행이 중단됨</li>
<li>최상위 PassManager::run 이 failure을 반환함</li>
</ul>
</li>
</ul>
<p>7) Pass Manager 구조 : PassManager vs OpPassManager</p>
<ol>
<li>PassManager</li>
</ol>
<ul>
<li>전체 파이프라인의 최상위 엔트리 + 전역 설정 담당</li>
<li>동시에 top-level OpPassManager 역할도 함</li>
</ul>
<ol start="2">
<li>OpPassManager</li>
</ol>
<ul>
<li>특정 중첩 레벨의 operation 들에 대해 실행될 패스들의 컬렉션</li>
<li>두 종류<!-- -->
<ul>
<li>op-specific: 특정 op 타입에 고정(anchor)</li>
<li>op-agnostic: 특정 타입에 제한 없이 가능한 op들에 실행</li>
<li>Anchor op 타입 요구조건은<!-- -->
<ul>
<li>등록되어 있고, IsolatedFromAbove trait 이어야 한다는 점</li>
<li>현재 레벨 이상을 건드리면 SSA/use-list 등을 잘못 건드릴 위험이 있기 때문</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Nesting으로 파이프라인 구성</li>
</ol>
<ul>
<li><code>nest&lt;OpT&gt;()</code> : 특정 op 타입 레벨로 중첩 PM 생성</li>
<li>nestAny() : op-agnostic 중첩 PM 생성</li>
<li>이 중첩은 IR의 Region 안 operation 구조적 중첩과 대응됨</li>
</ul>
<ol start="4">
<li>실행 방식 (중요한 실행 모델)</li>
</ol>
<ul>
<li>한 operation을 잡고 그 op에 걸린 패스들을 연속으로 전부 실행 한 다음, 다음 operation으로 넘어간다.</li>
<li>효과는<!-- -->
<ul>
<li>함수 단위로 집중하여 캐시 / 지역성이 좋아지고</li>
<li>함수 파이프라인을 병렬 실행 하여 멀티스레딩 시 작업(job) 구성 효율이 좋아짐.</li>
</ul>
</li>
</ul>
<p>8) Dynamic Pass Pipelines (패스 내부에서 파이프라인 실행)</p>
<ul>
<li>어떤 Pass는 실행 중에 조건에 따라 추가 파이프라인을 돌리고 싶을 수 있다.<!-- -->
<ul>
<li>inliner가 중간에 단순화 파이프라인을 실행하는 케이스</li>
</ul>
</li>
<li>이때 Pass::runPipeline(OpPassManager &amp;, Operation *) 로 현재 op 또는 그 아래 op들에 대해 동적 파이프라인 실행 가능</li>
<li>장점은 분석 / Instrumentation / PassManager 구성요소가 동적 파이프라인에도 제대로 연동된다는 점</li>
<li>권장 사항은 Pass 내부에서 새 PassManager 를 만들기 보다 runPipeline을 사용함.</li>
<li>OpPassManager 는 copy-safe <code>-&gt;</code> 가능하면 파이프라인을 캐시해서 재사용함.</li>
</ul>
<p>9) Instance-Specific Pass Options (옵션)</p>
<ul>
<li>패스는 인스턴스별 옵션을 <code>Option&lt;&gt;, ListOption&lt;&gt;</code> 로 정의가 가능함</li>
<li>LLVM command line 스타일을 따른다.</li>
<li>ListOption은 콤마로 분리되지만, 원소 내부의 서브 범위 등은 콤마를 separator로 안 볼 수 있는 규칙이 있음</li>
</ul>
<ul>
<li>PassPipelineRegistration 옵션</li>
</ul>
<ul>
<li>파이프라인 등록 시 PassPipelineOptions 를 상속한 옵션 구조체를 제공 가능함</li>
<li>빌더 시그니쳐 : void (OpPassManager &amp;pm, const Options&amp;)</li>
</ul>
<p>10) Pass Statistics</p>
<ul>
<li>컴파일러가 뭘 얼마나 했는지를 패스 인스턴스 별로 카운트 / 집계함.</li>
<li>Pass::Statistic 을 사용함 (원자적 unsigned 처럼 증가 가능함)</li>
<li>출력은<!-- -->
<ul>
<li>API : PassManager::enableStatistics</li>
<li>CLI : -mlir-pass-statistics, -mlir-pass-statistics-display (pipeline/tree vs list view)</li>
</ul>
</li>
</ul>
<p>11) Pass Registration &amp; Pipeline Registration</p>
<ol>
<li>PassRegistration</li>
</ol>
<ul>
<li>패스 클래스를 텍스트 파이프라인에서 생성 가능하게 등록</li>
<li>getArgument() 가 텍스트 식별자, getDescription()이 요약 설명</li>
<li>기본 생성 불가 패스는 &quot;생성 콜백&quot; 으로 등록이 가능함</li>
<li>copy-constructible + 데이터 공유 주의 (병렬 실행 때문)</li>
</ul>
<ol start="2">
<li>PassPipelineRegistration</li>
</ol>
<ul>
<li>자주 쓰는 파이프라인 자체를 하나의 이름으로 등록함</li>
<li>OpPassManager에 패스를 추가하는 빌더 함수 (또는 람다) 제공된</li>
</ul>
<p>12) Textual Pass Pipeline Specification (문자열 파이프라인 문법)</p>
<ul>
<li>중첩 구조 / 패스 이름 / 파이프라인 이름 / 옵션을 문자열로 표현 함.</li>
<li>EBNF 핵심:<!-- -->
<ul>
<li>op-anchor(elem, elem, ...)</li>
<li>elem은 중첩 pipeline 이거나 pass-name / pass-pipeline-name + Option 이 가능함</li>
</ul>
</li>
<li>op-anchor는 func.func, builtin.module 같은 op mnenmonic 또는 any</li>
<li>OpPassManager::printAsTextualPipeline(...) 로 라운드트립 지원하려면 Pass::getArgument() 구현 필요</li>
</ul>
<p>13) Declarative Pass Specification (TableGen 기반)</p>
<ul>
<li>패스도 operation 처럼 일부를 TableGen으로 선언이 가능함<!-- -->
<ul>
<li>registration boilerplate 생성</li>
<li>옵션 / 통계 / 의존 dialect 선언</li>
<li>문서 (gen-pass-doc) 생성</li>
</ul>
</li>
<li>gen-pass-decls<!-- -->
<ul>
<li><code>register&lt;PassName&gt;()</code> 와 그룹 등록 함수 생성</li>
<li>MyPassOptions 구조체 생성</li>
<li>impl::MyPassBase 같은 베이스 클래스 생성 (옵션 / 통계 멤버 포함)</li>
</ul>
</li>
<li>매크로 (GEN_PASS_REGISTRATION, GEN_PASS_DECL, GEN_PASS_DEF_...) 로 필요한 부분만 포함</li>
</ul>
<p>14) Pass Instrumentation</p>
<ul>
<li>PassInstrumentation 으로 패스 실행/분석 계산 이벤트에 hook<!-- -->
<ul>
<li>runBeforePipeline / runAfterPipeline</li>
<li>runBeforePass / runAfterPass / runAfterPassFailed</li>
<li>runBeforeAnalysis / runAfterAnalysis</li>
</ul>
</li>
<li>PassManager에 addInstrumentation(...) 로 등록</li>
<li>Hook 호출은 스택처럼 (LIFO) before / after가 짝지어 실행됨</li>
<li>Instrumentation hook 은 thread-safe 하게 호출이 보장됨.</li>
</ul>
<ul>
<li>Standard Instrumentations</li>
</ul>
<ol>
<li>Pass Timing</li>
</ol>
<ul>
<li>PassManager::enableTiming 또는 mlir-opt -mlir-timing</li>
<li>표시모드는<!-- -->
<ul>
<li>list(-mlir-timing-display=list) / tree(기본)</li>
<li>JSON 출력 (-mlir-output-format=json)</li>
</ul>
</li>
<li>멀티스레드 에서는 User Time(총 CPU)과 Wall Time(최장 스레드) 의미 차이를 주의</li>
</ul>
<ol start="2">
<li>IR Printing</li>
</ol>
<ul>
<li>패스 전/후 IR 덤프 및 필터링<!-- -->
<ul>
<li>-mlir-print-ir-before=..., -mlir-print-ir-after=...</li>
<li>-mlir-print-ir-before-all, -mlir-print-ir-after-all</li>
<li>-mlir-print-ir-after-change(변경된 경우만, 해시 기반)</li>
<li>-mlir-print-ir-after-failure(실패 시만)</li>
<li>-mlir-print-ir-module-scope(모듈 스코프 출력, threading disable 필요)</li>
<li>-mlir-print-ir-tree-dir=...(디렉토리 트리로 파일 출력)</li>
<li>-mlir-use-nameloc-as-prefix(named loc로 SSA 이름 프리픽스)</li>
</ul>
</li>
</ul>
<p>15) Crash / Failure Reproduction (재현 파일 생성)</p>
<ul>
<li>크래시나 패스 실패 시 reproducer(입력 IR + 파이프라인 설정) 을 .mlir로 덤프 가능</li>
<li>활성화<!-- -->
<ul>
<li>API : PassManager::enableCrashReproducerGeneration</li>
<li>CLI : mlir-pass-pipeline-crash-reproducer</li>
</ul>
</li>
<li>재현 실행 : mlir-opt -run-reproducer</li>
<li>Local reproducer (실패 직전 IR 포함) 도 가능함<!-- -->
<ul>
<li>CLI: mlir-pass-pipeline-local-reproducer</li>
<li>단, 멀티스레딩 비활성화 필요(-mlir-disable-threading)</li>
</ul>
</li>
</ul></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"TI0pD73CnhalHln6RXV_z\",\"c\":[\"\",\"posts\",\"mlir\",\"md-Pass\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-Pass\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR docs PassManagement 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-12-20\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Pass Infrastructure\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"1) Operation Pass가 기본 단위임.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR에서 변환 / 최적화의 기본 추상화 단위는 Operation 이고, 패스는 \\\"현재 operation(current operation)\\\" 을 기준으로 동작함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"모든 패스는 OperationPass 에서 파생되며, 멀티스레드/중첩 실행을 안전하게 하려고 강한 제약을 가짐.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"OperationPass 공통 제약(중요한 부분)\\n패스가 runOnOperation() 을 실행할 때\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"형제(sibling) operation을 보면 안된다.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"형제 및 그 아래에도 접근 하면 안됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다른 스레드가 병렬로 수정 중일 수도 있음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"단, 조상(ancestor/parent) operation을 읽는 것은 허용함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"현재 operation 아래에 중첩 된 것들만 수정이 가능함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"조상 / 부모 blcok에 다른 op를 추가/삭제/변경 하는 것은 안됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"예외 : 현재 operation의 attribute는 자유롭게 수정이 가능함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이말인 즉슨, 현재 op를 직접 바꿀 수 있는 유일한 통로라는 것\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"runOnOperation 호출 간 mutable 한 패스 상태를 유지하면 안됨\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"여러 op에 대해 실행 순서 보장이 없음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"멀티스레딩 에서는 어떤 패스 인스턴스가 모든 op를 다 처리한다는 보장도 없음\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"전역 mutable 상태를 금지함 - static 변수 같은\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"copy-constructible 이어야 한다.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"패스 매니저가 병렬 처리를 위해 패스 인스턴스를 복제 가능\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) Operation Pass 의 종류와 필터링에 대하여\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Op-Agnostic Pass (기본)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"기본은 op-agnostic : 어떤 operation 타입이든 패스 매니저가 대상으로 삼는 타입에서 실행이 됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이런 패스는 자기가 어떤 op에서 돌지 가정을 하면 안된다. (canonicalize, cse)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"구현 포인트는 \",[\"$\",\"code\",null,{\"children\":\"OperationPass\u003c\u003e\"}],\" (탬플릿 인자 X) + runOnOperation() 오버라이드\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Filtered Operation Pass\\n필요하면 이 패스는 특정한 op/컨텍스트 에서만 실행 되도록 추가 필터링을 적용할 수 있다.\\nA - 정적 스케줄 필터링 : canScheduleOn\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"bool canScheduleOn(RegisteredOperationName opInfo) const 로 어떤 op 타입에 스케줄 가능한지 제약을 선언함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"FunctionOpInterface 를 구현한 op에서만 실행함.\\n아주 중요한 상속 규칙은\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 필터가 걸린 패스를 op-agnostic pass manager에 넣으면 그 pass manager(안의 모든 패스 포함)가 그 제약을 상속한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그래서 any(cse, my-function-pass) 같은 파이프라인ㄷ 실제로는 FunctionOpInterface op들만 대상으로 cse 까지 같이 돌아버린다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"B - 정적 필터링\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Op 타입 1개로 제한함 : \",[\"$\",\"code\",null,{\"children\":\"OperationPass\u003cfunc::FuncOp\u003e\"}],\" 처럼 템플릿에 op 타입을 넣으면 자동 필터링이 됨\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"인터페이스로 제한함 : \",[\"$\",\"code\",null,{\"children\":\"InterfacePass\u003cFunctionOpInterface\u003e\"}],\" 기반으로 작성하면 자동 필터링이 됨\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3) Dependent Dialects\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"패스가 어떤 dialect의 entity(ops/types/attrs 등)를 새로 만들 수 있다면, 그 dialect가 미리 로드 되어 있어야 함.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"특히 멀티 스레드 pipline 시작 전\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"이를 위해 패스는 getDependentDialects() 를 Override 해서 필요 dialect 목록을 명시적으로 선언해야 함.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"TableGen에서도 dependentDialects 필드로 선언이 가능\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4) Pass Initialization hook\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"패스가 런타임에 만들면 비싼 상태를 갖는 경우\",\"\\n\",\"$Le\",\"\\n\"]}],\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\"]}],\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\",\"\\n\",\"$L28\",\"\\n\",\"$L29\",\"\\n\",\"$L2a\",\"\\n\",\"$L2b\",\"\\n\",\"$L2c\",\"\\n\",\"$L2d\",\"\\n\",\"$L2e\",\"\\n\",\"$L2f\",\"\\n\",\"$L30\",\"\\n\",\"$L31\",\"\\n\",\"$L32\",\"\\n\",\"$L33\",\"\\n\",\"$L34\",\"\\n\",\"$L35\",\"\\n\",\"$L36\",\"\\n\",\"$L37\",\"\\n\",\"$L38\",\"\\n\",\"$L39\",\"\\n\",\"$L3a\",\"\\n\",\"$L3b\",\"\\n\",\"$L3c\",\"\\n\",\"$L3d\",\"\\n\",\"$L3e\"]}],\"$L3f\",\"$L40\"]}]\n"])</script><script>self.__next_f.push([1,"41:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"예시로 PDL Pattern bytecode compile case\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"LogicalResult initialize(MLIRContext *context) 를 override 해 pipeline 1회 실행당 1번 초기화 가능\"}],\"\\n\"]}]\nf:[\"$\",\"li\",null,{\"children\":[\"여기서는 getContext / getOperation / getAnalysis 같은 per-run API 사용 금지 (현재 op가 없기 때문)\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"제공된 context 로만 작업 해야 함.\"}],\"\\n\"]}],\"\\n\"]}]\n10:[\"$\",\"li\",null,{\"children\":\"실패 시 진단 메시지 출력 후 failure() 반환 : Pipeline 중단\"}]\n11:[\"$\",\"p\",null,{\"children\":\"5) Analysis Management (분석) 모델\"}]\n12:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석은 변환 패스가 아니라 독립 클래스로, 요청 시 lazy 계산 + Cache 됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"분석 클래스 요구사항\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"생성자 : (Operation*) 또는 (Operation*, AnalysisManager\u0026)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"대상 operation을 수정하면 안 됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AnalysisManager\u0026 를 통해 의존 분석을 요청 가능\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n13:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석 무효화(invalidation) 제어\"}],\"\\n\"]}]\n14:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"bool isInvalidated(const PreservedAnalyses\u0026) 로 보존 세트에 없더라도 실제로는 무효화할지를 더 정교하게 결정이 가능함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"의존 분석이 있다면 그 무효화도 함께 확인해야 한다.\"}],\"\\n\"]}]\n15:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"패스에서 분석 조회 API\"}],\"\\n\"]}]\n16:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"OperationPass가 제공함\"}],\"\\n\"]}]\n17:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"  - getAnalysis\u003c\u003e (없으면 생성)\\n  - getCachedAnalysis\u003c\u003e (있을 경우에만)\\n  - getCachedParentAnalysis\u003c\u003e\\n  - getCachedChildAnalysis\u003c\u003e\\n  - getChildAnalysis\u003c\u003e (없으면 생성함)\\n\"}]}]\n18:[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석 보존 (PreservedAnalyses)\"}],\"\\n\"]}]\n19:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"기본적으로 패스가 지나가면 분석은 다 무효화된다고 가정\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"바뀌지 않았거나 유지됨을 보장하면 패스가 명시적으로 표시해야 함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"markAllAnalysesPreserved()\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"markAnalysesPreserved\u003cA, B...\u003e()\"}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n1a:[\"$\",\"p\",null,{\"children\":\"6) Pass failure\"}]\n1b:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"패스는 graceful fail이 가능함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"불변식이 깨져 IR이 유효하지 않을 수 있으면 signalPassFailure() 호출\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"실패가 발생하면\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"파이프라인의 나머지 패스 실행이 중단됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"최상위 PassManager::run 이 failure을 반환함\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n1c:[\"$\",\"p\",null,{\"children\":\"7) Pass Manager 구조 : PassManager vs OpPassManager\"}]\n1d:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"PassManager\"}],\"\\n\"]}]\n1e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"전체 파이프라인의 최상위 엔트리 + 전역 설정 담당\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"동시에 top-level OpPassManager 역할도 함\"}],\"\\n\"]}]\n1f:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"OpPassManager\"}],\"\\n\"]}]\n20:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"특정 중첩 레벨의 oper"])</script><script>self.__next_f.push([1,"ation 들에 대해 실행될 패스들의 컬렉션\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"두 종류\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"op-specific: 특정 op 타입에 고정(anchor)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"op-agnostic: 특정 타입에 제한 없이 가능한 op들에 실행\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Anchor op 타입 요구조건은\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"등록되어 있고, IsolatedFromAbove trait 이어야 한다는 점\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"현재 레벨 이상을 건드리면 SSA/use-list 등을 잘못 건드릴 위험이 있기 때문\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n21:[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Nesting으로 파이프라인 구성\"}],\"\\n\"]}]\n22:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"nest\u003cOpT\u003e()\"}],\" : 특정 op 타입 레벨로 중첩 PM 생성\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"nestAny() : op-agnostic 중첩 PM 생성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 중첩은 IR의 Region 안 operation 구조적 중첩과 대응됨\"}],\"\\n\"]}]\n23:[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"실행 방식 (중요한 실행 모델)\"}],\"\\n\"]}]\n24:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"한 operation을 잡고 그 op에 걸린 패스들을 연속으로 전부 실행 한 다음, 다음 operation으로 넘어간다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"효과는\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"함수 단위로 집중하여 캐시 / 지역성이 좋아지고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"함수 파이프라인을 병렬 실행 하여 멀티스레딩 시 작업(job) 구성 효율이 좋아짐.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n25:[\"$\",\"p\",null,{\"children\":\"8) Dynamic Pass Pipelines (패스 내부에서 파이프라인 실행)\"}]\n26:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"어떤 Pass는 실행 중에 조건에 따라 추가 파이프라인을 돌리고 싶을 수 있다.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"inliner가 중간에 단순화 파이프라인을 실행하는 케이스\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이때 Pass::runPipeline(OpPassManager \u0026, Operation *) 로 현재 op 또는 그 아래 op들에 대해 동적 파이프라인 실행 가능\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"장점은 분석 / Instrumentation / PassManager 구성요소가 동적 파이프라인에도 제대로 연동된다는 점\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"권장 사항은 Pass 내부에서 새 PassManager 를 만들기 보다 runPipeline을 사용함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"OpPassManager 는 copy-safe \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 가능하면 파이프라인을 캐시해서 재사용함.\"]}],\"\\n\"]}]\n27:[\"$\",\"p\",null,{\"children\":\"9) Instance-Specific Pass Options (옵션)\"}]\n28:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"패스는 인스턴스별 옵션을 \",[\"$\",\"code\",null,{\"children\":\"Option\u003c\u003e, ListOption\u003c\u003e\"}],\" 로 정의가 가능함\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM command line 스타일을 따른다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"ListOption은 콤마로 분리되지만, 원소 내부의 서브 범위 등은 콤마를 separator로 안 볼 수 있는 규칙이 있음\"}],\"\\n\"]}]\n29:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"PassPipelineRegistration 옵션\"}],\"\\n\"]}]\n2a:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"파이프라인 등록 시 PassPipelineOptions 를 상속한 옵션 구조체를 제공 가능함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"빌더 시그니쳐 : void (OpPassManager \u0026pm, const Options\u0026)\"}],\"\\n\"]}]\n2b:[\"$\",\"p\",null,{\"children\":\"10) Pass Statistics\"}]\n2c:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"컴파일러가 뭘 얼마나 했는지를 패스 인스턴스 별로 카운트 / 집계함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Pass::Statistic 을 "])</script><script>self.__next_f.push([1,"사용함 (원자적 unsigned 처럼 증가 가능함)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"출력은\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"API : PassManager::enableStatistics\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CLI : -mlir-pass-statistics, -mlir-pass-statistics-display (pipeline/tree vs list view)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n2d:[\"$\",\"p\",null,{\"children\":\"11) Pass Registration \u0026 Pipeline Registration\"}]\n2e:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"PassRegistration\"}],\"\\n\"]}]\n2f:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"패스 클래스를 텍스트 파이프라인에서 생성 가능하게 등록\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"getArgument() 가 텍스트 식별자, getDescription()이 요약 설명\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"기본 생성 불가 패스는 \\\"생성 콜백\\\" 으로 등록이 가능함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"copy-constructible + 데이터 공유 주의 (병렬 실행 때문)\"}],\"\\n\"]}]\n30:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"PassPipelineRegistration\"}],\"\\n\"]}]\n31:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"자주 쓰는 파이프라인 자체를 하나의 이름으로 등록함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"OpPassManager에 패스를 추가하는 빌더 함수 (또는 람다) 제공된\"}],\"\\n\"]}]\n32:[\"$\",\"p\",null,{\"children\":\"12) Textual Pass Pipeline Specification (문자열 파이프라인 문법)\"}]\n33:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"중첩 구조 / 패스 이름 / 파이프라인 이름 / 옵션을 문자열로 표현 함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"EBNF 핵심:\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"op-anchor(elem, elem, ...)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"elem은 중첩 pipeline 이거나 pass-name / pass-pipeline-name + Option 이 가능함\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"op-anchor는 func.func, builtin.module 같은 op mnenmonic 또는 any\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"OpPassManager::printAsTextualPipeline(...) 로 라운드트립 지원하려면 Pass::getArgument() 구현 필요\"}],\"\\n\"]}]\n34:[\"$\",\"p\",null,{\"children\":\"13) Declarative Pass Specification (TableGen 기반)\"}]\n35:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"패스도 operation 처럼 일부를 TableGen으로 선언이 가능함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"registration boilerplate 생성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"옵션 / 통계 / 의존 dialect 선언\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"문서 (gen-pass-doc) 생성\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"gen-pass-decls\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"register\u003cPassName\u003e()\"}],\" 와 그룹 등록 함수 생성\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"MyPassOptions 구조체 생성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"impl::MyPassBase 같은 베이스 클래스 생성 (옵션 / 통계 멤버 포함)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"매크로 (GEN_PASS_REGISTRATION, GEN_PASS_DECL, GEN_PASS_DEF_...) 로 필요한 부분만 포함\"}],\"\\n\"]}]\n36:[\"$\",\"p\",null,{\"children\":\"14) Pass Instrumentation\"}]\n37:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"PassInstrumentation 으로 패스 실행/분석 계산 이벤트에 hook\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"runBeforePipeline / runAfterPipeline\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"runBeforePass / runAfterPass / runAfterPassFailed\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"runBeforeAnalysis / runAfterAnalysis\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"PassManager에 addInstrumentation(...) 로 등록\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Hook 호출은 스택처럼 (LIFO) before / after가 짝지어 실행됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Instrumentation hook 은 thread-safe 하게 호출이 보장됨.\"}],\"\\n\"]}]\n38:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Standard Instrumenta"])</script><script>self.__next_f.push([1,"tions\"}],\"\\n\"]}]\n39:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Pass Timing\"}],\"\\n\"]}]\n3a:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"PassManager::enableTiming 또는 mlir-opt -mlir-timing\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"표시모드는\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"list(-mlir-timing-display=list) / tree(기본)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"JSON 출력 (-mlir-output-format=json)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"멀티스레드 에서는 User Time(총 CPU)과 Wall Time(최장 스레드) 의미 차이를 주의\"}],\"\\n\"]}]\n3b:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"IR Printing\"}],\"\\n\"]}]\n3c:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"패스 전/후 IR 덤프 및 필터링\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-print-ir-before=..., -mlir-print-ir-after=...\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-print-ir-before-all, -mlir-print-ir-after-all\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-print-ir-after-change(변경된 경우만, 해시 기반)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-print-ir-after-failure(실패 시만)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-print-ir-module-scope(모듈 스코프 출력, threading disable 필요)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-print-ir-tree-dir=...(디렉토리 트리로 파일 출력)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"-mlir-use-nameloc-as-prefix(named loc로 SSA 이름 프리픽스)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n3d:[\"$\",\"p\",null,{\"children\":\"15) Crash / Failure Reproduction (재현 파일 생성)\"}]\n3e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"크래시나 패스 실패 시 reproducer(입력 IR + 파이프라인 설정) 을 .mlir로 덤프 가능\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"활성화\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"API : PassManager::enableCrashReproducerGeneration\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CLI : mlir-pass-pipeline-crash-reproducer\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"재현 실행 : mlir-opt -run-reproducer\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Local reproducer (실패 직전 IR 포함) 도 가능함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"CLI: mlir-pass-pipeline-local-reproducer\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"단, 멀티스레딩 비활성화 필요(-mlir-disable-threading)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n3f:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n40:[\"$\",\"$L41\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"42:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR docs PassManagement 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Pass Infrastructure\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L42\",\"3\",{}]]\n8:null\n"])</script></body></html>