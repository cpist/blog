<!DOCTYPE html><!--l8yvcX2zcoGhp9hpJxEKS--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR Transform Tutorial Ch 3 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="More than Simple Transform Operations"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Transform Tutorial Ch 3 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-11-29</div><p style="color:#333">More than Simple Transform Operations</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>1) Transform의 재사용성에 포커싱을 맞춘다.</p>
<p>매번 반복되는 패턴에 대해서는 TransformEachOpTraint을 쓰는것이 좋다.</p>
<ul>
<li>Transform 연산을 만들때마다<!-- -->
<ul>
<li>payload를 검증하고</li>
<li>여러 operation에 대해서 loop를 돌리고</li>
<li>결과를 모아서 반환하는 것이 너무 반복적이고 귀찮다.</li>
</ul>
</li>
</ul>
<ul>
<li>이를 해결하기 위한 방안이 언급한 TransformEachOpTrait</li>
</ul>
<p>이 Trait을 쓸 경우</p>
<ul>
<li>apply() 전체를 직접 구현할 필요가 없고</li>
<li>대신 applyToOne() 만 구현하면 된다.</li>
</ul>
<pre><code>applyToOne(rewriter, payloadOp, results, state)
</code></pre>
<ul>
<li>각 payload operation 하나만 처리</li>
<li>나머지 반복/검증/결과 병합은 trait이 자동 처리</li>
</ul>
<p>2) Handle 타입을 더 똑똑하게 제한하는 법 (Type Constraint)</p>
<p>기존 handle 타입은 아래와 같이 아무 op나 다 들어올수가 있음.</p>
<pre><code>!transform.any_op
</code></pre>
<p>해결책은 concrete Op 타입 을 쓰는 법</p>
<pre><code>Transform_ConcreteOpType&lt;&quot;func.call&quot;&gt;
</code></pre>
<p>func.call 만 받으라고 타입으로 강제 하는 것</p>
<p>3) interface를 구현한 op만 허용하는 방법 - 직접 타입을 만든다면?</p>
<ul>
<li>CallOpInterface 를 구현한 op만 받고 싶은데</li>
<li>Transform dialect 에 그런 타입이 없다면</li>
</ul>
<p>해결책은 Transform 용 커스텀 타입을 정의하는 것이다.</p>
<pre><code>def CallOpInterfaceHandle : TypeDef&lt;...&gt; {
  let mnemonic = &quot;my.call_op_interface&quot;;
}
</code></pre>
<p>그리고 C++ 에서</p>
<pre><code>checkPayload(...) {
  if (!isa&lt;CallOpInterface&gt;(op))
    error!
}
</code></pre>
<p>이것의 효과는</p>
<ul>
<li>transform IR 단계에서 사전 검증</li>
<li>런타임 전에 잘못된 사용을 차단함.</li>
</ul>
<p>4) 오히려 여러 타입을 허용하고 싶을 때는 AnyTypeOf</p>
<pre><code>AnyTypeOf&lt;[
  Transform_ConcreteOpType&lt;&quot;func.call&quot;&gt;,
  CallOpInterfaceHandle
]&gt;
</code></pre>
<p>위의 의미는</p>
<ul>
<li>func.call 도 좋고</li>
<li>CallOpInterface 구현 op도 좋다.</li>
</ul>
<p>5) Handle을 consume 하는 Transform 연산</p>
<ul>
<li>기존 op를 완전히 다른 op로 바꾸는 경우<!-- -->
<ul>
<li>func.call <code>-&gt;</code> my.mm4</li>
</ul>
</li>
<li>기존 handle은 더 이상 의미가 없다.</li>
<li>새로운 handle을 결과로 만들어야 한다.</li>
</ul>
<ul>
<li>핵심 포인트</li>
</ul>
<ul>
<li>applyToOne() 에서<!-- -->
<ul>
<li>새 op 생성</li>
<li>results.push_back(newOp)</li>
</ul>
</li>
<li>Memory effect에<!-- -->
<ul>
<li>consumesHandle</li>
<li>producesHandle</li>
<li>modifiesPayload
중요한 제약 사항도 있는데</li>
</ul>
</li>
<li>applyToOne() 은<!-- -->
<ul>
<li>결과가 항상 1개 이상일 때만 사용 가능함</li>
</ul>
</li>
<li>빈 Handle을 반환하려면<!-- -->
<ul>
<li>apply() 를 직접 구현해야 함.</li>
</ul>
</li>
</ul>
<p>6) MemoryEffects도 귀찮다면 Trait로 해결한다.
두가지 패턴을 자주 쓰는데</p>
<ul>
<li>FunctionalStyleTransformOpTrait</li>
</ul>
<ul>
<li>입력 handle : 전부 소비</li>
<li>결과 handle : 전부 생성</li>
<li>payload IR : 수정
결과 적으로 완전 변환(transform)</li>
</ul>
<ul>
<li>NavigationTransformOpTrait</li>
</ul>
<ul>
<li>입력 handle : 읽기만</li>
<li>결과 handle : 생성</li>
<li>payload IR : 읽기만
결과적으로 탐색 / 조회용 transform</li>
</ul>
<p>이 결과 getEffects() 직접 구현은 하지 않고, 선언 한 줄로 끝낸다.</p>
<p>참고로 NavigationTransformOpTrait 에 대해서 handle이 늘어나는것은 메타데이터가 늘어나는 것이지, 실제 코드 증가는 아님.
Transform dialect 에서 handle은 payload IR(실제 프로그램) 이 가리키는 참조 목록이다.
즉 payload IR은 알다시피 실제 실행되는 코드이고, handle은 이 op들을 보라는 메타 정보임.</p>
<pre><code>!transform.any_op
</code></pre>
<p>이런게 100개 생긴다고 해도 실제 IR은 1줄도 늘어나지 않는다는 것.</p>
<p>물론 handle은 쌓일 수 있긴 한데
(1) SSA 값이라는게 핵심</p>
<pre><code>%h1 = transform.match ...
%h2 = transform.filter %h1 ...
%h3 = transform.get_users %h2 ...
</code></pre>
<p>Transform IR도 SSA 임.</p>
<ul>
<li>%h1, %h2, %h3가 동시에 살아 있을 필요가 없고</li>
<li>이후 안쓰이면 dead value가 된다. (즉 DCE 대상임.)</li>
</ul>
<p>(2) Transform IR도 최적화 되는게 핵심
뭔말인고 하니 Transform IR은</p>
<ul>
<li>DCE (dead code elimination)</li>
<li>CSE</li>
<li>상수 전파와 같은 최적화를 자기 자신에게도 적용받음</li>
</ul>
<p>즉, 아래와 같은건 자동으로 제거된다.</p>
<pre><code>%tmp = transform.filter %h ...
// %tmp 안 씀
</code></pre>
<ul>
<li>consume을 하지 않는데 최적화가 되나?
여기서 NavigationTransformOp 의 경우 정보를 얻고</li>
</ul>
<ul>
<li>대상 IR은 그대로 하면서도</li>
<li>다양한 관점으로 같은 IR을 여러번 바라볼 수 있게 한다.</li>
<li>최적화 의사결정의 단계를 거침 (어떤 op들이 있는지, loop 안에 뭐가 있는지, call의 user는 누구인지)</li>
</ul>
<p>CT 여러번 찍는다고 몸이 바뀌는게 아닌것과 같음.</p>
<p>consume을 안해서 최적화에 유리한 케이스가 있음</p>
<ul>
<li>같은 대상에 여러 분석을 적용 가능하다던지</li>
</ul>
<pre><code>%loops = transform.match ops{loop}
%inner = transform.get_nested %loops
%calls = transform.match %inner ops{call}
</code></pre>
<ul>
<li>transform script가 선언적으로 된다던지<!-- -->
<ul>
<li>Navigation 과 Functional을 분리함으로서 이해, 디버깅, 재사용이 용이해 지게 함.</li>
</ul>
</li>
</ul>
<p>=====================================================================</p>
<p>요약해 보자면 Transform 연산을 더 안전하고, 재사용 가능하고, 덜 귀찮게 쓰는 방법들을 정리해 보았음.</p>
<ul>
<li>반복 로직은 TransformEachOpTrait</li>
<li>사전 조건 검증은 커스텀 Transform 타입으로</li>
<li>유연한 타입 허용은 AnyTypeOf로</li>
<li>op 교체는 handle 소비 / 생성으로</li>
<li>메모리 효과는 Trait으로 자동화함.</li>
</ul></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"l8yvcX2zcoGhp9hpJxEKS\",\"c\":[\"\",\"posts\",\"mlir\",\"md-t3\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-t3\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Transform Tutorial Ch 3 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-11-29\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"More than Simple Transform Operations\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"1) Transform의 재사용성에 포커싱을 맞춘다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"매번 반복되는 패턴에 대해서는 TransformEachOpTraint을 쓰는것이 좋다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Transform 연산을 만들때마다\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload를 검증하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"여러 operation에 대해서 loop를 돌리고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"결과를 모아서 반환하는 것이 너무 반복적이고 귀찮다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이를 해결하기 위한 방안이 언급한 TransformEachOpTrait\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이 Trait을 쓸 경우\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"apply() 전체를 직접 구현할 필요가 없고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"대신 applyToOne() 만 구현하면 된다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"applyToOne(rewriter, payloadOp, results, state)\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"각 payload operation 하나만 처리\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"나머지 반복/검증/결과 병합은 trait이 자동 처리\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) Handle 타입을 더 똑똑하게 제한하는 법 (Type Constraint)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"기존 handle 타입은 아래와 같이 아무 op나 다 들어올수가 있음.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"!transform.any_op\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"해결책은 concrete Op 타입 을 쓰는 법\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"Transform_ConcreteOpType\u003c\\\"func.call\\\"\u003e\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"func.call 만 받으라고 타입으로 강제 하는 것\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3) interface를 구현한 op만 허용하는 방법 - 직접 타입을 만든다면?\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"CallOpInterface 를 구현한 op만 받고 싶은데\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform dialect 에 그런 타입이 없다면\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"해결책은 Transform 용 커스텀 타입을 정의하는 것이다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"def CallOpInterfaceHandle : TypeDef\u003c...\u003e {\\n  let mnemonic = \\\"my.call_op_interface\\\";\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"그리고 C++ 에서\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"checkPayload(...) {\\n  if (!isa\u003cCallOpInterface\u003e(op))\\n    error!\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이것의 효과는\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform IR 단계에서 사전 검증\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"런타임 전에 잘못된 사용을 차단함.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4) 오히려 여러 타입을 허용하고 싶을 때는 AnyTypeOf\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"AnyTypeOf\u003c[\\n  Transform_ConcreteOpType\u003c\\\"func.call\\\"\u003e,\\n  CallOpInterfaceHandle\\n]\u003e\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"위의 의미는\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"func.call 도 좋고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CallOpInterface 구현 op도 좋다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"5) Handle을 consume 하는 Transform 연산\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"기존 op를 완전히 다른 op로 바꾸는 경우\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"func.call \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" my.mm4\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"기존 handle은 더 이상 의미가 없다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"새로운 handle을 결과로 만들어야 한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핵심 포인트\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"applyToOne() 에서\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"새 op 생성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"results.push_back(newOp)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Memory effect에\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"consumesHandle\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"producesHandle\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"modifiesPayload\\n중요한 제약 사항도 있는데\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"applyToOne() 은\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"결과가 항상 1개 이상일 때만 사용 가능함\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"빈 Handle을 반환하려면\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"apply() 를 직접 구현해야 함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"6) MemoryEffects도 귀찮다면 Trait로 해결한다.\\n두가지 패턴을 자주 쓰는데\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",\"$Le\",\"\\n\"]}],\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\"]}],\"$L28\",\"$L29\"]}]\n"])</script><script>self.__next_f.push([1,"2a:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"li\",null,{\"children\":\"FunctionalStyleTransformOpTrait\"}]\nf:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"입력 handle : 전부 소비\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"결과 handle : 전부 생성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload IR : 수정\\n결과 적으로 완전 변환(transform)\"}],\"\\n\"]}]\n10:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"NavigationTransformOpTrait\"}],\"\\n\"]}]\n11:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"입력 handle : 읽기만\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"결과 handle : 생성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload IR : 읽기만\\n결과적으로 탐색 / 조회용 transform\"}],\"\\n\"]}]\n12:[\"$\",\"p\",null,{\"children\":\"이 결과 getEffects() 직접 구현은 하지 않고, 선언 한 줄로 끝낸다.\"}]\n13:[\"$\",\"p\",null,{\"children\":\"참고로 NavigationTransformOpTrait 에 대해서 handle이 늘어나는것은 메타데이터가 늘어나는 것이지, 실제 코드 증가는 아님.\\nTransform dialect 에서 handle은 payload IR(실제 프로그램) 이 가리키는 참조 목록이다.\\n즉 payload IR은 알다시피 실제 실행되는 코드이고, handle은 이 op들을 보라는 메타 정보임.\"}]\n14:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"!transform.any_op\\n\"}]}]\n15:[\"$\",\"p\",null,{\"children\":\"이런게 100개 생긴다고 해도 실제 IR은 1줄도 늘어나지 않는다는 것.\"}]\n16:[\"$\",\"p\",null,{\"children\":\"물론 handle은 쌓일 수 있긴 한데\\n(1) SSA 값이라는게 핵심\"}]\n17:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%h1 = transform.match ...\\n%h2 = transform.filter %h1 ...\\n%h3 = transform.get_users %h2 ...\\n\"}]}]\n18:[\"$\",\"p\",null,{\"children\":\"Transform IR도 SSA 임.\"}]\n19:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"%h1, %h2, %h3가 동시에 살아 있을 필요가 없고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이후 안쓰이면 dead value가 된다. (즉 DCE 대상임.)\"}],\"\\n\"]}]\n1a:[\"$\",\"p\",null,{\"children\":\"(2) Transform IR도 최적화 되는게 핵심\\n뭔말인고 하니 Transform IR은\"}]\n1b:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"DCE (dead code elimination)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CSE\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"상수 전파와 같은 최적화를 자기 자신에게도 적용받음\"}],\"\\n\"]}]\n1c:[\"$\",\"p\",null,{\"children\":\"즉, 아래와 같은건 자동으로 제거된다.\"}]\n1d:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%tmp = transform.filter %h ...\\n// %tmp 안 씀\\n\"}]}]\n1e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"consume을 하지 않는데 최적화가 되나?\\n여기서 NavigationTransformOp 의 경우 정보를 얻고\"}],\"\\n\"]}]\n1f:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"대상 IR은 그대로 하면서도\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다양한 관점으로 같은 IR을 여러번 바라볼 수 있게 한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"최적화 의사결정의 단계를 거침 (어떤 op들이 있는지, loop 안에 뭐가 있는지, call의 user는 누구인지)\"}],\"\\n\"]}]\n20:[\"$\",\"p\",null,{\"children\":\"CT 여러번 찍는다고 몸이 바뀌는게 아닌것과 같음.\"}]\n21:[\"$\",\"p\",null,{\"children\":\"consume을 안해서 최적화에 유리한 케이스가 있음\"}]\n22:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"같은 대상에 여러 분석을 적용 가능하다던지\"}],\"\\n\"]}]\n23:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%loops = transform.match ops{loop}\\n%inner = transform.get_nested %loops\\n%calls = transform.match %inner ops{call}\\n\"}]}]\n24:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"transform script가 선언적으로 된다던지\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Navigation 과 Functional을 분리함으로서 이해, 디버깅, 재사용이 용이해 지게 함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n25:[\"$\",\"p"])</script><script>self.__next_f.push([1,"\",null,{\"children\":\"=====================================================================\"}]\n26:[\"$\",\"p\",null,{\"children\":\"요약해 보자면 Transform 연산을 더 안전하고, 재사용 가능하고, 덜 귀찮게 쓰는 방법들을 정리해 보았음.\"}]\n27:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"반복 로직은 TransformEachOpTrait\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"사전 조건 검증은 커스텀 Transform 타입으로\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"유연한 타입 허용은 AnyTypeOf로\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"op 교체는 handle 소비 / 생성으로\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"메모리 효과는 Trait으로 자동화함.\"}],\"\\n\"]}]\n28:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n29:[\"$\",\"$L2a\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"2b:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Transform Tutorial Ch 3 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"More than Simple Transform Operations\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L2b\",\"3\",{}]]\n8:null\n"])</script></body></html>