<!DOCTYPE html><!--rgkoFkL_SxE7swusMMKT_--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/cbd55ab9639e1e66.js"/><script src="/blog/_next/static/chunks/8c4bb65ca9f95eb5.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-8ff2f6efb1e78309.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><title>MLIR Toy Tutorial Ch 1 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Introduction to the Toy language and the definition of its AST."/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Toy Tutorial Ch 1 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-10-25</div><p style="color:#333">Introduction to the Toy language and the definition of its AST.</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><ol>
<li>제시된 Toy 언어는</li>
</ol>
<ul>
<li>Tensor로 계산 (Rank는 최대 2, 벡터/형렬 까지만)</li>
<li>타입은 double(64-bit float) 로 하나</li>
<li>값은 immutable: a = b + c 같은 연산을 할 경우 새로운 값이 생기고 원래 값은 바뀌지 않음</li>
<li>내장함수로는 transpose() 와 print()</li>
</ul>
<pre><code>var a = [[1, 2, 3], [4, 5, 6]];   # 자동으로 &lt;2,3&gt; 행렬로 추론됨
var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6]; # 납작한 배열을 &lt;2,3&gt;으로 “reshape”해서 선언
print(transpose(a) * transpose(b));
</code></pre>
<p>여기서 핵심은:</p>
<ul>
<li>이중 리스트인 a는 자동으로 <strong>&lt;<code>2,3</code>&gt;</strong> 으로 shape 추론</li>
<li>1차원 리스트인 b는 원소 개수가 같기 떄문에 <strong>&lt;<code>2,3</code>&gt;</strong> 를 붙여서 텐서 형태를 바꿀수 있음 (Reshape, 재형상화)</li>
</ul>
<ol start="2">
<li>Toy 의 함수가 &quot;제네릭&quot; 인 이유
Toy 함수 파라미터는 분명 텐서이지만 shape를 알수가 없음.</li>
</ol>
<pre><code>def multiply_transpose(a, b) {
  return transpose(a) * transpose(b);
}
</code></pre>
<p>즉 함수 내용 만 보면 어떤 텐서든 transpose 하고 곱하라는 것이지만,
<strong>&lt;<code>2,3</code>&gt;</strong> 과 <strong>&lt;<code>2,3</code>&gt;</strong> 을 한번 호출했다면, 컴파일러가 이 버전으로 specialize (전문화) 를 생성 함.
똑같은 걸 또 부르면 만든 specialize 버전을 재사용 하면 됨.
그런데, <strong>&lt;<code>3,2</code>&gt;</strong> 와 <strong>&lt;<code>3,2</code>&gt;</strong> 를 부른다면 새로운 specialize를 한번 더 생성해야 함.
shape가 안맞으면 당연히 에러를 출력해야 함.
따라서 함수는 제네릭이어야 함. 호출할 때마다 shape가 정해지고, specialize 된 함수가 생성되는 방향</p>
<ol start="3">
<li>AST는 무엇인가?</li>
</ol>
<p>심플함, 코드를 tree 형태로 만든것.
이건 함수다, 블록이다, 변수 선언이다, 함수 호출이다. 이걸 구조화 한것.</p>
<pre><code>Module:
  Function 
    Proto &#x27;multiply_transpose&#x27; @test/Examples/Toy/Ch1/ast.toy:4:1
    Params: [a, b]
    Block {
      Return
        BinOp: * @test/Examples/Toy/Ch1/ast.toy:5:25
          Call &#x27;transpose&#x27; [ @test/Examples/Toy/Ch1/ast.toy:5:10
            var: a @test/Examples/Toy/Ch1/ast.toy:5:20
          ]
          Call &#x27;transpose&#x27; [ @test/Examples/Toy/Ch1/ast.toy:5:25
            var: b @test/Examples/Toy/Ch1/ast.toy:5:35
          ]
    } // Block
  Function 
    Proto &#x27;main&#x27; @test/Examples/Toy/Ch1/ast.toy:8:1
    Params: []
    Block {
      VarDecl a&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:11:3
        Literal: &lt;2, 3&gt;[ &lt;3&gt;[ 1.000000e+00, 2.000000e+00, 3.000000e+00], &lt;3&gt;[ 4.000000e+00, 5.000000e+00, 6.000000e+00]] @test/Examples/Toy/Ch1/ast.toy:11:11
      VarDecl b&lt;2, 3&gt; @test/Examples/Toy/Ch1/ast.toy:15:3
        Literal: &lt;6&gt;[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @test/Examples/Toy/Ch1/ast.toy:15:17
      VarDecl c&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:19:3
        Call &#x27;multiply_transpose&#x27; [ @test/Examples/Toy/Ch1/ast.toy:19:11
          var: a @test/Examples/Toy/Ch1/ast.toy:19:30
          var: b @test/Examples/Toy/Ch1/ast.toy:19:33
        ]
      VarDecl d&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:22:3
        Call &#x27;multiply_transpose&#x27; [ @test/Examples/Toy/Ch1/ast.toy:22:11
          var: b @test/Examples/Toy/Ch1/ast.toy:22:30
          var: a @test/Examples/Toy/Ch1/ast.toy:22:33
        ]
      VarDecl e&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:25:3
        Call &#x27;multiply_transpose&#x27; [ @test/Examples/Toy/Ch1/ast.toy:25:11
          var: c @test/Examples/Toy/Ch1/ast.toy:25:30
          var: d @test/Examples/Toy/Ch1/ast.toy:25:33
        ]
      VarDecl f&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:28:3
        Call &#x27;multiply_transpose&#x27; [ @test/Examples/Toy/Ch1/ast.toy:28:11
          var: a @test/Examples/Toy/Ch1/ast.toy:28:30
          var: c @test/Examples/Toy/Ch1/ast.toy:28:33
        ]
    } // Block
</code></pre>
<p>이 dump 내용을 차근차근 분석해 보면</p>
<ul>
<li>Module : 파일 전체</li>
<li>Function multiply_transpose</li>
<li>proto : 함수 이름 / 위치 / 파라미터</li>
<li>BinOp: * : 곱셈 연산</li>
<li>VarDecl a : 변수 a 선언</li>
<li>Literal <strong>&lt;<code>2,3</code>&gt;</strong> ... : 리터럴 텐서 값</li>
<li>VarDecl b**&lt;<code>2,3</code>&gt;** : b 선언 (reshape)</li>
<li>VarDecl c : 함수 호출 결과 저장</li>
</ul>
<p>@test/Examples/Toy/Ch1/ast.toy:19:11 이런건 이 노드가 소스코드의 몇 번째 줄 / 몇 번째 칸에서 왔는지를 적어둔 것.</p>
<ol start="4">
<li>Lexer / Parser
Lexer는 어휘 분석기로 글자를 토큰으로 자르는 역할
Parser는 구문 분석기로 토큰을 읽어서 AST로 만드는 역할
튜토리얼은 재귀 하강 (Recursive Descent) 이라는 근본 Parser 방식을 사용함.</li>
</ol>
<p>=====================================================================</p>
<p>Flow를 요약해 보자면
소스코드 -&gt; Lexer (토큰화) -&gt; Parser (AST 만들기) -&gt; MLIR 로의 변환</p></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2025<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/cbd55ab9639e1e66.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"rgkoFkL_SxE7swusMMKT_\",\"c\":[\"\",\"posts\",\"mlir\",\"md1\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md1\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2025,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:T7a9,"])</script><script>self.__next_f.push([1,"Module:\n  Function \n    Proto 'multiply_transpose' @test/Examples/Toy/Ch1/ast.toy:4:1\n    Params: [a, b]\n    Block {\n      Return\n        BinOp: * @test/Examples/Toy/Ch1/ast.toy:5:25\n          Call 'transpose' [ @test/Examples/Toy/Ch1/ast.toy:5:10\n            var: a @test/Examples/Toy/Ch1/ast.toy:5:20\n          ]\n          Call 'transpose' [ @test/Examples/Toy/Ch1/ast.toy:5:25\n            var: b @test/Examples/Toy/Ch1/ast.toy:5:35\n          ]\n    } // Block\n  Function \n    Proto 'main' @test/Examples/Toy/Ch1/ast.toy:8:1\n    Params: []\n    Block {\n      VarDecl a\u003c\u003e @test/Examples/Toy/Ch1/ast.toy:11:3\n        Literal: \u003c2, 3\u003e[ \u003c3\u003e[ 1.000000e+00, 2.000000e+00, 3.000000e+00], \u003c3\u003e[ 4.000000e+00, 5.000000e+00, 6.000000e+00]] @test/Examples/Toy/Ch1/ast.toy:11:11\n      VarDecl b\u003c2, 3\u003e @test/Examples/Toy/Ch1/ast.toy:15:3\n        Literal: \u003c6\u003e[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @test/Examples/Toy/Ch1/ast.toy:15:17\n      VarDecl c\u003c\u003e @test/Examples/Toy/Ch1/ast.toy:19:3\n        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:19:11\n          var: a @test/Examples/Toy/Ch1/ast.toy:19:30\n          var: b @test/Examples/Toy/Ch1/ast.toy:19:33\n        ]\n      VarDecl d\u003c\u003e @test/Examples/Toy/Ch1/ast.toy:22:3\n        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:22:11\n          var: b @test/Examples/Toy/Ch1/ast.toy:22:30\n          var: a @test/Examples/Toy/Ch1/ast.toy:22:33\n        ]\n      VarDecl e\u003c\u003e @test/Examples/Toy/Ch1/ast.toy:25:3\n        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:25:11\n          var: c @test/Examples/Toy/Ch1/ast.toy:25:30\n          var: d @test/Examples/Toy/Ch1/ast.toy:25:33\n        ]\n      VarDecl f\u003c\u003e @test/Examples/Toy/Ch1/ast.toy:28:3\n        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:28:11\n          var: a @test/Examples/Toy/Ch1/ast.toy:28:30\n          var: c @test/Examples/Toy/Ch1/ast.toy:28:33\n        ]\n    } // Block\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Toy Tutorial Ch 1 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-10-25\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Introduction to the Toy language and the definition of its AST.\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"제시된 Toy 언어는\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Tensor로 계산 (Rank는 최대 2, 벡터/형렬 까지만)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"타입은 double(64-bit float) 로 하나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"값은 immutable: a = b + c 같은 연산을 할 경우 새로운 값이 생기고 원래 값은 바뀌지 않음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"내장함수로는 transpose() 와 print()\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"var a = [[1, 2, 3], [4, 5, 6]];   # 자동으로 \u003c2,3\u003e 행렬로 추론됨\\nvar b\u003c2, 3\u003e = [1, 2, 3, 4, 5, 6]; # 납작한 배열을 \u003c2,3\u003e으로 “reshape”해서 선언\\nprint(transpose(a) * transpose(b));\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"여기서 핵심은:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"이중 리스트인 a는 자동으로 \",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"2,3\"}],\"\u003e\"]}],\" 으로 shape 추론\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"1차원 리스트인 b는 원소 개수가 같기 떄문에 \",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"2,3\"}],\"\u003e\"]}],\" 를 붙여서 텐서 형태를 바꿀수 있음 (Reshape, 재형상화)\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Toy 의 함수가 \\\"제네릭\\\" 인 이유\\nToy 함수 파라미터는 분명 텐서이지만 shape를 알수가 없음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"def multiply_transpose(a, b) {\\n  return transpose(a) * transpose(b);\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"즉 함수 내용 만 보면 어떤 텐서든 transpose 하고 곱하라는 것이지만,\\n\",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"2,3\"}],\"\u003e\"]}],\" 과 \",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"2,3\"}],\"\u003e\"]}],\" 을 한번 호출했다면, 컴파일러가 이 버전으로 specialize (전문화) 를 생성 함.\\n똑같은 걸 또 부르면 만든 specialize 버전을 재사용 하면 됨.\\n그런데, \",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"3,2\"}],\"\u003e\"]}],\" 와 \",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"3,2\"}],\"\u003e\"]}],\" 를 부른다면 새로운 specialize를 한번 더 생성해야 함.\\nshape가 안맞으면 당연히 에러를 출력해야 함.\\n따라서 함수는 제네릭이어야 함. 호출할 때마다 shape가 정해지고, specialize 된 함수가 생성되는 방향\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"AST는 무엇인가?\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"심플함, 코드를 tree 형태로 만든것.\\n이건 함수다, 블록이다, 변수 선언이다, 함수 호출이다. 이걸 구조화 한것.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$e\"}]}],\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\"]}]]}]\n"])</script><script>self.__next_f.push([1,"f:[\"$\",\"p\",null,{\"children\":\"이 dump 내용을 차근차근 분석해 보면\"}]\n10:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Module : 파일 전체\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Function multiply_transpose\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"proto : 함수 이름 / 위치 / 파라미터\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"BinOp: * : 곱셈 연산\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"VarDecl a : 변수 a 선언\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Literal \",[\"$\",\"strong\",null,{\"children\":[\"\u003c\",[\"$\",\"code\",null,{\"children\":\"2,3\"}],\"\u003e\"]}],\" ... : 리터럴 텐서 값\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"VarDecl b**\u003c\",[\"$\",\"code\",null,{\"children\":\"2,3\"}],\"\u003e** : b 선언 (reshape)\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"VarDecl c : 함수 호출 결과 저장\"}],\"\\n\"]}]\n11:[\"$\",\"p\",null,{\"children\":\"@test/Examples/Toy/Ch1/ast.toy:19:11 이런건 이 노드가 소스코드의 몇 번째 줄 / 몇 번째 칸에서 왔는지를 적어둔 것.\"}]\n12:[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Lexer / Parser\\nLexer는 어휘 분석기로 글자를 토큰으로 자르는 역할\\nParser는 구문 분석기로 토큰을 읽어서 AST로 만드는 역할\\n튜토리얼은 재귀 하강 (Recursive Descent) 이라는 근본 Parser 방식을 사용함.\"}],\"\\n\"]}]\n13:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n14:[\"$\",\"p\",null,{\"children\":\"Flow를 요약해 보자면\\n소스코드 -\u003e Lexer (토큰화) -\u003e Parser (AST 만들기) -\u003e MLIR 로의 변환\"}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"15:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Toy Tutorial Ch 1 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Introduction to the Toy language and the definition of its AST.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L15\",\"3\",{}]]\n8:null\n"])</script></body></html>