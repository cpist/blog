1:"$Sreact.fragment"
a:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
b:"$Sreact.suspense"
2:T7a9,Module:
  Function 
    Proto 'multiply_transpose' @test/Examples/Toy/Ch1/ast.toy:4:1
    Params: [a, b]
    Block {
      Return
        BinOp: * @test/Examples/Toy/Ch1/ast.toy:5:25
          Call 'transpose' [ @test/Examples/Toy/Ch1/ast.toy:5:10
            var: a @test/Examples/Toy/Ch1/ast.toy:5:20
          ]
          Call 'transpose' [ @test/Examples/Toy/Ch1/ast.toy:5:25
            var: b @test/Examples/Toy/Ch1/ast.toy:5:35
          ]
    } // Block
  Function 
    Proto 'main' @test/Examples/Toy/Ch1/ast.toy:8:1
    Params: []
    Block {
      VarDecl a<> @test/Examples/Toy/Ch1/ast.toy:11:3
        Literal: <2, 3>[ <3>[ 1.000000e+00, 2.000000e+00, 3.000000e+00], <3>[ 4.000000e+00, 5.000000e+00, 6.000000e+00]] @test/Examples/Toy/Ch1/ast.toy:11:11
      VarDecl b<2, 3> @test/Examples/Toy/Ch1/ast.toy:15:3
        Literal: <6>[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @test/Examples/Toy/Ch1/ast.toy:15:17
      VarDecl c<> @test/Examples/Toy/Ch1/ast.toy:19:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:19:11
          var: a @test/Examples/Toy/Ch1/ast.toy:19:30
          var: b @test/Examples/Toy/Ch1/ast.toy:19:33
        ]
      VarDecl d<> @test/Examples/Toy/Ch1/ast.toy:22:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:22:11
          var: b @test/Examples/Toy/Ch1/ast.toy:22:30
          var: a @test/Examples/Toy/Ch1/ast.toy:22:33
        ]
      VarDecl e<> @test/Examples/Toy/Ch1/ast.toy:25:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:25:11
          var: c @test/Examples/Toy/Ch1/ast.toy:25:30
          var: d @test/Examples/Toy/Ch1/ast.toy:25:33
        ]
      VarDecl f<> @test/Examples/Toy/Ch1/ast.toy:28:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:28:11
          var: a @test/Examples/Toy/Ch1/ast.toy:28:30
          var: c @test/Examples/Toy/Ch1/ast.toy:28:33
        ]
    } // Block
0:{"buildId":"-RSL23qilBsE-iik6CMrj","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Toy Tutorial Ch 1 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-10-25"}],["$","p",null,{"style":{"color":"#333"},"children":"Introduction to the Toy language and the definition of its AST."}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"제시된 Toy 언어는"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Tensor로 계산 (Rank는 최대 2, 벡터/형렬 까지만)"}],"\n",["$","li",null,{"children":"타입은 double(64-bit float) 로 하나"}],"\n",["$","li",null,{"children":"값은 immutable: a = b + c 같은 연산을 할 경우 새로운 값이 생기고 원래 값은 바뀌지 않음"}],"\n",["$","li",null,{"children":"내장함수로는 transpose() 와 print()"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"var a = [[1, 2, 3], [4, 5, 6]];   # 자동으로 <2,3> 행렬로 추론됨\nvar b<2, 3> = [1, 2, 3, 4, 5, 6]; # 납작한 배열을 <2,3>으로 “reshape”해서 선언\nprint(transpose(a) * transpose(b));\n"}]}],"\n",["$","p",null,{"children":"여기서 핵심은:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["이중 리스트인 a는 자동으로 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 으로 shape 추론"]}],"\n",["$","li",null,{"children":["1차원 리스트인 b는 원소 개수가 같기 떄문에 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 를 붙여서 텐서 형태를 바꿀수 있음 (Reshape, 재형상화)"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"Toy 의 함수가 \"제네릭\" 인 이유\nToy 함수 파라미터는 분명 텐서이지만 shape를 알수가 없음."}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def multiply_transpose(a, b) {\n  return transpose(a) * transpose(b);\n}\n"}]}],"\n",["$","p",null,{"children":["즉 함수 내용 만 보면 어떤 텐서든 transpose 하고 곱하라는 것이지만,\n",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 과 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 을 한번 호출했다면, 컴파일러가 이 버전으로 specialize (전문화) 를 생성 함.\n똑같은 걸 또 부르면 만든 specialize 버전을 재사용 하면 됨.\n그런데, ",["$","strong",null,{"children":["<",["$","code",null,{"children":"3,2"}],">"]}]," 와 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"3,2"}],">"]}]," 를 부른다면 새로운 specialize를 한번 더 생성해야 함.\nshape가 안맞으면 당연히 에러를 출력해야 함.\n따라서 함수는 제네릭이어야 함. 호출할 때마다 shape가 정해지고, specialize 된 함수가 생성되는 방향"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"AST는 무엇인가?"}],"\n"]}],"\n",["$","p",null,{"children":"심플함, 코드를 tree 형태로 만든것.\n이건 함수다, 블록이다, 변수 선언이다, 함수 호출이다. 이걸 구조화 한것."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$2"}]}],"\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8"]}]]}],null,"$L9"]}],"loading":null,"isPartial":false}
3:["$","p",null,{"children":"이 dump 내용을 차근차근 분석해 보면"}]
4:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Module : 파일 전체"}],"\n",["$","li",null,{"children":"Function multiply_transpose"}],"\n",["$","li",null,{"children":"proto : 함수 이름 / 위치 / 파라미터"}],"\n",["$","li",null,{"children":"BinOp: * : 곱셈 연산"}],"\n",["$","li",null,{"children":"VarDecl a : 변수 a 선언"}],"\n",["$","li",null,{"children":["Literal ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," ... : 리터럴 텐서 값"]}],"\n",["$","li",null,{"children":["VarDecl b**<",["$","code",null,{"children":"2,3"}],">** : b 선언 (reshape)"]}],"\n",["$","li",null,{"children":"VarDecl c : 함수 호출 결과 저장"}],"\n"]}]
5:["$","p",null,{"children":"@test/Examples/Toy/Ch1/ast.toy:19:11 이런건 이 노드가 소스코드의 몇 번째 줄 / 몇 번째 칸에서 왔는지를 적어둔 것."}]
6:["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"Lexer / Parser\nLexer는 어휘 분석기로 글자를 토큰으로 자르는 역할\nParser는 구문 분석기로 토큰을 읽어서 AST로 만드는 역할\n튜토리얼은 재귀 하강 (Recursive Descent) 이라는 근본 Parser 방식을 사용함."}],"\n"]}]
7:["$","p",null,{"children":"====================================================================="}]
8:["$","p",null,{"children":"Flow를 요약해 보자면\n소스코드 -> Lexer (토큰화) -> Parser (AST 만들기) -> MLIR 로의 변환"}]
9:["$","$La",null,{"children":["$","$b",null,{"name":"Next.MetadataOutlet","children":"$@c"}]}]
c:null
