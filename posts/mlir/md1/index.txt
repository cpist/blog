1:"$Sreact.fragment"
2:I[22016,["/blog/_next/static/chunks/796e69ae18b2784c.js"],""]
3:I[39756,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
4:I[37457,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
6:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"ViewportBoundary"]
b:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"MetadataBoundary"]
d:I[68027,[],"default"]
:HL["/blog/_next/static/chunks/d335db6b3f1a2619.css","style"]
0:{"P":null,"b":"KZfT5RBrf8atnI4ETYYwl","c":["","posts","mlir","md1",""],"q":"","i":false,"f":[[["",{"children":["posts",{"children":[["slug","mlir/md1","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/blog/_next/static/chunks/d335db6b3f1a2619.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","script","script-0",{"src":"/blog/_next/static/chunks/796e69ae18b2784c.js","async":true,"nonce":"$undefined"}]],["$","html",null,{"lang":"ko","children":["$","body",null,{"children":["$","main",null,{"children":[["$","header",null,{"style":{"display":"flex","justifyContent":"space-between","alignItems":"baseline","gap":12},"children":[["$","h1",null,{"style":{"margin":"8px 0"},"children":["$","$L2",null,{"href":"/","style":{"textDecoration":"none"},"children":"CPIST's blog"}]}],["$","nav",null,{"style":{"display":"flex","gap":12},"children":["$","$L2",null,{"href":"/posts","children":"Posts"}]}]]}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"12px 0 24px"}}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","footer",null,{"style":{"marginTop":48,"paddingTop":16,"borderTop":"1px solid #eee","color":"#666"},"children":["© ",2026," CPIST's blog"]}]]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",[["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true,"nonce":"$undefined"}]],["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],null]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:T7a9,Module:
  Function 
    Proto 'multiply_transpose' @test/Examples/Toy/Ch1/ast.toy:4:1
    Params: [a, b]
    Block {
      Return
        BinOp: * @test/Examples/Toy/Ch1/ast.toy:5:25
          Call 'transpose' [ @test/Examples/Toy/Ch1/ast.toy:5:10
            var: a @test/Examples/Toy/Ch1/ast.toy:5:20
          ]
          Call 'transpose' [ @test/Examples/Toy/Ch1/ast.toy:5:25
            var: b @test/Examples/Toy/Ch1/ast.toy:5:35
          ]
    } // Block
  Function 
    Proto 'main' @test/Examples/Toy/Ch1/ast.toy:8:1
    Params: []
    Block {
      VarDecl a<> @test/Examples/Toy/Ch1/ast.toy:11:3
        Literal: <2, 3>[ <3>[ 1.000000e+00, 2.000000e+00, 3.000000e+00], <3>[ 4.000000e+00, 5.000000e+00, 6.000000e+00]] @test/Examples/Toy/Ch1/ast.toy:11:11
      VarDecl b<2, 3> @test/Examples/Toy/Ch1/ast.toy:15:3
        Literal: <6>[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @test/Examples/Toy/Ch1/ast.toy:15:17
      VarDecl c<> @test/Examples/Toy/Ch1/ast.toy:19:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:19:11
          var: a @test/Examples/Toy/Ch1/ast.toy:19:30
          var: b @test/Examples/Toy/Ch1/ast.toy:19:33
        ]
      VarDecl d<> @test/Examples/Toy/Ch1/ast.toy:22:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:22:11
          var: b @test/Examples/Toy/Ch1/ast.toy:22:30
          var: a @test/Examples/Toy/Ch1/ast.toy:22:33
        ]
      VarDecl e<> @test/Examples/Toy/Ch1/ast.toy:25:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:25:11
          var: c @test/Examples/Toy/Ch1/ast.toy:25:30
          var: d @test/Examples/Toy/Ch1/ast.toy:25:33
        ]
      VarDecl f<> @test/Examples/Toy/Ch1/ast.toy:28:3
        Call 'multiply_transpose' [ @test/Examples/Toy/Ch1/ast.toy:28:11
          var: a @test/Examples/Toy/Ch1/ast.toy:28:30
          var: c @test/Examples/Toy/Ch1/ast.toy:28:33
        ]
    } // Block
5:["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Toy Tutorial Ch 1 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-10-25"}],["$","p",null,{"style":{"color":"#333"},"children":"Introduction to the Toy language and the definition of its AST."}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"1) 제시된 Toy 언어는"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Tensor로 계산 (Rank는 최대 2, 벡터/형렬 까지만)"}],"\n",["$","li",null,{"children":"타입은 double(64-bit float) 로 하나"}],"\n",["$","li",null,{"children":"값은 immutable: a = b + c 같은 연산을 할 경우 새로운 값이 생기고 원래 값은 바뀌지 않음"}],"\n",["$","li",null,{"children":"내장함수로는 transpose() 와 print()"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"var a = [[1, 2, 3], [4, 5, 6]];   # 자동으로 <2,3> 행렬로 추론됨\nvar b<2, 3> = [1, 2, 3, 4, 5, 6]; # 납작한 배열을 <2,3>으로 “reshape”해서 선언\nprint(transpose(a) * transpose(b));\n"}]}],"\n",["$","p",null,{"children":"여기서 핵심은:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["이중 리스트인 a는 자동으로 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 으로 shape 추론"]}],"\n",["$","li",null,{"children":["1차원 리스트인 b는 원소 개수가 같기 떄문에 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 를 붙여서 텐서 형태를 바꿀수 있음 (Reshape, 재형상화)"]}],"\n"]}],"\n",["$","p",null,{"children":"2) Toy 의 함수가 \"제네릭\" 인 이유\nToy 함수 파라미터는 분명 텐서이지만 shape를 알수가 없음."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def multiply_transpose(a, b) {\n  return transpose(a) * transpose(b);\n}\n"}]}],"\n",["$","p",null,{"children":["즉 함수 내용 만 보면 어떤 텐서든 transpose 하고 곱하라는 것이지만,\n",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 과 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," 을 한번 호출했다면, 컴파일러가 이 버전으로 specialize (전문화) 를 생성 함.\n똑같은 걸 또 부르면 만든 specialize 버전을 재사용 하면 됨.\n그런데, ",["$","strong",null,{"children":["<",["$","code",null,{"children":"3,2"}],">"]}]," 와 ",["$","strong",null,{"children":["<",["$","code",null,{"children":"3,2"}],">"]}]," 를 부른다면 새로운 specialize를 한번 더 생성해야 함.\nshape가 안맞으면 당연히 에러를 출력해야 함.\n따라서 함수는 제네릭이어야 함. 호출할 때마다 shape가 정해지고, specialize 된 함수가 생성되는 방향"]}],"\n",["$","p",null,{"children":"3) AST는 무엇인가?"}],"\n",["$","p",null,{"children":"심플함, 코드를 tree 형태로 만든것.\n이건 함수다, 블록이다, 변수 선언이다, 함수 호출이다. 이걸 구조화 한것."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$e"}]}],"\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14"]}],"$L15","$L16"]}]
17:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
f:["$","p",null,{"children":"이 dump 내용을 차근차근 분석해 보면"}]
10:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Module : 파일 전체"}],"\n",["$","li",null,{"children":"Function multiply_transpose"}],"\n",["$","li",null,{"children":"proto : 함수 이름 / 위치 / 파라미터"}],"\n",["$","li",null,{"children":"BinOp: * : 곱셈 연산"}],"\n",["$","li",null,{"children":"VarDecl a : 변수 a 선언"}],"\n",["$","li",null,{"children":["Literal ",["$","strong",null,{"children":["<",["$","code",null,{"children":"2,3"}],">"]}]," ... : 리터럴 텐서 값"]}],"\n",["$","li",null,{"children":["VarDecl b**<",["$","code",null,{"children":"2,3"}],">** : b 선언 (reshape)"]}],"\n",["$","li",null,{"children":"VarDecl c : 함수 호출 결과 저장"}],"\n"]}]
11:["$","p",null,{"children":"@test/Examples/Toy/Ch1/ast.toy:19:11 이런건 이 노드가 소스코드의 몇 번째 줄 / 몇 번째 칸에서 왔는지를 적어둔 것."}]
12:["$","p",null,{"children":"4) Lexer / Parser\nLexer는 어휘 분석기로 글자를 토큰으로 자르는 역할\nParser는 구문 분석기로 토큰을 읽어서 AST로 만드는 역할\n튜토리얼은 재귀 하강 (Recursive Descent) 이라는 근본 Parser 방식을 사용함."}]
13:["$","p",null,{"children":"====================================================================="}]
14:["$","p",null,{"children":"Flow를 요약해 보자면\n소스코드 -> Lexer (토큰화) -> Parser (AST 만들기) -> MLIR 로의 변환"}]
15:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
16:["$","$L17",null,{}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
18:I[27201,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"IconMark"]
c:[["$","title","0",{"children":"MLIR Toy Tutorial Ch 1 에 대하여 - CPIST's blog"}],["$","meta","1",{"name":"description","content":"Introduction to the Toy language and the definition of its AST."}],["$","link","2",{"rel":"icon","href":"/blog/favicon.ico?favicon.0b3bf435.ico","sizes":"256x256","type":"image/x-icon"}],["$","$L18","3",{}]]
8:null
