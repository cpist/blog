<!DOCTYPE html><!--jUEcg4T0ew1D4QO95r_yl--><html lang="ko"><head><meta charSet="utf-8"/><link rel="preconnect" href="/" crossorigin=""/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="stylesheet" href="/blog/_next/static/chunks/4057cc9dbcc744c0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR Tutorial DataFlow Analysis 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Quickstart tutorial to adding MLIR graph rewrite"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article style="max-width:800px;margin:0 auto;padding:20px"><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Tutorial DataFlow Analysis 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-12-14</div><p style="color:#333;font-style:italic">Quickstart tutorial to adding MLIR graph rewrite</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose" style="line-height:1.6"><ol>
<li>MLIR 에서 그래프 rewrite(변환) 은 어떻게 추가할 수 있을까?</li>
</ol>
<p>일반적인 흐름은 다음과 같음</p>
<pre><code>1. Operation(연산) 정의
2. Rewrite 패턴 정의 (TableGen / C++)
3. 패턴 등록
4. Rewrite 방식의 종류
5. 테스트 방법
6. 필요 시 일반 최적화 패스 작성

원칙적으로는 패턴 + Rewrite Engine 사용이 권장됨.
그래프 워커 방식은 어디까지나 개념을 설명하기 위한 것
</code></pre>
<ol start="2">
<li>MLIR Operation 정의 (TableGen)
MLIR의 연산(Operation) 은 TableGen(.td) 파일로 정의가 된다.
Operation 정의에 필요한 요소는 아래와 같음.</li>
</ol>
<ul>
<li>Operation 이름<!-- -->
<ul>
<li>Dialect 내에서 유일함</li>
<li>tfl.leaky_relu</li>
</ul>
</li>
<li>Traits<!-- -->
<ul>
<li>연산의 성질 (부작용이 없고, 타입이 동일함)</li>
<li>C++ 검증 로직과 연결됨</li>
</ul>
</li>
<li>Arguments<!-- -->
<ul>
<li>Operands : 런타임 입력 값</li>
<li>Attributes : 컴파일 타임 상수 값 (반드시 이름이 필요함)</li>
</ul>
</li>
<li>Results<!-- -->
<ul>
<li>출력 값 (여러 개 가능)</li>
</ul>
</li>
<li>문서화<!-- -->
<ul>
<li>Summary + 상세 설명</li>
</ul>
</li>
<li>Dialect 전용 메타데이터<!-- -->
<ul>
<li>ex) TFLite FlatBuffer 생성 옵션</li>
</ul>
</li>
</ul>
<p>추가 기능으로서 Operation은 필요에 따라 다음을 가질 수 있음.</p>
<ul>
<li>Custom parser / printer</li>
<li>Builder</li>
<li>Verifier</li>
<li>Constant folder</li>
<li>Canonicalizer
상수 폴딩은 fold() 메서드로 구현함.</li>
</ul>
<ol start="3">
<li>
<p>Rewrite(그래프 변환) 개념
MLIR에서 가장 일반적인 변환은 DAG <code>-&gt;</code> DAG 변환임.
이를 표현하는 가장 중요한 수단이 계속 말하는 Rewrite Pattern 이다.</p>
</li>
<li>
<p>TableGen 기반의 Rewrite 패턴</p>
</li>
</ol>
<ul>
<li>기본 패턴 (Pat)<!-- -->
<ul>
<li>Source DAG <code>-&gt;</code> Result DAG 형태</li>
<li>Source에서 캡처한 값 / 속성을 Result 에서 재사용 가능</li>
<li>단순 1:1 변환에 매우 적합</li>
</ul>
</li>
<li>tf.LeakyRelu 를 tfl.LeakyRelu 로 바꾸는게 예시</li>
</ul>
<pre><code>%y = &quot;tf.LeakyRelu&quot;(%x) {alpha: 0.1} : (tensor&lt;1xf32&gt;) -&gt; tensor&lt;1xf32&gt;

에서

%y = &quot;tfl.leaky_relu&quot;(%x) {alpha: 1.000000e-01} : (tensor&lt;1xf32&gt;) -&gt; tensor&lt;1xf32&gt;
로 바뀜.
</code></pre>
<p>IR 의미상으로는 프런트엔드 (TF) 를 백엔드/타겟(TFLite) op로 &#x27;legalize&#x27; 하는 단계임
추가 변환이 없으면 alpha 변환 / 클램프 같은건 안하고 그냥 복사를 함.</p>
<ul>
<li>이제 NativeCodeCall 같은 복잡한 케이스에 대해서는</li>
</ul>
<ul>
<li>즉 TableGen으로 표현하기 어려운 경우가 있음</li>
<li>이럴 때는 C++ 함수로 직접 연산을 생성함.</li>
<li>임의로 복잡한 로직이 가능함</li>
<li>다만 제약은 있는데 입력 패턴에서 다중 operand / attribute 간 제약 포현은 제한적이다.</li>
</ul>
<ol start="5">
<li>패턴은 어떻게 등록하는가?</li>
</ol>
<ol>
<li>.td 파일을 mlir-tblgen -gen-rewriters로 처리한다.</li>
<li>CMake 설징이 필요함</li>
<li>생성된 .inc 파일을 포함해서</li>
<li>populateWithGenerated(RewritePatternSet&amp;) 을 호출한다.
생성된 패턴을 Pass에서 사용이 가능하다.</li>
</ol>
<ol start="6">
<li>C++ 기반의 Rewrite 방식들</li>
</ol>
<ol>
<li>matchAndRewrite 함수 스타일</li>
</ol>
<ul>
<li>간단한 변환에 적합함</li>
<li>함수 하나로 패턴 + 리라이트를 구현함</li>
<li>직접 RewritePatternSet 에 추가함
ODS 에서는 hasCanonicalizeMethod = 1 로 연산별 canonicalization 도 지원함.</li>
</ul>
<ol start="2">
<li>Canonicalization 메서드</li>
</ol>
<ul>
<li>Operation 자체에 귀속된 간단한 최적화</li>
<li>mul(x, power_of_2) 를 shl(x, log2) 로</li>
<li>당연히 복잡한 패턴이나 다중 연산 매칭에는 한계가 있음</li>
</ul>
<ol start="3">
<li>일반 RewritePattern 클래스</li>
</ol>
<ul>
<li>가장 강력하고 범용적인 방식임</li>
<li>직접<!-- -->
<ul>
<li>매칭 로직</li>
<li>리라이트 로직</li>
<li>우선순위(benefit) 지정이 가능함</li>
</ul>
</li>
<li>복잡한 경우에는<!-- -->
<ul>
<li>PatternState를 사용해 match 단계의 정보를 전달함.
matchAndRewrite는 단일 단계 변환에 특히 편리함.</li>
</ul>
</li>
</ul>
<ol start="7">
<li>Rewrite 우선 순위 (Benefit)</li>
</ol>
<ul>
<li>C++ RewritePattern은 명시적으로 benefit을 지정함</li>
<li>TableGen 패턴은 매칭 / 대체 op 수 기반의 휴리스틱 방식임.</li>
</ul>
<ol start="8">
<li>테스트는 lit + FileCheck를 이용함
MLIR의 경우 IR 기반 테스트를 중심으로 한다.
테스트 방식은</li>
</ol>
<pre><code>입력 MLIR을 작성하고 -&gt; mlir-opt로 특정 패스를 실행한 뒤 -&gt; FileCheck로 결과를 검증한다.
</code></pre>
<p>장점으로는</p>
<ul>
<li>바이너리 테스트를 최소화하고</li>
<li>IR 표현 자체를 명확히 검증하며</li>
<li>독립적이고 단순한 테스트 구성이 가능하다는 것이다.</li>
</ul>
<ol start="9">
<li>최적화 패스 작성</li>
</ol>
<ul>
<li>패턴 기반으로 표현하기 어려운 경우</li>
<li>모듈/함수 단위 순회 패스로 구현이 가능함</li>
<li>MLIR Pass Infrastructure 사용</li>
</ul>
<p>=====================================================================</p>
<p>요약해 보자면
MLIR Graph Rewrite는 아래와 같은 흐름으로 구성된다.</p>
<pre><code>Operation 정의 → Rewrite 패턴(TableGen/C++) → 패턴 등록 → lit 기반 IR 테스트
</code></pre>
<p>왠만하면 패턴 기반의 Rewrite Engine을 쓰자!</p></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n:HC[\"/\",\"\"]\n:HL[\"/blog/_next/static/chunks/4057cc9dbcc744c0.css\",\"style\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"jUEcg4T0ew1D4QO95r-yl\",\"c\":[\"\",\"posts\",\"mlir\",\"md-rewrite\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-rewrite\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/4057cc9dbcc744c0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"style\":{\"maxWidth\":\"800px\",\"margin\":\"0 auto\",\"padding\":\"20px\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Tutorial DataFlow Analysis 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-12-14\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\",\"fontStyle\":\"italic\"},\"children\":\"Quickstart tutorial to adding MLIR graph rewrite\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"style\":{\"lineHeight\":1.6},\"children\":[[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR 에서 그래프 rewrite(변환) 은 어떻게 추가할 수 있을까?\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"일반적인 흐름은 다음과 같음\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"1. Operation(연산) 정의\\n2. Rewrite 패턴 정의 (TableGen / C++)\\n3. 패턴 등록\\n4. Rewrite 방식의 종류\\n5. 테스트 방법\\n6. 필요 시 일반 최적화 패스 작성\\n\\n원칙적으로는 패턴 + Rewrite Engine 사용이 권장됨.\\n그래프 워커 방식은 어디까지나 개념을 설명하기 위한 것\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR Operation 정의 (TableGen)\\nMLIR의 연산(Operation) 은 TableGen(.td) 파일로 정의가 된다.\\nOperation 정의에 필요한 요소는 아래와 같음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Operation 이름\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Dialect 내에서 유일함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"tfl.leaky_relu\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Traits\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"연산의 성질 (부작용이 없고, 타입이 동일함)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"C++ 검증 로직과 연결됨\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Arguments\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Operands : 런타임 입력 값\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Attributes : 컴파일 타임 상수 값 (반드시 이름이 필요함)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Results\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"출력 값 (여러 개 가능)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"문서화\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Summary + 상세 설명\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Dialect 전용 메타데이터\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"ex) TFLite FlatBuffer 생성 옵션\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"추가 기능으로서 Operation은 필요에 따라 다음을 가질 수 있음.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Custom parser / printer\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Builder\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Verifier\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Constant folder\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Canonicalizer\\n상수 폴딩은 fold() 메서드로 구현함.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Rewrite(그래프 변환) 개념\\nMLIR에서 가장 일반적인 변환은 DAG \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" DAG 변환임.\\n이를 표현하는 가장 중요한 수단이 계속 말하는 Rewrite Pattern 이다.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"TableGen 기반의 Rewrite 패턴\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"기본 패턴 (Pat)\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Source DAG \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" Result DAG 형태\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Source에서 캡처한 값 / 속성을 Result 에서 재사용 가능\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"단순 1:1 변환에 매우 적합\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"tf.LeakyRelu 를 tfl.LeakyRelu 로 바꾸는게 예시\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%y = \\\"tf.LeakyRelu\\\"(%x) {alpha: 0.1} : (tensor\u003c1xf32\u003e) -\u003e tensor\u003c1xf32\u003e\\n\\n에서\\n\\n%y = \\\"tfl.leaky_relu\\\"(%x) {alpha: 1.000000e-01} : (tensor\u003c1xf32\u003e) -\u003e tensor\u003c1xf32\u003e\\n로 바뀜.\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"IR 의미상으로는 프런트엔드 (TF) 를 백엔드/타겟(TFLite) op로 'legalize' 하는 단계임\\n추가 변환이 없으면 alpha 변환 / 클램프 같은건 안하고 그냥 복사를 함.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이제 NativeCodeCall 같은 복잡한 케이스에 대해서는\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"즉 TableGen으로 표현하기 어려운 경우가 있음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이럴 때는 C++ 함수로 직접 연산을 생성함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"임의로 복잡한 로직이 가능함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다만 제약은 있는데 입력 패턴에서 다중 operand / attribute 간 제약 포현은 제한적이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"5\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"패턴은 어떻게 등록하는가?\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\".td 파일을 mlir-tblgen -gen-rewriters로 처리한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CMake 설징이 필요함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"생성된 .inc 파일을 포함해서\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"populateWithGenerated(RewritePatternSet\u0026) 을 호출한다.\\n생성된 패턴을 Pass에서 사용이 가능하다.\"}],\"\\n\"]}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\"]}],\"$L21\",\"$L22\"]}]\n"])</script><script>self.__next_f.push([1,"23:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"ol\",null,{\"start\":\"6\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"C++ 기반의 Rewrite 방식들\"}],\"\\n\"]}]\nf:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"matchAndRewrite 함수 스타일\"}],\"\\n\"]}]\n10:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"간단한 변환에 적합함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"함수 하나로 패턴 + 리라이트를 구현함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"직접 RewritePatternSet 에 추가함\\nODS 에서는 hasCanonicalizeMethod = 1 로 연산별 canonicalization 도 지원함.\"}],\"\\n\"]}]\n11:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Canonicalization 메서드\"}],\"\\n\"]}]\n12:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Operation 자체에 귀속된 간단한 최적화\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"mul(x, power_of_2) 를 shl(x, log2) 로\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"당연히 복잡한 패턴이나 다중 연산 매칭에는 한계가 있음\"}],\"\\n\"]}]\n13:[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"일반 RewritePattern 클래스\"}],\"\\n\"]}]\n14:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"가장 강력하고 범용적인 방식임\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"직접\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"매칭 로직\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"리라이트 로직\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"우선순위(benefit) 지정이 가능함\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"복잡한 경우에는\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"PatternState를 사용해 match 단계의 정보를 전달함.\\nmatchAndRewrite는 단일 단계 변환에 특히 편리함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n15:[\"$\",\"ol\",null,{\"start\":\"7\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Rewrite 우선 순위 (Benefit)\"}],\"\\n\"]}]\n16:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"C++ RewritePattern은 명시적으로 benefit을 지정함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"TableGen 패턴은 매칭 / 대체 op 수 기반의 휴리스틱 방식임.\"}],\"\\n\"]}]\n17:[\"$\",\"ol\",null,{\"start\":\"8\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"테스트는 lit + FileCheck를 이용함\\nMLIR의 경우 IR 기반 테스트를 중심으로 한다.\\n테스트 방식은\"}],\"\\n\"]}]\n18:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"입력 MLIR을 작성하고 -\u003e mlir-opt로 특정 패스를 실행한 뒤 -\u003e FileCheck로 결과를 검증한다.\\n\"}]}]\n19:[\"$\",\"p\",null,{\"children\":\"장점으로는\"}]\n1a:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"바이너리 테스트를 최소화하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"IR 표현 자체를 명확히 검증하며\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"독립적이고 단순한 테스트 구성이 가능하다는 것이다.\"}],\"\\n\"]}]\n1b:[\"$\",\"ol\",null,{\"start\":\"9\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"최적화 패스 작성\"}],\"\\n\"]}]\n1c:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"패턴 기반으로 표현하기 어려운 경우\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"모듈/함수 단위 순회 패스로 구현이 가능함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR Pass Infrastructure 사용\"}],\"\\n\"]}]\n1d:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n1e:[\"$\",\"p\",null,{\"children\":\"요약해 보자면\\nMLIR Graph Rewrite는 아래와 같은 흐름으로 구성된다.\"}]\n1f:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"Operation 정의 → Rewrite 패턴(TableGen/C++) → 패턴 등록 → lit 기반 IR 테스트\\n\"}]}]\n20:[\"$\",\"p\",null,{\"children\":\"왠만하면 패턴 기반의 Rewrite Engine을 쓰자!\"}]\n21:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n22:[\"$\",\"$L23\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"24:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Tutorial DataFlow Analysis 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Quickstart tutorial to adding MLIR graph rewrite\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L24\",\"3\",{}]]\n8:null\n"])</script></body></html>