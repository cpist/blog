1:"$Sreact.fragment"
42:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
43:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
44:"$Sreact.suspense"
0:{"buildId":"VqngCHoUqrMNzAqxUIcr8","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Transform Tutorial Ch 1 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-11-22"}],["$","p",null,{"style":{"color":"#333"},"children":"Combining Existing Transformations"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"1) Transform IR은 뭘까?\nTransform Dialect란 어떤 IR 연산을, 어떤 순서로, 어떻게 바꿀지를 또 다른 IR로 표현하는 방식이다."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Payload IR : 진짜 바꾸고 싶은 코드 (ex: linalg.matmul)"}],"\n",["$","li",null,{"children":"Transform IR : \"이걸타일링 해라, 저걸 합쳐라\" 와 같은 변환 스크립트"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"여기서 많이 물어보는게 rewrite와 transform의 차이이다."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["rewrite는 무엇을 무엇으로 바꿀지에 초점이 있는 local 한 규칙 기반의 치환","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"보통 한 개 op(혹은 작은 subgraph) 를 매칭해서 다른 형태로 치환"}],"\n",["$","li",null,{"children":"applyPatternsAndFoldGreedily, canonicalization, dialect conversion 등에서 패턴 엔진이 반복 적용"}],"\n",["$","li",null,{"children":"규칙 자체가 변환 스케줄(순서/반복/적용 범위) 을 강하게 드러내지 않는 경우가 많음(대개 “greedy로 될 때까지” 같은 식)"}],"\n",["$","li",null,{"children":"“이 op를 이런 op로 바꾼다”, “이런 조합이면 fold 한다” 같은 미세 최적화/정규화에 강함"}],"\n",["$","li",null,{"children":["Lowering(예: linalg ",["$","code",null,{"children":"→"}]," scf ",["$","code",null,{"children":"→"}]," llvm)에서도 실제 치환은 대개 rewrite 패턴으로 구현됨"]}],"\n",["$","li",null,{"children":["예시는 arith.addi에 상수 0이 들어오면 x + 0 ",["$","code",null,{"children":"→"}]," x로 바꾸는 canonicalization 패턴."]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["반면 transform은 **“어떤 변환을 어떤 순서로, 어디에, 어떻게 적용할지”**에 초점인 변환 오케스트레이션/스케줄링 레이어예요.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"형태: Transform dialect IR 로 “변환 프로그램”을 작성"}],"\n",["$","li",null,{"children":"단위: rewrite보다 더 큰 범위/전략을 다룸 (어떤 함수들만 대상으로 삼기, 특정 op 집합에만 타일링 적용, 그 다음 벡터화, 그 다음 버퍼화…)"}],"\n",["$","li",null,{"children":"실행 방식: transform interpreter/runner가 Transform IR을 실행하면서 대상 payload IR에 변환을 적용"}],"\n",["$","li",null,{"children":"변환 순서와 적용 범위를 명시적으로 제어 가능"}],"\n",["$","li",null,{"children":"“같은 rewrite 패턴/패스를 쓰더라도” 파이프라인을 IR로 표현해서 실험/튜닝/재사용이 쉬움"}],"\n",["$","li",null,{"children":"타겟별 튜닝(예: CPU vs GPU)에서 “전략”을 바꾸기 좋음"}],"\n",["$","li",null,{"children":"예시는 “이 linalg.matmul들만 찾아서 tile size=…로 타일링하고, 그 결과를 벡터화하고, 특정 조건이면 unroll한다” 같은 전략 스크립트."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":"2) 핸들 (handle) 의 개념\nTransform IR은 handle을 통해 Payload IR을 조작함.\nhandle 의 종류는 다음과 같음"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"operation handle : 특정 연산 (linalg.matmul)"}],"\n",["$","li",null,{"children":"value handle : 값"}],"\n",["$","li",null,{"children":"parameter : 숫자, 속성 같은 설정 값"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"%arg1 : !transform.op<\"linalg.matmul\">\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 핸들은 matmul 연산만 가리킬 수 있음."}],"\n"]}],"\n",["$","p",null,{"children":"3) 시작점: @__transform_main\nTransform은 항상 여기서 시작함"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"transform.named_sequence @__transform_main(...)\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"마치 C의 main() 함수"}],"\n",["$","li",null,{"children":"어떤 연산을 언제, 어떤 순서로 변환할지 정의"}],"\n",["$","li",null,{"children":"내부는 그냥 \"변환을 차례대로 나열\" 하는 구조"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"transform.with_named_sequence"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 모듈 안에 transform 시퀀스가 있다는 것을 알려줌."}],"\n"]}],"\n",["$","p",null,{"children":"4) transform 이 실패하였을 때\nTransform 에는 실패 전파(propagate) 모드가 있음."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"propagate의 경우"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"하나라도 실패하면 전체 실패"}],"\n",["$","li",null,{"children":"디버깅 할때는 최고"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"suppress"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"실패는 무시하고 바깥 스크립트는 계속 실행함."}],"\n",["$","li",null,{"children":"실패해도 괜찮은 변환에 유용함."}],"\n"]}],"\n",["$","p",null,{"children":"5) 디버깅을 어떻게 하는가\n예를 들어서 어떤 연산이 잡혀있는지 확인하고 싶을 때"}],"\n","$L2","\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27","\n","$L28","\n","$L29","\n","$L2a","\n","$L2b","\n","$L2c","\n","$L2d","\n","$L2e","\n","$L2f","\n","$L30","\n","$L31","\n","$L32","\n","$L33","\n","$L34","\n","$L35","\n","$L36","\n","$L37","\n","$L38","\n","$L39","\n","$L3a","\n","$L3b","\n","$L3c","\n","$L3d"]}],"$L3e","$L3f"]}],["$L40"],"$L41"]}],"loading":null,"isPartial":false}
2:["$","pre",null,{"children":["$","code",null,{"children":"transform.debug.emit_remark_at %arg1, \"matmul\"\n"}]}]
3:["$","p",null,{"children":["컴파일 로그에 아래와 같은 내용이 찍힘\n",["$","code",null,{"children":"“이 matmul을 지금 보고 있다!”"}]]}]
4:["$","p",null,{"children":"6) 실제 변환 : 타일링\n예를 들어 matmul을 타일링 하게 되면"}]
5:["$","pre",null,{"children":["$","code",null,{"children":"%loop, %tiled =\n  transform.structured.tile_using_forall %arg1 tile_sizes [4, 32]\n"}]}]
6:["$","p",null,{"children":"그 결과"}]
7:["$","ul",null,{"children":["\n",["$","li",null,{"children":["%loop ",["$","code",null,{"children":"->"}]," 새로 생긴 scf.forall 루프"]}],"\n",["$","li",null,{"children":["%tiled ",["$","code",null,{"children":"->"}]," 타일된 연산"]}],"\n"]}]
8:["$","p",null,{"children":"기존 핸들은 소모(consumed) 된다.\n여기서 소모라는 것은 transform op가 그 핸들이 가리키던 payload op들을 없애거나(erase) 새로 만들거나(recreate) 해서 기존 참조가 위험해 질때 소비 되었다고 표시함."}]
9:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Consumed 로 표시된 operand handle은 그 transform 이후에 쓰면 안된다."}],"\n",["$","li",null,{"children":"다른 라인, 즉 이후 어떤 위치에서도 재사용 할 경우 UB(정의되지 않은 동작) 이 됨."}],"\n"]}]
a:["$","p",null,{"children":"이렇게 강하게 막는 이유는"}]
b:["$","ul",null,{"children":["\n",["$","li",null,{"children":"핸들은 본질적으로 \"payload op\" 에 대한 참조(reference) 인데"}],"\n",["$","li",null,{"children":"op가 지워지거나 새로 만들면 참조가 헛것이 될 수 있기 때문"}],"\n"]}]
c:["$","p",null,{"children":"결론적으로 사용했기 떄문에 못쓴다 이런게 아니라 해당 transform 이 payload를 재작성 했기 때문에 못쓰는 것이다.\n참고로 payload IR은 실제로 바꾸고 싶은 IR을 의미함."}]
d:["$","pre",null,{"children":["$","code",null,{"children":"linalg.matmul\nlinalg.elementwise\nscf.forall\ntensor.extract_slice\nfunc.func\n\nfunc.func @fc_relu(...) {\n  %matmul = linalg.matmul ...\n  %add = linalg.elementwise ...\n  %relu = linalg.elementwise ...\n}\n"}]}]
e:["$","p",null,{"children":"이런 것들, 변환의 대상이 되는 IR"}]
f:["$","p",null,{"children":"Transform IR은 payload op를 직접 수정하지 않고, handle을 통해 간접 조작한다."}]
10:["$","p",null,{"children":"7) 핸들 무효화"}]
11:["$","pre",null,{"children":["$","code",null,{"children":"tile_using_forall %arg1\nemit_remark_at %arg1   // 이미 죽은 핸들\n"}]}]
12:["$","ul",null,{"children":["\n",["$","li",null,{"children":"타일링은 연산을 지우고 새로 만듦"}],"\n",["$","li",null,{"children":"옛날 핸들은 dangling point 상태이다."}],"\n",["$","li",null,{"children":"Expensive checks 모드가 켜져 있을 경우"}],"\n",["$","li",null,{"children":"이 핸들이 무효라는 것을 알려준다."}],"\n"]}]
13:["$","p",null,{"children":"무효화 (invalidated) 는\n해당 handle이 가리키던 payload IR entity(연산 / 값)가 더 이상 그 모습 그대로 존재하지 않아, 이 행들로 접근하면 위험하다는 상태임."}]
14:["$","ul",null,{"children":["\n",["$","li",null,{"children":"예시로 tile_using_forall %arg1 같은 타일링은"}],"\n"]}]
15:["$","ul",null,{"children":["\n",["$","li",null,{"children":"linalg.matmul 을 그대로 두는게 아니라"}],"\n",["$","li",null,{"children":"슬라이스 / 루프 / 새로운 작은 matmul 형태로 재구성을 함."}],"\n"]}]
16:["$","p",null,{"children":"그러면 %arg1이 가리키던 그 matmul이"}]
17:["$","ul",null,{"children":["\n",["$","li",null,{"children":"없어지거나"}],"\n",["$","li",null,{"children":"구조가 바뀌거나"}],"\n",["$","li",null,{"children":"다른 op로 대체될 수 있음."}],"\n"]}]
18:["$","p",null,{"children":"그렇기 때문에 transform dialect는 안전장치로"}]
19:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 operand handle은 consumed"}],"\n",["$","li",null,{"children":"그리고 그것과 같은 payload op를 가리키던 다른 핸들도 전부 invalidated 라고 처리한다."}],"\n"]}]
1a:["$","ul",null,{"children":["\n",["$","li",null,{"children":"참고로 alias(별칭)도 같이 무효가 되는데"}],"\n"]}]
1b:["$","pre",null,{"children":["$","code",null,{"children":"%casted = transform.cast %arg1 : ... to !transform.any_op\n"}]}]
1c:["$","p",null,{"children":"%arg1과 %casted 는 같은 payload op를 참조(alias) 한다.\n원본이 없어지면 둘다 무효가 되는 것은 당연하다. (포인터 복사해도 주소는 같기 때문)"}]
1d:["$","p",null,{"children":"8)  핸들은 복사한다 해도 같이 죽는다."}]
1e:["$","pre",null,{"children":["$","code",null,{"children":"%casted = transform.cast %arg1\n"}]}]
1f:["$","ul",null,{"children":["\n",["$","li",null,{"children":"%arg1과 %casted 는 같은 연산을 가리킨다."}],"\n",["$","li",null,{"children":"하나가 무효화 되면 -> 둘다 무효다."}],"\n"]}]
20:["$","ul",null,{"children":["\n",["$","li",null,{"children":"즉 참조(reference) 처럼 생각하면 딱 맞는다."}],"\n"]}]
21:["$","p",null,{"children":"9) 변환 체이닝"}]
22:["$","ul",null,{"children":["\n",["$","li",null,{"children":"마지막 연산 (RELU) 부터 타일링을 진행함"}],"\n",["$","li",null,{"children":["그 루프 안으로","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"add 연산을 fuse 하고"}],"\n",["$","li",null,{"children":"matmul도 fuse 한다."}],"\n"]}],"\n"]}],"\n"]}]
23:["$","pre",null,{"children":["$","code",null,{"children":"tile → fuse add → fuse matmul\n"}]}]
24:["$","p",null,{"children":"그 결과"}]
25:["$","ul",null,{"children":["\n",["$","li",null,{"children":"캐시 효율도 올라가고"}],"\n",["$","li",null,{"children":"코드도 깔끔해지고"}],"\n",["$","li",null,{"children":"크기 조절도 자동으로 된다."}],"\n"]}]
26:["$","ul",null,{"children":["\n",["$","li",null,{"children":"참고로 fuse를 좀더 자세히 설명해 보자면, 두(혹은 여러) 연산을 같은 루프 안으로 합쳐서, 중간 결과를 밖에 안 만들게 하는 것이다.\n원래 라면"}],"\n"]}]
27:["$","ol",null,{"children":["\n",["$","li",null,{"children":"matmul 결과를 큰 tensor에 쓰고"}],"\n",["$","li",null,{"children":"그 tensor를 다시 읽어서 add 하고"}],"\n",["$","li",null,{"children":"또 다시 읽어서 max(ReLU) 를 했을거임.\n이 경우 메모리 왕복이 많아짐."}],"\n"]}]
28:["$","p",null,{"children":"fuse를 하게 되면"}]
29:["$","ul",null,{"children":["\n",["$","li",null,{"children":"ReLU 를 타일링 해서 루프를 만들고"}],"\n",["$","li",null,{"children":"그 루프 안에서 필요한 add, matmul 도 같이 계산하게 끌어들임.\n아래와 같은 방식으로"}],"\n"]}]
2a:["$","pre",null,{"children":["$","code",null,{"children":"for tile ... {\n  tile_matmul()\n  tile_add()\n  tile_relu()\n}\n\n즉,\n\nfor each tile:\n  A_tile, B_tile 읽음\n  matmul(tile) → 레지스터/캐시\n  add(tile)    → 바로 이어서\n  relu(tile)   → 바로 이어서\n  결과 tile만 메모리에 씀\n"}]}]
2b:["$","p",null,{"children":"이렇게 했을때"}]
2c:["$","ul",null,{"children":["\n",["$","li",null,{"children":"중간 텐서를 크게 저장/로드 하지 않고"}],"\n",["$","li",null,{"children":"타일 단위로 바로 다음 연산을 이어서 처리하여 캐시 / 대역폭에서 이득을 볼 수 있다. (하나의 tile 범위에 대해서)"}],"\n"]}]
2d:["$","p",null,{"children":"10) 더 작은 타일 + 아웃라이닝"}]
2e:["$","ul",null,{"children":["\n",["$","li",null,{"children":"4x4 matmul 마이크로 커널이 있다면?\n(1) 다시 타일링을 하고\n(2) 루프를 함수로 outline 한다음\n(3) 나중에 마이크로 커널 호출로 교체를 한다."}],"\n"]}]
2f:["$","ul",null,{"children":["\n",["$","li",null,{"children":"주의할 부분이라면"}],"\n"]}]
30:["$","ul",null,{"children":["\n",["$","li",null,{"children":"outline도 핸들을 소모하고"}],"\n",["$","li",null,{"children":"그 안에 있던 연산 핸들이 전부 무효화 된다."}],"\n"]}]
31:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Kernel은 DL / 선형대수의 Kernel 개념이 맞음.\nMicrokernel 은"}],"\n"]}]
32:["$","ul",null,{"children":["\n",["$","li",null,{"children":"아주 작은 고정 크기 블록 (ex: 4x4 matmul) 을"}],"\n",["$","li",null,{"children":["어셈블리 / 벤더 intrinsics / 특수 명령어로 최적화해 둔 함수이다.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"BLAS 내부, oneDNN, XNNPACK류가 이런 스타일을 많이 씀"}],"\n"]}],"\n"]}],"\n"]}]
33:["$","ul",null,{"children":["\n",["$","li",null,{"children":"replace 흐름의 경우"}],"\n"]}]
34:["$","ol",null,{"children":["\n",["$","li",null,{"children":"큰 matmul을 타일링 해서 4x4 단위로 쪼개고"}],"\n",["$","li",null,{"children":"그 4x4 계산을 별도 함수로 outline(= 루프 바디를 함수로 떼어내고)"}],"\n",["$","li",null,{"children":["그 함수 호출(func.call) 을","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"microkernel_4x4(...) 같은 특수 호출로 바꾸고 싶다\n즉 outline 된 함수 호출을 마이크로커널 호출로 바꾸는 것임."}],"\n"]}],"\n"]}],"\n"]}]
35:["$","ul",null,{"children":["\n",["$","li",null,{"children":"왜 굳이 outline을 하는가? (outline : 코드 조각을 바깥으로빼서(out) 별도의 함수를 만들어(line을 긋는다.))"}],"\n"]}]
36:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Transform dialect 에서 \"임의의 호출을 내 마음대로 다른 호출로 바꾸기\"는 기본 제공이 제한적임."}],"\n",["$","li",null,{"children":"일단 호출 형태로 만들어 놓으면 (=call)"}],"\n",["$","li",null,{"children":"그 다음단계 (커스텀 transform op 또는 다른패스) 에서 교체하기가 쉬워짐."}],"\n"]}]
37:["$","p",null,{"children":"최종적으로"}]
38:["$","ul",null,{"children":["\n",["$","li",null,{"children":["호출로 교체한다는 것은 타일된 작은 계산 ",["$","code",null,{"children":"->"}]," 특수 최적화 함수 호출로 바꾸어서 성능을 극대화 한다는 것이다."]}],"\n"]}]
39:["$","p",null,{"children":"11) Transform dialect 의 자동 추적\nTransform은 IR 변경을 자동 추적함."}]
3a:["$","ul",null,{"children":["\n",["$","li",null,{"children":["연산 삭제 ",["$","code",null,{"children":"->"}]," 핸들에서 자동 제거"]}],"\n",["$","li",null,{"children":["연산 교체 ",["$","code",null,{"children":"->"}]," 가능한 경우 핸들 자동 갱신"]}],"\n",["$","li",null,{"children":["애매하면 ",["$","code",null,{"children":"->"}]," 에러로 막아준다.\n이를 통해 몰래 잘못 바꾸는 일을 방지한다."]}],"\n"]}]
3b:["$","p",null,{"children":"====================================================================="}]
3c:["$","p",null,{"children":"요약해 보자면 Transform Dialect는 IR을 바꾸는 과정을 IR로 작성하는 안전한 자동 리팩토링 언어라 할 수 있음."}]
3d:["$","p",null,{"children":"Rewrite는 로컬 규칙 (치환) 자체였다면, Transform은 그 규칙/패스를 어떤 순서, 범위, 전략으로 적용할지 (오케스트레이션)"}]
3e:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
3f:["$","$L42",null,{}]
40:["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true}]
41:["$","$L43",null,{"children":["$","$44",null,{"name":"Next.MetadataOutlet","children":"$@45"}]}]
45:null
