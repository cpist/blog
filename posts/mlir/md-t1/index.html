<!DOCTYPE html><!--Ji_piVBREfl1BCiHbQepC--><html lang="ko"><head><meta charSet="utf-8"/><link rel="preconnect" href="/" crossorigin=""/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="stylesheet" href="/blog/_next/static/chunks/4057cc9dbcc744c0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR Transform Tutorial Ch 1 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Combining Existing Transformations"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article style="max-width:800px;margin:0 auto;padding:20px"><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Transform Tutorial Ch 1 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-11-22</div><p style="color:#333;font-style:italic">Combining Existing Transformations</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose" style="line-height:1.6"><ol>
<li>Transform IR은 뭘까?
Transform Dialect란 어떤 IR 연산을, 어떤 순서로, 어떻게 바꿀지를 또 다른 IR로 표현하는 방식이다.</li>
</ol>
<ul>
<li>Payload IR : 진짜 바꾸고 싶은 코드 (ex: linalg.matmul)</li>
<li>Transform IR : &quot;이걸타일링 해라, 저걸 합쳐라&quot; 와 같은 변환 스크립트</li>
</ul>
<ul>
<li>여기서 많이 물어보는게 rewrite와 transform의 차이이다.</li>
</ul>
<ul>
<li>rewrite는 무엇을 무엇으로 바꿀지에 초점이 있는 local 한 규칙 기반의 치환<!-- -->
<ul>
<li>보통 한 개 op(혹은 작은 subgraph) 를 매칭해서 다른 형태로 치환</li>
<li>applyPatternsAndFoldGreedily, canonicalization, dialect conversion 등에서 패턴 엔진이 반복 적용</li>
<li>규칙 자체가 변환 스케줄(순서/반복/적용 범위) 을 강하게 드러내지 않는 경우가 많음(대개 “greedy로 될 때까지” 같은 식)</li>
<li>“이 op를 이런 op로 바꾼다”, “이런 조합이면 fold 한다” 같은 미세 최적화/정규화에 강함</li>
<li>Lowering(예: linalg <code>→</code> scf <code>→</code> llvm)에서도 실제 치환은 대개 rewrite 패턴으로 구현됨</li>
<li>예시는 arith.addi에 상수 0이 들어오면 x + 0 <code>→</code> x로 바꾸는 canonicalization 패턴.</li>
</ul>
</li>
<li>반면 transform은 **“어떤 변환을 어떤 순서로, 어디에, 어떻게 적용할지”**에 초점인 변환 오케스트레이션/스케줄링 레이어예요.<!-- -->
<ul>
<li>형태: Transform dialect IR 로 “변환 프로그램”을 작성</li>
<li>단위: rewrite보다 더 큰 범위/전략을 다룸 (어떤 함수들만 대상으로 삼기, 특정 op 집합에만 타일링 적용, 그 다음 벡터화, 그 다음 버퍼화…)</li>
<li>실행 방식: transform interpreter/runner가 Transform IR을 실행하면서 대상 payload IR에 변환을 적용</li>
<li>변환 순서와 적용 범위를 명시적으로 제어 가능</li>
<li>“같은 rewrite 패턴/패스를 쓰더라도” 파이프라인을 IR로 표현해서 실험/튜닝/재사용이 쉬움</li>
<li>타겟별 튜닝(예: CPU vs GPU)에서 “전략”을 바꾸기 좋음</li>
<li>예시는 “이 linalg.matmul들만 찾아서 tile size=…로 타일링하고, 그 결과를 벡터화하고, 특정 조건이면 unroll한다” 같은 전략 스크립트.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>핸들 (handle) 의 개념
Transform IR은 handle을 통해 Payload IR을 조작함.
handle 의 종류는 다음과 같음</li>
</ol>
<ul>
<li>operation handle : 특정 연산 (linalg.matmul)</li>
<li>value handle : 값</li>
<li>parameter : 숫자, 속성 같은 설정 값</li>
</ul>
<pre><code>%arg1 : !transform.op&lt;&quot;linalg.matmul&quot;&gt;
</code></pre>
<ul>
<li>이 핸들은 matmul 연산만 가리킬 수 있음.</li>
</ul>
<ol start="3">
<li>시작점: @__transform_main
Transform은 항상 여기서 시작함</li>
</ol>
<pre><code>transform.named_sequence @__transform_main(...)
</code></pre>
<ul>
<li>마치 C의 main() 함수</li>
<li>어떤 연산을 언제, 어떤 순서로 변환할지 정의</li>
<li>내부는 그냥 &quot;변환을 차례대로 나열&quot; 하는 구조</li>
</ul>
<ul>
<li>transform.with_named_sequence</li>
</ul>
<ul>
<li>이 모듈 안에 transform 시퀀스가 있다는 것을 알려줌.</li>
</ul>
<ol start="4">
<li>transform 이 실패하였을 때
Transform 에는 실패 전파(propagate) 모드가 있음.</li>
</ol>
<ul>
<li>propagate의 경우</li>
</ul>
<ul>
<li>하나라도 실패하면 전체 실패</li>
<li>디버깅 할때는 최고</li>
</ul>
<ul>
<li>suppress</li>
</ul>
<ul>
<li>실패는 무시하고 바깥 스크립트는 계속 실행함.</li>
<li>실패해도 괜찮은 변환에 유용함.</li>
</ul>
<ol start="5">
<li>디버깅을 어떻게 하는가
예를 들어서 어떤 연산이 잡혀있는지 확인하고 싶을 때</li>
</ol>
<pre><code>transform.debug.emit_remark_at %arg1, &quot;matmul&quot;
</code></pre>
<p>컴파일 로그에 아래와 같은 내용이 찍힘
<code>“이 matmul을 지금 보고 있다!”</code></p>
<ol start="6">
<li>실제 변환 : 타일링
예를 들어 matmul을 타일링 하게 되면</li>
</ol>
<pre><code>%loop, %tiled =
  transform.structured.tile_using_forall %arg1 tile_sizes [4, 32]
</code></pre>
<p>그 결과</p>
<ul>
<li>%loop <code>-&gt;</code> 새로 생긴 scf.forall 루프</li>
<li>%tiled <code>-&gt;</code> 타일된 연산</li>
</ul>
<p>기존 핸들은 소모(consumed) 된다.
여기서 소모라는 것은 transform op가 그 핸들이 가리키던 payload op들을 없애거나(erase) 새로 만들거나(recreate) 해서 기존 참조가 위험해 질때 소비 되었다고 표시함.</p>
<ul>
<li>Consumed 로 표시된 operand handle은 그 transform 이후에 쓰면 안된다.</li>
<li>다른 라인, 즉 이후 어떤 위치에서도 재사용 할 경우 UB(정의되지 않은 동작) 이 됨.</li>
</ul>
<p>이렇게 강하게 막는 이유는</p>
<ul>
<li>핸들은 본질적으로 &quot;payload op&quot; 에 대한 참조(reference) 인데</li>
<li>op가 지워지거나 새로 만들면 참조가 헛것이 될 수 있기 때문</li>
</ul>
<p>결론적으로 사용했기 떄문에 못쓴다 이런게 아니라 해당 transform 이 payload를 재작성 했기 때문에 못쓰는 것이다.
참고로 payload IR은 실제로 바꾸고 싶은 IR을 의미함.</p>
<pre><code>linalg.matmul
linalg.elementwise
scf.forall
tensor.extract_slice
func.func

func.func @fc_relu(...) {
  %matmul = linalg.matmul ...
  %add = linalg.elementwise ...
  %relu = linalg.elementwise ...
}
</code></pre>
<p>이런 것들, 변환의 대상이 되는 IR</p>
<p>Transform IR은 payload op를 직접 수정하지 않고, handle을 통해 간접 조작한다.</p>
<ol start="7">
<li>핸들 무효화</li>
</ol>
<pre><code>tile_using_forall %arg1
emit_remark_at %arg1   // 이미 죽은 핸들
</code></pre>
<ul>
<li>타일링은 연산을 지우고 새로 만듦</li>
<li>옛날 핸들은 dangling point 상태이다.</li>
<li>Expensive checks 모드가 켜져 있을 경우</li>
<li>이 핸들이 무효라는 것을 알려준다.</li>
</ul>
<p>무효화 (invalidated) 는
해당 handle이 가리키던 payload IR entity(연산 / 값)가 더 이상 그 모습 그대로 존재하지 않아, 이 행들로 접근하면 위험하다는 상태임.</p>
<ul>
<li>예시로 tile_using_forall %arg1 같은 타일링은</li>
</ul>
<ul>
<li>linalg.matmul 을 그대로 두는게 아니라</li>
<li>슬라이스 / 루프 / 새로운 작은 matmul 형태로 재구성을 함.</li>
</ul>
<p>그러면 %arg1이 가리키던 그 matmul이</p>
<ul>
<li>없어지거나</li>
<li>구조가 바뀌거나</li>
<li>다른 op로 대체될 수 있음.</li>
</ul>
<p>그렇기 때문에 transform dialect는 안전장치로</p>
<ul>
<li>이 operand handle은 consumed</li>
<li>그리고 그것과 같은 payload op를 가리키던 다른 핸들도 전부 invalidated 라고 처리한다.</li>
</ul>
<ul>
<li>참고로 alias(별칭)도 같이 무효가 되는데</li>
</ul>
<pre><code>%casted = transform.cast %arg1 : ... to !transform.any_op
</code></pre>
<p>%arg1과 %casted 는 같은 payload op를 참조(alias) 한다.
원본이 없어지면 둘다 무효가 되는 것은 당연하다. (포인터 복사해도 주소는 같기 때문)</p>
<ol start="8">
<li>핸들은 복사한다 해도 같이 죽는다.</li>
</ol>
<pre><code>%casted = transform.cast %arg1
</code></pre>
<ul>
<li>%arg1과 %casted 는 같은 연산을 가리킨다.</li>
<li>하나가 무효화 되면 -&gt; 둘다 무효다.</li>
</ul>
<ul>
<li>즉 참조(reference) 처럼 생각하면 딱 맞는다.</li>
</ul>
<ol start="9">
<li>변환 체이닝</li>
</ol>
<ul>
<li>마지막 연산 (RELU) 부터 타일링을 진행함</li>
<li>그 루프 안으로<!-- -->
<ul>
<li>add 연산을 fuse 하고</li>
<li>matmul도 fuse 한다.</li>
</ul>
</li>
</ul>
<pre><code>tile → fuse add → fuse matmul
</code></pre>
<p>그 결과</p>
<ul>
<li>캐시 효율도 올라가고</li>
<li>코드도 깔끔해지고</li>
<li>크기 조절도 자동으로 된다.</li>
</ul>
<ul>
<li>참고로 fuse를 좀더 자세히 설명해 보자면, 두(혹은 여러) 연산을 같은 루프 안으로 합쳐서, 중간 결과를 밖에 안 만들게 하는 것이다.
원래 라면</li>
</ul>
<ol>
<li>matmul 결과를 큰 tensor에 쓰고</li>
<li>그 tensor를 다시 읽어서 add 하고</li>
<li>또 다시 읽어서 max(ReLU) 를 했을거임.
이 경우 메모리 왕복이 많아짐.</li>
</ol>
<p>fuse를 하게 되면</p>
<ul>
<li>ReLU 를 타일링 해서 루프를 만들고</li>
<li>그 루프 안에서 필요한 add, matmul 도 같이 계산하게 끌어들임.
아래와 같은 방식으로</li>
</ul>
<pre><code>for tile ... {
  tile_matmul()
  tile_add()
  tile_relu()
}

즉,

for each tile:
  A_tile, B_tile 읽음
  matmul(tile) → 레지스터/캐시
  add(tile)    → 바로 이어서
  relu(tile)   → 바로 이어서
  결과 tile만 메모리에 씀
</code></pre>
<p>이렇게 했을때</p>
<ul>
<li>중간 텐서를 크게 저장/로드 하지 않고</li>
<li>타일 단위로 바로 다음 연산을 이어서 처리하여 캐시 / 대역폭에서 이득을 볼 수 있다. (하나의 tile 범위에 대해서)</li>
</ul>
<ol start="10">
<li>더 작은 타일 + 아웃라이닝</li>
</ol>
<ul>
<li>4x4 matmul 마이크로 커널이 있다면?
(1) 다시 타일링을 하고
(2) 루프를 함수로 outline 한다음
(3) 나중에 마이크로 커널 호출로 교체를 한다.</li>
</ul>
<ul>
<li>주의할 부분이라면</li>
</ul>
<ul>
<li>outline도 핸들을 소모하고</li>
<li>그 안에 있던 연산 핸들이 전부 무효화 된다.</li>
</ul>
<ul>
<li>Kernel은 DL / 선형대수의 Kernel 개념이 맞음.
Microkernel 은</li>
</ul>
<ul>
<li>아주 작은 고정 크기 블록 (ex: 4x4 matmul) 을</li>
<li>어셈블리 / 벤더 intrinsics / 특수 명령어로 최적화해 둔 함수이다.<!-- -->
<ul>
<li>BLAS 내부, oneDNN, XNNPACK류가 이런 스타일을 많이 씀</li>
</ul>
</li>
</ul>
<ul>
<li>replace 흐름의 경우</li>
</ul>
<ol>
<li>큰 matmul을 타일링 해서 4x4 단위로 쪼개고</li>
<li>그 4x4 계산을 별도 함수로 outline(= 루프 바디를 함수로 떼어내고)</li>
<li>그 함수 호출(func.call) 을<!-- -->
<ul>
<li>microkernel_4x4(...) 같은 특수 호출로 바꾸고 싶다
즉 outline 된 함수 호출을 마이크로커널 호출로 바꾸는 것임.</li>
</ul>
</li>
</ol>
<ul>
<li>왜 굳이 outline을 하는가? (outline : 코드 조각을 바깥으로빼서(out) 별도의 함수를 만들어(line을 긋는다.))</li>
</ul>
<ul>
<li>Transform dialect 에서 &quot;임의의 호출을 내 마음대로 다른 호출로 바꾸기&quot;는 기본 제공이 제한적임.</li>
<li>일단 호출 형태로 만들어 놓으면 (=call)</li>
<li>그 다음단계 (커스텀 transform op 또는 다른패스) 에서 교체하기가 쉬워짐.</li>
</ul>
<p>최종적으로</p>
<ul>
<li>호출로 교체한다는 것은 타일된 작은 계산 <code>-&gt;</code> 특수 최적화 함수 호출로 바꾸어서 성능을 극대화 한다는 것이다.</li>
</ul>
<ol start="11">
<li>Transform dialect 의 자동 추적
Transform은 IR 변경을 자동 추적함.</li>
</ol>
<ul>
<li>연산 삭제 <code>-&gt;</code> 핸들에서 자동 제거</li>
<li>연산 교체 <code>-&gt;</code> 가능한 경우 핸들 자동 갱신</li>
<li>애매하면 <code>-&gt;</code> 에러로 막아준다.
이를 통해 몰래 잘못 바꾸는 일을 방지한다.</li>
</ul>
<p>=====================================================================</p>
<p>요약해 보자면 Transform Dialect는 IR을 바꾸는 과정을 IR로 작성하는 안전한 자동 리팩토링 언어라 할 수 있음.</p>
<p>Rewrite는 로컬 규칙 (치환) 자체였다면, Transform은 그 규칙/패스를 어떤 순서, 범위, 전략으로 적용할지 (오케스트레이션)</p></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n:HC[\"/\",\"\"]\n:HL[\"/blog/_next/static/chunks/4057cc9dbcc744c0.css\",\"style\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"Ji-piVBREfl1BCiHbQepC\",\"c\":[\"\",\"posts\",\"mlir\",\"md-t1\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-t1\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/4057cc9dbcc744c0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"style\":{\"maxWidth\":\"800px\",\"margin\":\"0 auto\",\"padding\":\"20px\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Transform Tutorial Ch 1 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-11-22\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\",\"fontStyle\":\"italic\"},\"children\":\"Combining Existing Transformations\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"style\":{\"lineHeight\":1.6},\"children\":[[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform IR은 뭘까?\\nTransform Dialect란 어떤 IR 연산을, 어떤 순서로, 어떻게 바꿀지를 또 다른 IR로 표현하는 방식이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Payload IR : 진짜 바꾸고 싶은 코드 (ex: linalg.matmul)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform IR : \\\"이걸타일링 해라, 저걸 합쳐라\\\" 와 같은 변환 스크립트\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"여기서 많이 물어보는게 rewrite와 transform의 차이이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"rewrite는 무엇을 무엇으로 바꿀지에 초점이 있는 local 한 규칙 기반의 치환\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"보통 한 개 op(혹은 작은 subgraph) 를 매칭해서 다른 형태로 치환\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"applyPatternsAndFoldGreedily, canonicalization, dialect conversion 등에서 패턴 엔진이 반복 적용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"규칙 자체가 변환 스케줄(순서/반복/적용 범위) 을 강하게 드러내지 않는 경우가 많음(대개 “greedy로 될 때까지” 같은 식)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"“이 op를 이런 op로 바꾼다”, “이런 조합이면 fold 한다” 같은 미세 최적화/정규화에 강함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Lowering(예: linalg \",[\"$\",\"code\",null,{\"children\":\"→\"}],\" scf \",[\"$\",\"code\",null,{\"children\":\"→\"}],\" llvm)에서도 실제 치환은 대개 rewrite 패턴으로 구현됨\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"예시는 arith.addi에 상수 0이 들어오면 x + 0 \",[\"$\",\"code\",null,{\"children\":\"→\"}],\" x로 바꾸는 canonicalization 패턴.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"반면 transform은 **“어떤 변환을 어떤 순서로, 어디에, 어떻게 적용할지”**에 초점인 변환 오케스트레이션/스케줄링 레이어예요.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"형태: Transform dialect IR 로 “변환 프로그램”을 작성\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"단위: rewrite보다 더 큰 범위/전략을 다룸 (어떤 함수들만 대상으로 삼기, 특정 op 집합에만 타일링 적용, 그 다음 벡터화, 그 다음 버퍼화…)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"실행 방식: transform interpreter/runner가 Transform IR을 실행하면서 대상 payload IR에 변환을 적용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"변환 순서와 적용 범위를 명시적으로 제어 가능\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"“같은 rewrite 패턴/패스를 쓰더라도” 파이프라인을 IR로 표현해서 실험/튜닝/재사용이 쉬움\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"타겟별 튜닝(예: CPU vs GPU)에서 “전략”을 바꾸기 좋음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"예시는 “이 linalg.matmul들만 찾아서 tile size=…로 타일링하고, 그 결과를 벡터화하고, 특정 조건이면 unroll한다” 같은 전략 스크립트.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핸들 (handle) 의 개념\\nTransform IR은 handle을 통해 Payload IR을 조작함.\\nhandle 의 종류는 다음과 같음\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"operation handle : 특정 연산 (linalg.matmul)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"value handle : 값\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"parameter : 숫자, 속성 같은 설정 값\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%arg1 : !transform.op\u003c\\\"linalg.matmul\\\"\u003e\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 핸들은 matmul 연산만 가리킬 수 있음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"시작점: @__transform_main\\nTransform은 항상 여기서 시작함\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"transform.named_sequence @__transform_main(...)\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"마치 C의 main() 함수\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"어떤 연산을 언제, 어떤 순서로 변환할지 정의\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"내부는 그냥 \\\"변환을 차례대로 나열\\\" 하는 구조\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform.with_named_sequence\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 모듈 안에 transform 시퀀스가 있다는 것을 알려줌.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform 이 실패하였을 때\\nTransform 에는 실패 전파(propagate) 모드가 있음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"propagate의 경우\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"하나라도 실패하면 전체 실패\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"디버깅 할때는 최고\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"suppress\"}],\"\\n\"]}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\",\"\\n\",\"$L28\",\"\\n\",\"$L29\",\"\\n\",\"$L2a\",\"\\n\",\"$L2b\",\"\\n\",\"$L2c\",\"\\n\",\"$L2d\",\"\\n\",\"$L2e\",\"\\n\",\"$L2f\",\"\\n\",\"$L30\",\"\\n\",\"$L31\",\"\\n\",\"$L32\",\"\\n\",\"$L33\",\"\\n\",\"$L34\",\"\\n\",\"$L35\",\"\\n\",\"$L36\",\"\\n\",\"$L37\",\"\\n\",\"$L38\",\"\\n\",\"$L39\",\"\\n\",\"$L3a\",\"\\n\",\"$L3b\",\"\\n\",\"$L3c\",\"\\n\",\"$L3d\",\"\\n\",\"$L3e\",\"\\n\",\"$L3f\",\"\\n\",\"$L40\",\"\\n\",\"$L41\",\"\\n\",\"$L42\",\"\\n\",\"$L43\",\"\\n\",\"$L44\",\"\\n\",\"$L45\",\"\\n\",\"$L46\",\"\\n\",\"$L47\",\"\\n\",\"$L48\",\"\\n\",\"$L49\",\"\\n\",\"$L4a\",\"\\n\",\"$L4b\"]}],\"$L4c\",\"$L4d\"]}]\n"])</script><script>self.__next_f.push([1,"4e:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"실패는 무시하고 바깥 스크립트는 계속 실행함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"실패해도 괜찮은 변환에 유용함.\"}],\"\\n\"]}]\nf:[\"$\",\"ol\",null,{\"start\":\"5\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"디버깅을 어떻게 하는가\\n예를 들어서 어떤 연산이 잡혀있는지 확인하고 싶을 때\"}],\"\\n\"]}]\n10:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"transform.debug.emit_remark_at %arg1, \\\"matmul\\\"\\n\"}]}]\n11:[\"$\",\"p\",null,{\"children\":[\"컴파일 로그에 아래와 같은 내용이 찍힘\\n\",[\"$\",\"code\",null,{\"children\":\"“이 matmul을 지금 보고 있다!”\"}]]}]\n12:[\"$\",\"ol\",null,{\"start\":\"6\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"실제 변환 : 타일링\\n예를 들어 matmul을 타일링 하게 되면\"}],\"\\n\"]}]\n13:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%loop, %tiled =\\n  transform.structured.tile_using_forall %arg1 tile_sizes [4, 32]\\n\"}]}]\n14:[\"$\",\"p\",null,{\"children\":\"그 결과\"}]\n15:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"%loop \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 새로 생긴 scf.forall 루프\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"%tiled \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 타일된 연산\"]}],\"\\n\"]}]\n16:[\"$\",\"p\",null,{\"children\":\"기존 핸들은 소모(consumed) 된다.\\n여기서 소모라는 것은 transform op가 그 핸들이 가리키던 payload op들을 없애거나(erase) 새로 만들거나(recreate) 해서 기존 참조가 위험해 질때 소비 되었다고 표시함.\"}]\n17:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Consumed 로 표시된 operand handle은 그 transform 이후에 쓰면 안된다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다른 라인, 즉 이후 어떤 위치에서도 재사용 할 경우 UB(정의되지 않은 동작) 이 됨.\"}],\"\\n\"]}]\n18:[\"$\",\"p\",null,{\"children\":\"이렇게 강하게 막는 이유는\"}]\n19:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핸들은 본질적으로 \\\"payload op\\\" 에 대한 참조(reference) 인데\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"op가 지워지거나 새로 만들면 참조가 헛것이 될 수 있기 때문\"}],\"\\n\"]}]\n1a:[\"$\",\"p\",null,{\"children\":\"결론적으로 사용했기 떄문에 못쓴다 이런게 아니라 해당 transform 이 payload를 재작성 했기 때문에 못쓰는 것이다.\\n참고로 payload IR은 실제로 바꾸고 싶은 IR을 의미함.\"}]\n1b:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"linalg.matmul\\nlinalg.elementwise\\nscf.forall\\ntensor.extract_slice\\nfunc.func\\n\\nfunc.func @fc_relu(...) {\\n  %matmul = linalg.matmul ...\\n  %add = linalg.elementwise ...\\n  %relu = linalg.elementwise ...\\n}\\n\"}]}]\n1c:[\"$\",\"p\",null,{\"children\":\"이런 것들, 변환의 대상이 되는 IR\"}]\n1d:[\"$\",\"p\",null,{\"children\":\"Transform IR은 payload op를 직접 수정하지 않고, handle을 통해 간접 조작한다.\"}]\n1e:[\"$\",\"ol\",null,{\"start\":\"7\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핸들 무효화\"}],\"\\n\"]}]\n1f:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"tile_using_forall %arg1\\nemit_remark_at %arg1   // 이미 죽은 핸들\\n\"}]}]\n20:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"타일링은 연산을 지우고 새로 만듦\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"옛날 핸들은 dangling point 상태이다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Expensive checks 모드가 켜져 있을 경우\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 핸들이 무효라는 것을 알려준다.\"}],\"\\n\"]}]\n21:[\"$\",\"p\",null,{\"children\":\"무효화 (invalidated) 는\\n해당 handle이 가리키던 payload IR entity(연산 / 값)가 더 이상 그 모습 그대로 존재하지 않아, 이 행들로 접근하면 위험하다는 상태임.\"}]\n22:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"예시로 tile_using_forall %arg1 같은 타일링은\"}],\"\\n\"]}]\n23:[\"$\",\"ul\",null,{\"ch"])</script><script>self.__next_f.push([1,"ildren\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"linalg.matmul 을 그대로 두는게 아니라\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"슬라이스 / 루프 / 새로운 작은 matmul 형태로 재구성을 함.\"}],\"\\n\"]}]\n24:[\"$\",\"p\",null,{\"children\":\"그러면 %arg1이 가리키던 그 matmul이\"}]\n25:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"없어지거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"구조가 바뀌거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다른 op로 대체될 수 있음.\"}],\"\\n\"]}]\n26:[\"$\",\"p\",null,{\"children\":\"그렇기 때문에 transform dialect는 안전장치로\"}]\n27:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 operand handle은 consumed\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그리고 그것과 같은 payload op를 가리키던 다른 핸들도 전부 invalidated 라고 처리한다.\"}],\"\\n\"]}]\n28:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"참고로 alias(별칭)도 같이 무효가 되는데\"}],\"\\n\"]}]\n29:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%casted = transform.cast %arg1 : ... to !transform.any_op\\n\"}]}]\n2a:[\"$\",\"p\",null,{\"children\":\"%arg1과 %casted 는 같은 payload op를 참조(alias) 한다.\\n원본이 없어지면 둘다 무효가 되는 것은 당연하다. (포인터 복사해도 주소는 같기 때문)\"}]\n2b:[\"$\",\"ol\",null,{\"start\":\"8\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핸들은 복사한다 해도 같이 죽는다.\"}],\"\\n\"]}]\n2c:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%casted = transform.cast %arg1\\n\"}]}]\n2d:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"%arg1과 %casted 는 같은 연산을 가리킨다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"하나가 무효화 되면 -\u003e 둘다 무효다.\"}],\"\\n\"]}]\n2e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"즉 참조(reference) 처럼 생각하면 딱 맞는다.\"}],\"\\n\"]}]\n2f:[\"$\",\"ol\",null,{\"start\":\"9\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"변환 체이닝\"}],\"\\n\"]}]\n30:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"마지막 연산 (RELU) 부터 타일링을 진행함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"그 루프 안으로\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"add 연산을 fuse 하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"matmul도 fuse 한다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n31:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"tile → fuse add → fuse matmul\\n\"}]}]\n32:[\"$\",\"p\",null,{\"children\":\"그 결과\"}]\n33:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"캐시 효율도 올라가고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"코드도 깔끔해지고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"크기 조절도 자동으로 된다.\"}],\"\\n\"]}]\n34:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"참고로 fuse를 좀더 자세히 설명해 보자면, 두(혹은 여러) 연산을 같은 루프 안으로 합쳐서, 중간 결과를 밖에 안 만들게 하는 것이다.\\n원래 라면\"}],\"\\n\"]}]\n35:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"matmul 결과를 큰 tensor에 쓰고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그 tensor를 다시 읽어서 add 하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"또 다시 읽어서 max(ReLU) 를 했을거임.\\n이 경우 메모리 왕복이 많아짐.\"}],\"\\n\"]}]\n36:[\"$\",\"p\",null,{\"children\":\"fuse를 하게 되면\"}]\n37:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"ReLU 를 타일링 해서 루프를 만들고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그 루프 안에서 필요한 add, matmul 도 같이 계산하게 끌어들임.\\n아래와 같은 방식으로\"}],\"\\n\"]}]\n38:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"for tile ... {\\n  tile_matmul()\\n  tile_add()\\n  tile_relu()\\n}\\n\\n즉,\\n\\nfor each tile:\\n  A_tile, B_tile 읽음\\n  matmul(tile) → 레지스터/캐시\\n  add(tile)    → 바로 이어서\\n  relu(tile)   → 바로 이어서\\n  결과 tile만 메모리에 씀\\n\"}]}]\n39:[\"$\",\"p\",null,{\"children\":\"이렇게 했을때\"}]\n3a:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\""])</script><script>self.__next_f.push([1,"children\":\"중간 텐서를 크게 저장/로드 하지 않고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"타일 단위로 바로 다음 연산을 이어서 처리하여 캐시 / 대역폭에서 이득을 볼 수 있다. (하나의 tile 범위에 대해서)\"}],\"\\n\"]}]\n3b:[\"$\",\"ol\",null,{\"start\":\"10\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"더 작은 타일 + 아웃라이닝\"}],\"\\n\"]}]\n3c:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"4x4 matmul 마이크로 커널이 있다면?\\n(1) 다시 타일링을 하고\\n(2) 루프를 함수로 outline 한다음\\n(3) 나중에 마이크로 커널 호출로 교체를 한다.\"}],\"\\n\"]}]\n3d:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"주의할 부분이라면\"}],\"\\n\"]}]\n3e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"outline도 핸들을 소모하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그 안에 있던 연산 핸들이 전부 무효화 된다.\"}],\"\\n\"]}]\n3f:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Kernel은 DL / 선형대수의 Kernel 개념이 맞음.\\nMicrokernel 은\"}],\"\\n\"]}]\n40:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"아주 작은 고정 크기 블록 (ex: 4x4 matmul) 을\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"어셈블리 / 벤더 intrinsics / 특수 명령어로 최적화해 둔 함수이다.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"BLAS 내부, oneDNN, XNNPACK류가 이런 스타일을 많이 씀\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n41:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"replace 흐름의 경우\"}],\"\\n\"]}]\n42:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"큰 matmul을 타일링 해서 4x4 단위로 쪼개고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그 4x4 계산을 별도 함수로 outline(= 루프 바디를 함수로 떼어내고)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"그 함수 호출(func.call) 을\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"microkernel_4x4(...) 같은 특수 호출로 바꾸고 싶다\\n즉 outline 된 함수 호출을 마이크로커널 호출로 바꾸는 것임.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n43:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"왜 굳이 outline을 하는가? (outline : 코드 조각을 바깥으로빼서(out) 별도의 함수를 만들어(line을 긋는다.))\"}],\"\\n\"]}]\n44:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform dialect 에서 \\\"임의의 호출을 내 마음대로 다른 호출로 바꾸기\\\"는 기본 제공이 제한적임.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"일단 호출 형태로 만들어 놓으면 (=call)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"그 다음단계 (커스텀 transform op 또는 다른패스) 에서 교체하기가 쉬워짐.\"}],\"\\n\"]}]\n45:[\"$\",\"p\",null,{\"children\":\"최종적으로\"}]\n46:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"호출로 교체한다는 것은 타일된 작은 계산 \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 특수 최적화 함수 호출로 바꾸어서 성능을 극대화 한다는 것이다.\"]}],\"\\n\"]}]\n47:[\"$\",\"ol\",null,{\"start\":\"11\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform dialect 의 자동 추적\\nTransform은 IR 변경을 자동 추적함.\"}],\"\\n\"]}]\n48:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"연산 삭제 \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 핸들에서 자동 제거\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"연산 교체 \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 가능한 경우 핸들 자동 갱신\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"애매하면 \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 에러로 막아준다.\\n이를 통해 몰래 잘못 바꾸는 일을 방지한다.\"]}],\"\\n\"]}]\n49:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n4a:[\"$\",\"p\",null,{\"children\":\"요약해 보자면 Transform Dialect는 IR을 바꾸는 과정을 IR로 작성하는 안전한 자동 리팩토링 언어라 할 수 있음.\"}]\n4b:[\"$\",\"p\",null,{\"children\":\"Rewrite는 로컬 규칙 (치환) 자체였다면, Transform은"])</script><script>self.__next_f.push([1," 그 규칙/패스를 어떤 순서, 범위, 전략으로 적용할지 (오케스트레이션)\"}]\n4c:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n4d:[\"$\",\"$L4e\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"4f:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Transform Tutorial Ch 1 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Combining Existing Transformations\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L4f\",\"3\",{}]]\n8:null\n"])</script></body></html>