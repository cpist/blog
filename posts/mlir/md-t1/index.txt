1:"$Sreact.fragment"
2:I[22016,["/blog/_next/static/chunks/796e69ae18b2784c.js"],""]
3:I[39756,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
4:I[37457,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
6:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"ViewportBoundary"]
b:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"MetadataBoundary"]
d:I[68027,[],"default"]
:HL["/blog/_next/static/chunks/743a8f8bdb738f7f.css","style"]
:HC["/",""]
:HL["https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css","style",{"crossOrigin":"anonymous","integrity":"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"}]
0:{"P":null,"b":"TmeFl9XvlrdQDoLIMxpL3","c":["","posts","mlir","md-t1",""],"q":"","i":false,"f":[[["",{"children":["posts",{"children":[["slug","mlir/md-t1","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/blog/_next/static/chunks/743a8f8bdb738f7f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","script","script-0",{"src":"/blog/_next/static/chunks/796e69ae18b2784c.js","async":true,"nonce":"$undefined"}]],["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":["$","link",null,{"rel":"stylesheet","href":"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css","integrity":"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu","crossOrigin":"anonymous"}]}],["$","body",null,{"children":["$","main",null,{"children":[["$","header",null,{"style":{"display":"flex","justifyContent":"space-between","alignItems":"baseline","gap":12},"children":[["$","h1",null,{"style":{"margin":"8px 0"},"children":["$","$L2",null,{"href":"/","style":{"textDecoration":"none"},"children":"CPIST's blog"}]}],["$","nav",null,{"style":{"display":"flex","gap":12},"children":["$","$L2",null,{"href":"/posts","children":"Posts"}]}]]}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"12px 0 24px"}}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","footer",null,{"style":{"marginTop":48,"paddingTop":16,"borderTop":"1px solid #eee","color":"#666"},"children":["© ",2026," CPIST's blog"]}]]}]}]]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",[["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true,"nonce":"$undefined"}]],["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],null]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
5:["$","article",null,{"style":{"maxWidth":"800px","margin":"0 auto","padding":"20px"},"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Transform Tutorial Ch 1 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-11-22"}],["$","p",null,{"style":{"color":"#333","fontStyle":"italic"},"children":"Combining Existing Transformations"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","style":{"lineHeight":1.6},"children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"Transform IR은 뭘까?\nTransform Dialect란 어떤 IR 연산을, 어떤 순서로, 어떻게 바꿀지를 또 다른 IR로 표현하는 방식이다."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Payload IR : 진짜 바꾸고 싶은 코드 (ex: linalg.matmul)"}],"\n",["$","li",null,{"children":"Transform IR : \"이걸타일링 해라, 저걸 합쳐라\" 와 같은 변환 스크립트"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"여기서 많이 물어보는게 rewrite와 transform의 차이이다."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["rewrite는 무엇을 무엇으로 바꿀지에 초점이 있는 local 한 규칙 기반의 치환","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"보통 한 개 op(혹은 작은 subgraph) 를 매칭해서 다른 형태로 치환"}],"\n",["$","li",null,{"children":"applyPatternsAndFoldGreedily, canonicalization, dialect conversion 등에서 패턴 엔진이 반복 적용"}],"\n",["$","li",null,{"children":"규칙 자체가 변환 스케줄(순서/반복/적용 범위) 을 강하게 드러내지 않는 경우가 많음(대개 “greedy로 될 때까지” 같은 식)"}],"\n",["$","li",null,{"children":"“이 op를 이런 op로 바꾼다”, “이런 조합이면 fold 한다” 같은 미세 최적화/정규화에 강함"}],"\n",["$","li",null,{"children":["Lowering(예: linalg ",["$","code",null,{"children":"→"}]," scf ",["$","code",null,{"children":"→"}]," llvm)에서도 실제 치환은 대개 rewrite 패턴으로 구현됨"]}],"\n",["$","li",null,{"children":["예시는 arith.addi에 상수 0이 들어오면 x + 0 ",["$","code",null,{"children":"→"}]," x로 바꾸는 canonicalization 패턴."]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["반면 transform은 **“어떤 변환을 어떤 순서로, 어디에, 어떻게 적용할지”**에 초점인 변환 오케스트레이션/스케줄링 레이어예요.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"형태: Transform dialect IR 로 “변환 프로그램”을 작성"}],"\n",["$","li",null,{"children":"단위: rewrite보다 더 큰 범위/전략을 다룸 (어떤 함수들만 대상으로 삼기, 특정 op 집합에만 타일링 적용, 그 다음 벡터화, 그 다음 버퍼화…)"}],"\n",["$","li",null,{"children":"실행 방식: transform interpreter/runner가 Transform IR을 실행하면서 대상 payload IR에 변환을 적용"}],"\n",["$","li",null,{"children":"변환 순서와 적용 범위를 명시적으로 제어 가능"}],"\n",["$","li",null,{"children":"“같은 rewrite 패턴/패스를 쓰더라도” 파이프라인을 IR로 표현해서 실험/튜닝/재사용이 쉬움"}],"\n",["$","li",null,{"children":"타겟별 튜닝(예: CPU vs GPU)에서 “전략”을 바꾸기 좋음"}],"\n",["$","li",null,{"children":"예시는 “이 linalg.matmul들만 찾아서 tile size=…로 타일링하고, 그 결과를 벡터화하고, 특정 조건이면 unroll한다” 같은 전략 스크립트."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"핸들 (handle) 의 개념\nTransform IR은 handle을 통해 Payload IR을 조작함.\nhandle 의 종류는 다음과 같음"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"operation handle : 특정 연산 (linalg.matmul)"}],"\n",["$","li",null,{"children":"value handle : 값"}],"\n",["$","li",null,{"children":"parameter : 숫자, 속성 같은 설정 값"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"%arg1 : !transform.op<\"linalg.matmul\">\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 핸들은 matmul 연산만 가리킬 수 있음."}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"시작점: @__transform_main\nTransform은 항상 여기서 시작함"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"transform.named_sequence @__transform_main(...)\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"마치 C의 main() 함수"}],"\n",["$","li",null,{"children":"어떤 연산을 언제, 어떤 순서로 변환할지 정의"}],"\n",["$","li",null,{"children":"내부는 그냥 \"변환을 차례대로 나열\" 하는 구조"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"transform.with_named_sequence"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 모듈 안에 transform 시퀀스가 있다는 것을 알려줌."}],"\n"]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"transform 이 실패하였을 때\nTransform 에는 실패 전파(propagate) 모드가 있음."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"propagate의 경우"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"하나라도 실패하면 전체 실패"}],"\n",["$","li",null,{"children":"디버깅 할때는 최고"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"suppress"}],"\n"]}],"\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27","\n","$L28","\n","$L29","\n","$L2a","\n","$L2b","\n","$L2c","\n","$L2d","\n","$L2e","\n","$L2f","\n","$L30","\n","$L31","\n","$L32","\n","$L33","\n","$L34","\n","$L35","\n","$L36","\n","$L37","\n","$L38","\n","$L39","\n","$L3a","\n","$L3b","\n","$L3c","\n","$L3d","\n","$L3e","\n","$L3f","\n","$L40","\n","$L41","\n","$L42","\n","$L43","\n","$L44","\n","$L45","\n","$L46","\n","$L47","\n","$L48","\n","$L49","\n","$L4a","\n","$L4b"]}],"$L4c","$L4d"]}]
4e:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
e:["$","ul",null,{"children":["\n",["$","li",null,{"children":"실패는 무시하고 바깥 스크립트는 계속 실행함."}],"\n",["$","li",null,{"children":"실패해도 괜찮은 변환에 유용함."}],"\n"]}]
f:["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"디버깅을 어떻게 하는가\n예를 들어서 어떤 연산이 잡혀있는지 확인하고 싶을 때"}],"\n"]}]
10:["$","pre",null,{"children":["$","code",null,{"children":"transform.debug.emit_remark_at %arg1, \"matmul\"\n"}]}]
11:["$","p",null,{"children":["컴파일 로그에 아래와 같은 내용이 찍힘\n",["$","code",null,{"children":"“이 matmul을 지금 보고 있다!”"}]]}]
12:["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"실제 변환 : 타일링\n예를 들어 matmul을 타일링 하게 되면"}],"\n"]}]
13:["$","pre",null,{"children":["$","code",null,{"children":"%loop, %tiled =\n  transform.structured.tile_using_forall %arg1 tile_sizes [4, 32]\n"}]}]
14:["$","p",null,{"children":"그 결과"}]
15:["$","ul",null,{"children":["\n",["$","li",null,{"children":["%loop ",["$","code",null,{"children":"->"}]," 새로 생긴 scf.forall 루프"]}],"\n",["$","li",null,{"children":["%tiled ",["$","code",null,{"children":"->"}]," 타일된 연산"]}],"\n"]}]
16:["$","p",null,{"children":"기존 핸들은 소모(consumed) 된다.\n여기서 소모라는 것은 transform op가 그 핸들이 가리키던 payload op들을 없애거나(erase) 새로 만들거나(recreate) 해서 기존 참조가 위험해 질때 소비 되었다고 표시함."}]
17:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Consumed 로 표시된 operand handle은 그 transform 이후에 쓰면 안된다."}],"\n",["$","li",null,{"children":"다른 라인, 즉 이후 어떤 위치에서도 재사용 할 경우 UB(정의되지 않은 동작) 이 됨."}],"\n"]}]
18:["$","p",null,{"children":"이렇게 강하게 막는 이유는"}]
19:["$","ul",null,{"children":["\n",["$","li",null,{"children":"핸들은 본질적으로 \"payload op\" 에 대한 참조(reference) 인데"}],"\n",["$","li",null,{"children":"op가 지워지거나 새로 만들면 참조가 헛것이 될 수 있기 때문"}],"\n"]}]
1a:["$","p",null,{"children":"결론적으로 사용했기 떄문에 못쓴다 이런게 아니라 해당 transform 이 payload를 재작성 했기 때문에 못쓰는 것이다.\n참고로 payload IR은 실제로 바꾸고 싶은 IR을 의미함."}]
1b:["$","pre",null,{"children":["$","code",null,{"children":"linalg.matmul\nlinalg.elementwise\nscf.forall\ntensor.extract_slice\nfunc.func\n\nfunc.func @fc_relu(...) {\n  %matmul = linalg.matmul ...\n  %add = linalg.elementwise ...\n  %relu = linalg.elementwise ...\n}\n"}]}]
1c:["$","p",null,{"children":"이런 것들, 변환의 대상이 되는 IR"}]
1d:["$","p",null,{"children":"Transform IR은 payload op를 직접 수정하지 않고, handle을 통해 간접 조작한다."}]
1e:["$","ol",null,{"start":"7","children":["\n",["$","li",null,{"children":"핸들 무효화"}],"\n"]}]
1f:["$","pre",null,{"children":["$","code",null,{"children":"tile_using_forall %arg1\nemit_remark_at %arg1   // 이미 죽은 핸들\n"}]}]
20:["$","ul",null,{"children":["\n",["$","li",null,{"children":"타일링은 연산을 지우고 새로 만듦"}],"\n",["$","li",null,{"children":"옛날 핸들은 dangling point 상태이다."}],"\n",["$","li",null,{"children":"Expensive checks 모드가 켜져 있을 경우"}],"\n",["$","li",null,{"children":"이 핸들이 무효라는 것을 알려준다."}],"\n"]}]
21:["$","p",null,{"children":"무효화 (invalidated) 는\n해당 handle이 가리키던 payload IR entity(연산 / 값)가 더 이상 그 모습 그대로 존재하지 않아, 이 행들로 접근하면 위험하다는 상태임."}]
22:["$","ul",null,{"children":["\n",["$","li",null,{"children":"예시로 tile_using_forall %arg1 같은 타일링은"}],"\n"]}]
23:["$","ul",null,{"children":["\n",["$","li",null,{"children":"linalg.matmul 을 그대로 두는게 아니라"}],"\n",["$","li",null,{"children":"슬라이스 / 루프 / 새로운 작은 matmul 형태로 재구성을 함."}],"\n"]}]
24:["$","p",null,{"children":"그러면 %arg1이 가리키던 그 matmul이"}]
25:["$","ul",null,{"children":["\n",["$","li",null,{"children":"없어지거나"}],"\n",["$","li",null,{"children":"구조가 바뀌거나"}],"\n",["$","li",null,{"children":"다른 op로 대체될 수 있음."}],"\n"]}]
26:["$","p",null,{"children":"그렇기 때문에 transform dialect는 안전장치로"}]
27:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 operand handle은 consumed"}],"\n",["$","li",null,{"children":"그리고 그것과 같은 payload op를 가리키던 다른 핸들도 전부 invalidated 라고 처리한다."}],"\n"]}]
28:["$","ul",null,{"children":["\n",["$","li",null,{"children":"참고로 alias(별칭)도 같이 무효가 되는데"}],"\n"]}]
29:["$","pre",null,{"children":["$","code",null,{"children":"%casted = transform.cast %arg1 : ... to !transform.any_op\n"}]}]
2a:["$","p",null,{"children":"%arg1과 %casted 는 같은 payload op를 참조(alias) 한다.\n원본이 없어지면 둘다 무효가 되는 것은 당연하다. (포인터 복사해도 주소는 같기 때문)"}]
2b:["$","ol",null,{"start":"8","children":["\n",["$","li",null,{"children":"핸들은 복사한다 해도 같이 죽는다."}],"\n"]}]
2c:["$","pre",null,{"children":["$","code",null,{"children":"%casted = transform.cast %arg1\n"}]}]
2d:["$","ul",null,{"children":["\n",["$","li",null,{"children":"%arg1과 %casted 는 같은 연산을 가리킨다."}],"\n",["$","li",null,{"children":"하나가 무효화 되면 -> 둘다 무효다."}],"\n"]}]
2e:["$","ul",null,{"children":["\n",["$","li",null,{"children":"즉 참조(reference) 처럼 생각하면 딱 맞는다."}],"\n"]}]
2f:["$","ol",null,{"start":"9","children":["\n",["$","li",null,{"children":"변환 체이닝"}],"\n"]}]
30:["$","ul",null,{"children":["\n",["$","li",null,{"children":"마지막 연산 (RELU) 부터 타일링을 진행함"}],"\n",["$","li",null,{"children":["그 루프 안으로","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"add 연산을 fuse 하고"}],"\n",["$","li",null,{"children":"matmul도 fuse 한다."}],"\n"]}],"\n"]}],"\n"]}]
31:["$","pre",null,{"children":["$","code",null,{"children":"tile → fuse add → fuse matmul\n"}]}]
32:["$","p",null,{"children":"그 결과"}]
33:["$","ul",null,{"children":["\n",["$","li",null,{"children":"캐시 효율도 올라가고"}],"\n",["$","li",null,{"children":"코드도 깔끔해지고"}],"\n",["$","li",null,{"children":"크기 조절도 자동으로 된다."}],"\n"]}]
34:["$","ul",null,{"children":["\n",["$","li",null,{"children":"참고로 fuse를 좀더 자세히 설명해 보자면, 두(혹은 여러) 연산을 같은 루프 안으로 합쳐서, 중간 결과를 밖에 안 만들게 하는 것이다.\n원래 라면"}],"\n"]}]
35:["$","ol",null,{"children":["\n",["$","li",null,{"children":"matmul 결과를 큰 tensor에 쓰고"}],"\n",["$","li",null,{"children":"그 tensor를 다시 읽어서 add 하고"}],"\n",["$","li",null,{"children":"또 다시 읽어서 max(ReLU) 를 했을거임.\n이 경우 메모리 왕복이 많아짐."}],"\n"]}]
36:["$","p",null,{"children":"fuse를 하게 되면"}]
37:["$","ul",null,{"children":["\n",["$","li",null,{"children":"ReLU 를 타일링 해서 루프를 만들고"}],"\n",["$","li",null,{"children":"그 루프 안에서 필요한 add, matmul 도 같이 계산하게 끌어들임.\n아래와 같은 방식으로"}],"\n"]}]
38:["$","pre",null,{"children":["$","code",null,{"children":"for tile ... {\n  tile_matmul()\n  tile_add()\n  tile_relu()\n}\n\n즉,\n\nfor each tile:\n  A_tile, B_tile 읽음\n  matmul(tile) → 레지스터/캐시\n  add(tile)    → 바로 이어서\n  relu(tile)   → 바로 이어서\n  결과 tile만 메모리에 씀\n"}]}]
39:["$","p",null,{"children":"이렇게 했을때"}]
3a:["$","ul",null,{"children":["\n",["$","li",null,{"children":"중간 텐서를 크게 저장/로드 하지 않고"}],"\n",["$","li",null,{"children":"타일 단위로 바로 다음 연산을 이어서 처리하여 캐시 / 대역폭에서 이득을 볼 수 있다. (하나의 tile 범위에 대해서)"}],"\n"]}]
3b:["$","ol",null,{"start":"10","children":["\n",["$","li",null,{"children":"더 작은 타일 + 아웃라이닝"}],"\n"]}]
3c:["$","ul",null,{"children":["\n",["$","li",null,{"children":"4x4 matmul 마이크로 커널이 있다면?\n(1) 다시 타일링을 하고\n(2) 루프를 함수로 outline 한다음\n(3) 나중에 마이크로 커널 호출로 교체를 한다."}],"\n"]}]
3d:["$","ul",null,{"children":["\n",["$","li",null,{"children":"주의할 부분이라면"}],"\n"]}]
3e:["$","ul",null,{"children":["\n",["$","li",null,{"children":"outline도 핸들을 소모하고"}],"\n",["$","li",null,{"children":"그 안에 있던 연산 핸들이 전부 무효화 된다."}],"\n"]}]
3f:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Kernel은 DL / 선형대수의 Kernel 개념이 맞음.\nMicrokernel 은"}],"\n"]}]
40:["$","ul",null,{"children":["\n",["$","li",null,{"children":"아주 작은 고정 크기 블록 (ex: 4x4 matmul) 을"}],"\n",["$","li",null,{"children":["어셈블리 / 벤더 intrinsics / 특수 명령어로 최적화해 둔 함수이다.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"BLAS 내부, oneDNN, XNNPACK류가 이런 스타일을 많이 씀"}],"\n"]}],"\n"]}],"\n"]}]
41:["$","ul",null,{"children":["\n",["$","li",null,{"children":"replace 흐름의 경우"}],"\n"]}]
42:["$","ol",null,{"children":["\n",["$","li",null,{"children":"큰 matmul을 타일링 해서 4x4 단위로 쪼개고"}],"\n",["$","li",null,{"children":"그 4x4 계산을 별도 함수로 outline(= 루프 바디를 함수로 떼어내고)"}],"\n",["$","li",null,{"children":["그 함수 호출(func.call) 을","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"microkernel_4x4(...) 같은 특수 호출로 바꾸고 싶다\n즉 outline 된 함수 호출을 마이크로커널 호출로 바꾸는 것임."}],"\n"]}],"\n"]}],"\n"]}]
43:["$","ul",null,{"children":["\n",["$","li",null,{"children":"왜 굳이 outline을 하는가? (outline : 코드 조각을 바깥으로빼서(out) 별도의 함수를 만들어(line을 긋는다.))"}],"\n"]}]
44:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Transform dialect 에서 \"임의의 호출을 내 마음대로 다른 호출로 바꾸기\"는 기본 제공이 제한적임."}],"\n",["$","li",null,{"children":"일단 호출 형태로 만들어 놓으면 (=call)"}],"\n",["$","li",null,{"children":"그 다음단계 (커스텀 transform op 또는 다른패스) 에서 교체하기가 쉬워짐."}],"\n"]}]
45:["$","p",null,{"children":"최종적으로"}]
46:["$","ul",null,{"children":["\n",["$","li",null,{"children":["호출로 교체한다는 것은 타일된 작은 계산 ",["$","code",null,{"children":"->"}]," 특수 최적화 함수 호출로 바꾸어서 성능을 극대화 한다는 것이다."]}],"\n"]}]
47:["$","ol",null,{"start":"11","children":["\n",["$","li",null,{"children":"Transform dialect 의 자동 추적\nTransform은 IR 변경을 자동 추적함."}],"\n"]}]
48:["$","ul",null,{"children":["\n",["$","li",null,{"children":["연산 삭제 ",["$","code",null,{"children":"->"}]," 핸들에서 자동 제거"]}],"\n",["$","li",null,{"children":["연산 교체 ",["$","code",null,{"children":"->"}]," 가능한 경우 핸들 자동 갱신"]}],"\n",["$","li",null,{"children":["애매하면 ",["$","code",null,{"children":"->"}]," 에러로 막아준다.\n이를 통해 몰래 잘못 바꾸는 일을 방지한다."]}],"\n"]}]
49:["$","p",null,{"children":"====================================================================="}]
4a:["$","p",null,{"children":"요약해 보자면 Transform Dialect는 IR을 바꾸는 과정을 IR로 작성하는 안전한 자동 리팩토링 언어라 할 수 있음."}]
4b:["$","p",null,{"children":"Rewrite는 로컬 규칙 (치환) 자체였다면, Transform은 그 규칙/패스를 어떤 순서, 범위, 전략으로 적용할지 (오케스트레이션)"}]
4c:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
4d:["$","$L4e",null,{}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
4f:I[27201,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"IconMark"]
c:[["$","title","0",{"children":"MLIR Transform Tutorial Ch 1 에 대하여 - CPIST's blog"}],["$","meta","1",{"name":"description","content":"Combining Existing Transformations"}],["$","link","2",{"rel":"icon","href":"/blog/favicon.ico?favicon.0b3bf435.ico","sizes":"256x256","type":"image/x-icon"}],["$","$L4f","3",{}]]
8:null
