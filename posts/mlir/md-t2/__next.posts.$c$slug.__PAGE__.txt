1:"$Sreact.fragment"
15:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
16:"$Sreact.suspense"
0:{"buildId":"6mGwdNF_4erqUyA2uHGSg","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Transform Tutorial Ch 2 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-11-23"}],["$","p",null,{"style":{"color":"#333"},"children":"Adding a Simple New Transformation Operation"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"확장(extension) 이 필요한 이유\nMLIR의 Trnasform dialect는 IR을 직접 바꾸는 메타 IR 이다.\n그런데"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"모든 변환을 upstream Transform dialect에 넣을수는 없고"}],"\n",["$","li",null,{"children":"out-of-tree dialect 전용 변환도 많다."}],"\n",["$","li",null,{"children":"실험적이거나 프로젝트 한정 변환도 있음."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"그래서 Transform dialect 는 \"확장(extension)\" 이라는 플러그인 구조를 제공함\n일종의 게임으로 치면 모드 같은 것임. 본체 코드는 안고치고, 새로운 기술을 추가하는 방법"}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"Transform Dialect Extension 은?\nExtension은 다음과 같은 특징을 가짐."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":[["$","code",null,{"children":"TransformDialectExtension<T>"}]," 를 상속함"]}],"\n",["$","li",null,{"children":"dialect가 로드 될 때 자동으로 함께 로드가 된다."}],"\n",["$","li",null,{"children":"새로운 transform operation 들을 등록할 수 있음."}],"\n",["$","li",null,{"children":"필요한 dialect 들을 의존(dependent) 또는 생성(generated) 으로 선언"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Dependent dialect - transform op 정의에 직접 쓰는 타입 / 어트리뷰트"}],"\n",["$","li",null,{"children":"Generated dialect - 변환 실행 결과로 생길 수 있는 op들의 dialect"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"예제에서는 scf, func dialect를 generated dialect 로 선언\n(변환 결과로 loop나 func.call이 생기기 때문)"}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"Extension 골격 코드"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"class MyExtension\n  : public transform::TransformDialectExtension<MyExtension> {\npublic:\n  using Base::Base;\n  void init();\n};\n"}]}],"\n",["$","p",null,{"children":"init() 에서 하는 3가지"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"(선택) dependent dialect 선언"}],"\n",["$","li",null,{"children":"generated dialect 선언"}],"\n",["$","li",null,{"children":"transform op 등록"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"void MyExtension::init() {\n  declareGeneratedDialect<scf::SCFDialect>();\n  declareGeneratedDialect<func::FuncDialect>();\n\n  registerTransformOps<\n    // ODS로 정의한 op들\n  >();\n}\n"}]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"Transform Operation 도 결국은 \"Op\" (ODS 사용)\nTransform op 정의는 일반 dialect op와 완전히 동일하게 ODS(TableGen) 로 함."}],"\n"]}],"\n",["$","p",null,{"children":"Transform op의 필수 인터페이스"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"TransformOpInterface : 실제 변환을 수행 (apply)"}],"\n",["$","li",null,{"children":"MemoryEffectsOpInterface : 핸들과 payload IR 에 대한 side-effect 설명"}],"\n"]}],"\n",["$","p",null,{"children":"이게 없으면 Transform interpreter가 assert로 죽음"}],"\n",["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"예제 케이스 my.change_call_target\n이 op는 \"Transform handle\"이 가리키는 func.call 들의 callee를 문자열로 지정한 심볼 이름으로 바뀜"}],"\n"]}],"\n",["$","p",null,{"children":"ODS 정의의 핵심"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def ChangeCallTargetOp :\n  Op<Transform_Dialect, \"my.change_call_target\",\n     [DeclareOpInterfaceMethods<TransformOpInterface>,\n      DeclareOpInterfaceMethods<MemoryEffectsOpInterface>]> {\n"}]}],"\n",["$","p",null,{"children":"입력은"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"%call: transform handle"}],"\n",["$","li",null,{"children":"\"new_target\" : 새 callee 이름 (string)"}],"\n"]}],"\n",["$","p",null,{"children":"출력은"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"없음 (payload를 in-place로 수정)"}],"\n"]}],"\n",["$","p",null,{"children":"실패 정책은"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"handle이 func.call 이 아니면 -> silenceable failure"}],"\n"]}],"\n",["$","ol",null,{"start":"6","children":["\n","$L2","\n"]}],"\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13"]}]]}],null,"$L14"]}],"loading":null,"isPartial":false}
2:["$","li",null,{"children":"apply() 는 변환의 핵심\napply()는 Transform dialect의 규칙을 철저히 따름"}]
3:["$","p",null,{"children":"apply의 입력"}]
4:["$","ul",null,{"children":["\n",["$","li",null,{"children":"TransformRewriter &rewriter : IR 수정은 반드시 이걸로만"}],"\n",["$","li",null,{"children":"TransformResults &results : 새 payload handle 결과 연결"}],"\n",["$","li",null,{"children":["TransformState &state : transform handle ",["$","code",null,{"children":"<->"}]," payload IR 매핑 조회"]}],"\n"]}]
5:["$","p",null,{"children":["즉 apply 흐름을 요약하자면\n",["$","code",null,{"children":"handle -> payload ops 조회 -> 타입체크 -> 실제 IR 수정"}]]}]
6:["$","pre",null,{"children":["$","code",null,{"children":"auto payload = state.getPayloadOps(getCall());\n\nfor (Operation *op : payload) {\n  auto call = dyn_cast<func::CallOp>(op);\n  if (!call)\n    return emitSilenceableError();\n\n  updateCallee(call, getNewTarget());\n}\n"}]}]
7:["$","p",null,{"children":"핵심 개념은"}]
8:["$","ul",null,{"children":["\n",["$","li",null,{"children":"payload IR : 실제로 바뀌는 대상 IR"}],"\n",["$","li",null,{"children":"transform IR : 어떻게 바꿀지를 적은 메타 IR"}],"\n",["$","li",null,{"children":"silenceable failure : 실패했지만 다음 변환은 계속 가능"}],"\n"]}]
9:["$","ol",null,{"start":"7","children":["\n",["$","li",null,{"children":"MemoryEffectsOpInterface\nTransform dialect는 side-effect 를 명시하지 않으면 안됨"}],"\n"]}]
a:["$","pre",null,{"children":["$","code",null,{"children":"void ChangeCallTargetOp::getEffects(...) {\n  onlyReadsHandle(getCall(), effects);\n  modifiesPayload(effects);\n}\n"}]}]
b:["$","ul",null,{"children":["\n",["$","li",null,{"children":"handle은 읽기만 함 (op를 삭제하지 않고 in-place 수정)"}],"\n",["$","li",null,{"children":"payload IR은 변경됨\n이 정보로 Transform interpreter는"}],"\n",["$","li",null,{"children":"handle 유효성과 transform 순서 안정성을 판단함."}],"\n"]}]
c:["$","ol",null,{"start":"8","children":["\n",["$","li",null,{"children":"등록의 과정"}],"\n"]}]
d:["$","pre",null,{"children":["$","code",null,{"children":"void registerMyExtension(DialectRegistry &registry) {\n  registry.addExtensions<MyExtension>();\n}\n"}]}]
e:["$","p",null,{"children":"이걸 main() 에서 호출하면 transform.my.change_call_target 사용이 가능함"}]
f:["$","ol",null,{"start":"9","children":["\n",["$","li",null,{"children":"실제 Transform IR에서 쓰는 방법"}],"\n"]}]
10:["$","pre",null,{"children":["$","code",null,{"children":"transform.my.change_call_target %call, \"microkernel\"\n  : !transform.any_op\n"}]}]
11:["$","ul",null,{"children":["\n",["$","li",null,{"children":"여기서 %call은 이전 transform op (outline) 가 만들어 준 실제 func.call을 가리키는 handle임."}],"\n",["$","li",null,{"children":"즉 Transform dialect 는 정확히 특정 call 하나를 찍어서 바꿀 수가 있음."}],"\n"]}]
12:["$","p",null,{"children":"====================================================================="}]
13:["$","p",null,{"children":"요약해 보자면 Transform을 확장해서 실제 IR을 안전하고, 추적가능하고, 실패까지 관리하면서 바꾸는 정식 커스텀 변환을 만드는 전 과정을 다루어 보았다."}]
14:["$","$L15",null,{"children":["$","$16",null,{"name":"Next.MetadataOutlet","children":"$@17"}]}]
17:null
