<!DOCTYPE html><!--59E72vmx5TUYaq5Cm6Dgp--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><title>MLIR Transform Tutorial Ch 2 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Adding a Simple New Transformation Operation"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Transform Tutorial Ch 2 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-11-23</div><p style="color:#333">Adding a Simple New Transformation Operation</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>1) 확장(extension) 이 필요한 이유
MLIR의 Trnasform dialect는 IR을 직접 바꾸는 메타 IR 이다.
그런데</p>
<ul>
<li>모든 변환을 upstream Transform dialect에 넣을수는 없고</li>
<li>out-of-tree dialect 전용 변환도 많다.</li>
<li>실험적이거나 프로젝트 한정 변환도 있음.</li>
</ul>
<ul>
<li>그래서 Transform dialect 는 &quot;확장(extension)&quot; 이라는 플러그인 구조를 제공함
일종의 게임으로 치면 모드 같은 것임. 본체 코드는 안고치고, 새로운 기술을 추가하는 방법</li>
</ul>
<p>2) Transform Dialect Extension 은?
Extension은 다음과 같은 특징을 가짐.</p>
<ul>
<li><code>TransformDialectExtension&lt;T&gt;</code> 를 상속함</li>
<li>dialect가 로드 될 때 자동으로 함께 로드가 된다.</li>
<li>새로운 transform operation 들을 등록할 수 있음.</li>
<li>필요한 dialect 들을 의존(dependent) 또는 생성(generated) 으로 선언</li>
</ul>
<ul>
<li>Dependent dialect - transform op 정의에 직접 쓰는 타입 / 어트리뷰트</li>
<li>Generated dialect - 변환 실행 결과로 생길 수 있는 op들의 dialect</li>
</ul>
<ul>
<li>예제에서는 scf, func dialect를 generated dialect 로 선언
(변환 결과로 loop나 func.call이 생기기 때문)</li>
</ul>
<p>3) Extension 골격 코드</p>
<pre><code>class MyExtension
  : public transform::TransformDialectExtension&lt;MyExtension&gt; {
public:
  using Base::Base;
  void init();
};
</code></pre>
<p>init() 에서 하는 3가지</p>
<ul>
<li>(선택) dependent dialect 선언</li>
<li>generated dialect 선언</li>
<li>transform op 등록</li>
</ul>
<pre><code>void MyExtension::init() {
  declareGeneratedDialect&lt;scf::SCFDialect&gt;();
  declareGeneratedDialect&lt;func::FuncDialect&gt;();

  registerTransformOps&lt;
    // ODS로 정의한 op들
  &gt;();
}
</code></pre>
<p>4) Transform Operation 도 결국은 &quot;Op&quot; (ODS 사용)
Transform op 정의는 일반 dialect op와 완전히 동일하게 ODS(TableGen) 로 함.</p>
<p>Transform op의 필수 인터페이스</p>
<ul>
<li>TransformOpInterface : 실제 변환을 수행 (apply)</li>
<li>MemoryEffectsOpInterface : 핸들과 payload IR 에 대한 side-effect 설명</li>
</ul>
<p>이게 없으면 Transform interpreter가 assert로 죽음</p>
<p>5) 예제 케이스 my.change_call_target
이 op는 &quot;Transform handle&quot;이 가리키는 func.call 들의 callee를 문자열로 지정한 심볼 이름으로 바뀜</p>
<p>ODS 정의의 핵심</p>
<pre><code>def ChangeCallTargetOp :
  Op&lt;Transform_Dialect, &quot;my.change_call_target&quot;,
     [DeclareOpInterfaceMethods&lt;TransformOpInterface&gt;,
      DeclareOpInterfaceMethods&lt;MemoryEffectsOpInterface&gt;]&gt; {
</code></pre>
<p>입력은</p>
<ul>
<li>%call: transform handle</li>
<li>&quot;new_target&quot; : 새 callee 이름 (string)</li>
</ul>
<p>출력은</p>
<ul>
<li>없음 (payload를 in-place로 수정)</li>
</ul>
<p>실패 정책은</p>
<ul>
<li>handle이 func.call 이 아니면 -&gt; silenceable failure</li>
</ul>
<p>6) apply() 는 변환의 핵심
apply()는 Transform dialect의 규칙을 철저히 따름</p>
<p>apply의 입력</p>
<ul>
<li>TransformRewriter &amp;rewriter : IR 수정은 반드시 이걸로만</li>
<li>TransformResults &amp;results : 새 payload handle 결과 연결</li>
<li>TransformState &amp;state : transform handle <code>&lt;-&gt;</code> payload IR 매핑 조회</li>
</ul>
<p>즉 apply 흐름을 요약하자면
<code>handle -&gt; payload ops 조회 -&gt; 타입체크 -&gt; 실제 IR 수정</code></p>
<pre><code>auto payload = state.getPayloadOps(getCall());

for (Operation *op : payload) {
  auto call = dyn_cast&lt;func::CallOp&gt;(op);
  if (!call)
    return emitSilenceableError();

  updateCallee(call, getNewTarget());
}
</code></pre>
<p>핵심 개념은</p>
<ul>
<li>payload IR : 실제로 바뀌는 대상 IR</li>
<li>transform IR : 어떻게 바꿀지를 적은 메타 IR</li>
<li>silenceable failure : 실패했지만 다음 변환은 계속 가능</li>
</ul>
<p>7) MemoryEffectsOpInterface
Transform dialect는 side-effect 를 명시하지 않으면 안됨</p>
<pre><code>void ChangeCallTargetOp::getEffects(...) {
  onlyReadsHandle(getCall(), effects);
  modifiesPayload(effects);
}
</code></pre>
<ul>
<li>handle은 읽기만 함 (op를 삭제하지 않고 in-place 수정)</li>
<li>payload IR은 변경됨
이 정보로 Transform interpreter는</li>
<li>handle 유효성과 transform 순서 안정성을 판단함.</li>
</ul>
<p>8) 등록의 과정</p>
<pre><code>void registerMyExtension(DialectRegistry &amp;registry) {
  registry.addExtensions&lt;MyExtension&gt;();
}
</code></pre>
<p>이걸 main() 에서 호출하면 transform.my.change_call_target 사용이 가능함</p>
<p>9) 실제 Transform IR에서 쓰는 방법</p>
<pre><code>transform.my.change_call_target %call, &quot;microkernel&quot;
  : !transform.any_op
</code></pre>
<ul>
<li>여기서 %call은 이전 transform op (outline) 가 만들어 준 실제 func.call을 가리키는 handle임.</li>
<li>즉 Transform dialect 는 정확히 특정 call 하나를 찍어서 바꿀 수가 있음.</li>
</ul>
<p>=====================================================================</p>
<p>요약해 보자면 Transform을 확장해서 실제 IR을 안전하고, 추적가능하고, 실패까지 관리하면서 바꾸는 정식 커스텀 변환을 만드는 전 과정을 다루어 보았다.</p></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"59E72vmx5TUYaq5Cm6Dgp\",\"c\":[\"\",\"posts\",\"mlir\",\"md-t2\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-t2\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Transform Tutorial Ch 2 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-11-23\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Adding a Simple New Transformation Operation\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"1) 확장(extension) 이 필요한 이유\\nMLIR의 Trnasform dialect는 IR을 직접 바꾸는 메타 IR 이다.\\n그런데\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"모든 변환을 upstream Transform dialect에 넣을수는 없고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"out-of-tree dialect 전용 변환도 많다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"실험적이거나 프로젝트 한정 변환도 있음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"그래서 Transform dialect 는 \\\"확장(extension)\\\" 이라는 플러그인 구조를 제공함\\n일종의 게임으로 치면 모드 같은 것임. 본체 코드는 안고치고, 새로운 기술을 추가하는 방법\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) Transform Dialect Extension 은?\\nExtension은 다음과 같은 특징을 가짐.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"TransformDialectExtension\u003cT\u003e\"}],\" 를 상속함\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"dialect가 로드 될 때 자동으로 함께 로드가 된다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"새로운 transform operation 들을 등록할 수 있음.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"필요한 dialect 들을 의존(dependent) 또는 생성(generated) 으로 선언\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Dependent dialect - transform op 정의에 직접 쓰는 타입 / 어트리뷰트\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Generated dialect - 변환 실행 결과로 생길 수 있는 op들의 dialect\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"예제에서는 scf, func dialect를 generated dialect 로 선언\\n(변환 결과로 loop나 func.call이 생기기 때문)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3) Extension 골격 코드\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"class MyExtension\\n  : public transform::TransformDialectExtension\u003cMyExtension\u003e {\\npublic:\\n  using Base::Base;\\n  void init();\\n};\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"init() 에서 하는 3가지\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"(선택) dependent dialect 선언\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"generated dialect 선언\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform op 등록\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"void MyExtension::init() {\\n  declareGeneratedDialect\u003cscf::SCFDialect\u003e();\\n  declareGeneratedDialect\u003cfunc::FuncDialect\u003e();\\n\\n  registerTransformOps\u003c\\n    // ODS로 정의한 op들\\n  \u003e();\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4) Transform Operation 도 결국은 \\\"Op\\\" (ODS 사용)\\nTransform op 정의는 일반 dialect op와 완전히 동일하게 ODS(TableGen) 로 함.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Transform op의 필수 인터페이스\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"TransformOpInterface : 실제 변환을 수행 (apply)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"MemoryEffectsOpInterface : 핸들과 payload IR 에 대한 side-effect 설명\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이게 없으면 Transform interpreter가 assert로 죽음\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"5) 예제 케이스 my.change_call_target\\n이 op는 \\\"Transform handle\\\"이 가리키는 func.call 들의 callee를 문자열로 지정한 심볼 이름으로 바뀜\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"ODS 정의의 핵심\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"def ChangeCallTargetOp :\\n  Op\u003cTransform_Dialect, \\\"my.change_call_target\\\",\\n     [DeclareOpInterfaceMethods\u003cTransformOpInterface\u003e,\\n      DeclareOpInterfaceMethods\u003cMemoryEffectsOpInterface\u003e]\u003e {\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"입력은\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"%call: transform handle\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"\\\"new_target\\\" : 새 callee 이름 (string)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"출력은\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"없음 (payload를 in-place로 수정)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"실패 정책은\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"handle이 func.call 이 아니면 -\u003e silenceable failure\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"6) apply() 는 변환의 핵심\\napply()는 Transform dialect의 규칙을 철저히 따름\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"apply의 입력\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"TransformRewriter \u0026rewriter : IR 수정은 반드시 이걸로만\"}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\"]}],\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\"]}],\"$L1f\",\"$L20\"]}]\n"])</script><script>self.__next_f.push([1,"21:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"li\",null,{\"children\":\"TransformResults \u0026results : 새 payload handle 결과 연결\"}]\nf:[\"$\",\"li\",null,{\"children\":[\"TransformState \u0026state : transform handle \",[\"$\",\"code\",null,{\"children\":\"\u003c-\u003e\"}],\" payload IR 매핑 조회\"]}]\n10:[\"$\",\"p\",null,{\"children\":[\"즉 apply 흐름을 요약하자면\\n\",[\"$\",\"code\",null,{\"children\":\"handle -\u003e payload ops 조회 -\u003e 타입체크 -\u003e 실제 IR 수정\"}]]}]\n11:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"auto payload = state.getPayloadOps(getCall());\\n\\nfor (Operation *op : payload) {\\n  auto call = dyn_cast\u003cfunc::CallOp\u003e(op);\\n  if (!call)\\n    return emitSilenceableError();\\n\\n  updateCallee(call, getNewTarget());\\n}\\n\"}]}]\n12:[\"$\",\"p\",null,{\"children\":\"핵심 개념은\"}]\n13:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload IR : 실제로 바뀌는 대상 IR\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform IR : 어떻게 바꿀지를 적은 메타 IR\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"silenceable failure : 실패했지만 다음 변환은 계속 가능\"}],\"\\n\"]}]\n14:[\"$\",\"p\",null,{\"children\":\"7) MemoryEffectsOpInterface\\nTransform dialect는 side-effect 를 명시하지 않으면 안됨\"}]\n15:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"void ChangeCallTargetOp::getEffects(...) {\\n  onlyReadsHandle(getCall(), effects);\\n  modifiesPayload(effects);\\n}\\n\"}]}]\n16:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"handle은 읽기만 함 (op를 삭제하지 않고 in-place 수정)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload IR은 변경됨\\n이 정보로 Transform interpreter는\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"handle 유효성과 transform 순서 안정성을 판단함.\"}],\"\\n\"]}]\n17:[\"$\",\"p\",null,{\"children\":\"8) 등록의 과정\"}]\n18:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"void registerMyExtension(DialectRegistry \u0026registry) {\\n  registry.addExtensions\u003cMyExtension\u003e();\\n}\\n\"}]}]\n19:[\"$\",\"p\",null,{\"children\":\"이걸 main() 에서 호출하면 transform.my.change_call_target 사용이 가능함\"}]\n1a:[\"$\",\"p\",null,{\"children\":\"9) 실제 Transform IR에서 쓰는 방법\"}]\n1b:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"transform.my.change_call_target %call, \\\"microkernel\\\"\\n  : !transform.any_op\\n\"}]}]\n1c:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"여기서 %call은 이전 transform op (outline) 가 만들어 준 실제 func.call을 가리키는 handle임.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"즉 Transform dialect 는 정확히 특정 call 하나를 찍어서 바꿀 수가 있음.\"}],\"\\n\"]}]\n1d:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n1e:[\"$\",\"p\",null,{\"children\":\"요약해 보자면 Transform을 확장해서 실제 IR을 안전하고, 추적가능하고, 실패까지 관리하면서 바꾸는 정식 커스텀 변환을 만드는 전 과정을 다루어 보았다.\"}]\n1f:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n20:[\"$\",\"$L21\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"22:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Transform Tutorial Ch 2 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Adding a Simple New Transformation Operation\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L22\",\"3\",{}]]\n8:null\n"])</script></body></html>