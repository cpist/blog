1:"$Sreact.fragment"
10:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
11:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
12:"$Sreact.suspense"
0:{"buildId":"gqtK1mSFNLAAOLgVp1zP3","rsc":["$","$1","c",{"children":[["$","article",null,{"style":{"maxWidth":"800px","margin":"0 auto","padding":"20px"},"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Tutorial DataFlow Analysis 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-12-13"}],["$","p",null,{"style":{"color":"#333","fontStyle":"italic"},"children":"Writing DataFlow Analyses in MLIR"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","style":{"lineHeight":1.6},"children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"Dataflow analysis 란?"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Dataflow analysis는 IR(중간 표현) 전반에 걸쳐 정보를 전달하는 분석 기법"}],"\n",["$","li",null,{"children":"MLIR에는 다양한 제어 흐름 구조 (Block, Region, CallGraph 등)가 있어 직접 구현하면 복잡해 질 수 있음."}],"\n",["$","li",null,{"children":"이를 단순화 하기 위해 MLIR은 ForwardDataFlowAnalysis 와 Lattice 유틸리티를 제공함."}],"\n"]}],"\n",["$","p",null,{"children":"프레임워크 (라이브러리 코드) 가 구현되어 있고, 이걸 상속해서 쓰는 구조임.\nC++ 라이브러리 코드라는거"}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"Forward Dataflow Analysis"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Forward 분석은 정의 -> 사용 방향으로 정보를 전파함."}],"\n",["$","li",null,{"children":"예제에서는 각 값에 붙은 metadata 라는 DictionaryAttr을 수집하고 전파하는 분석을 구현함."}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"Lattice (격자)\n데이터플로우 분석의 핵심 추상화"}],"\n"]}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Lattice의 역할은"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"분석 결과가 가질 수 있는 모든 가능한 상태를 표현"}],"\n",["$","li",null,{"children":"각 IR 값(Value)에 대해 하나의 LatticeElement 가 존재함."}],"\n",["$","li",null,{"children":"분석 중 전파되는 정보의 컨테이너 역할."}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"특수 상태"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["모든 lattice는 다음 두 상태를 반드시 가짐\n하나는 uninitialized","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"아직 분석 정보가 없음"}],"\n",["$","li",null,{"children":"join 시 \"다른 값 그대로 사용\"\n다른 하나는 top / overdefined / unknown"}],"\n",["$","li",null,{"children":"가능한 모든 값 포함 (아무 가정도 할 수 없는 상태)"}],"\n",["$","li",null,{"children":"join 시 결과는 항상 top"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"// Lattice 값 정의\nstruct MyLatticeValue {\n  static MyLatticeValue getPessimisticValueState(...);\n  static MyLatticeValue join(const MyLatticeValue &, const MyLatticeValue &);\n};\n\n// transfer function 정의\nclass MyAnalysis\n  : public ForwardDataFlowAnalysis<MyLatticeValue> {\n  ChangeResult visitOperation(\n    Operation *op,\n    ArrayRef<LatticeElement<MyLatticeValue> *> operands) override {\n    ...\n  }\n};\n"}]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"MetadataLatticeValue"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"lattice element가 실제로 담는 값 타입"}],"\n",["$","li",null,{"children":"예제에서는 DictionaryAttr의 내용을 DenseMap으로 보관함."}],"\n"]}],"\n",["$","p",null,{"children":"핵심 Method"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["getPessimisticValueState","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"IR 정보가 없을 때의 보수적인 초기 상태 (top)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["join(lhs, rhs)","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"두 lattice 값을 병합"}],"\n",["$","li",null,{"children":"단조성(monotonicity) 보장 필수"}],"\n",["$","li",null,{"children":"예제 정책 : 양쪽에 공통으로 존재하고 값이 같은 metadata만 유지"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["operator==","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"lattice 값 비교"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"LatticeElement"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"특정 IR Value 에 대한 lattice 상태를 관리하는 Wrapper"}],"\n",["$","li",null,{"children":"uninitalized 상태를 내부적으로 처리함."}],"\n"]}],"\n",["$","p",null,{"children":"주요 API"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"getValue() : 초기화된 값 접근"}],"\n",["$","li",null,{"children":"join(LatticeElement / ValueT) : 정보 병합, 변경 여부 반환"}],"\n",["$","li",null,{"children":"markPessimisticFixPoint() : 더 이상 정밀한 분석이 불가능하다고 표시"}],"\n"]}],"\n",["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"ForwardDataFlowAnalysis Driver\n분석 전체를 실행 관리하는 드라이버 클래스"}],"\n"]}],"\n","$L2","\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb"]}],"$Lc","$Ld"]}],["$Le"],"$Lf"]}],"loading":null,"isPartial":false}
2:["$","p",null,{"children":"핵심 기능"}]
3:["$","ul",null,{"children":["\n",["$","li",null,{"children":["run(Operation *topLevelOp)","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"top-level op 아래에서 분석 실행"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["getLatticeElement(Value)","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"lattice가 없으면 새로 생성(uninitialized)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["lookupLatticeElement(Value)","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"존재할 때만 반환 (분석 결과 조회 시 사용)"}],"\n"]}],"\n"]}],"\n"]}]
4:["$","ol",null,{"start":"7","children":["\n",["$","li",null,{"children":"visitOperation (Transfer Function)"}],"\n"]}]
5:["$","ul",null,{"children":["\n",["$","li",null,{"children":"분석의 핵심 로직"}],"\n",["$","li",null,{"children":["각 operation 에 대해","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"operand lattice 정보를 기반으로 result / block argument의 lattice를 갱신"}],"\n"]}],"\n"]}],"\n"]}]
6:["$","p",null,{"children":"예제 로직을 정리해 보자면"}]
7:["$","ol",null,{"children":["\n",["$","li",null,{"children":"op에 metadata가 없으면 결과 값들을 pessimistic fixpoint(top) 으로 설정함"}],"\n",["$","li",null,{"children":"metatdata가 있으면 이를 lattice 값으로 만들어 결과 값들의 lattice에 join 함"}],"\n"]}]
8:["$","ol",null,{"start":"8","children":["\n",["$","li",null,{"children":"분석 결과 사용 시 주의점"}],"\n"]}]
9:["$","ul",null,{"children":["\n",["$","li",null,{"children":["결과 조회 시에는 lookupLatticeElement 를 사용함","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"getLatticeElement는 새 element를 만들어 버릴 수 있음"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["lattice가 없다면","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"해당 value는 분석 중 방문되지 않았음"}],"\n",["$","li",null,{"children":"ex) unreachable block"}],"\n",["$","li",null,{"children":"이런건 반드시 보수적으로 처리해야 한다는거"}],"\n"]}],"\n"]}],"\n"]}]
a:["$","p",null,{"children":"====================================================================="}]
b:["$","p",null,{"children":"요약해 보자면\nMLIR의 Forward Dataflow Analysis는 Lattice + ForwardDataFlowAnalysis + visitOperation(transfer function) 구조로 이루어지며,\n단조적인 join 규칙과 pessimistic(top) 상태를 통해 안전하고 확장 가능한 분석을 가능하게 한다는 것이다."}]
c:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
d:["$","$L10",null,{}]
e:["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true}]
f:["$","$L11",null,{"children":["$","$12",null,{"name":"Next.MetadataOutlet","children":"$@13"}]}]
13:null
