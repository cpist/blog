1:"$Sreact.fragment"
9:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
a:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
b:"$Sreact.suspense"
0:{"buildId":"MQvFKTPoiW61Lu7ysV5zz","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR ArithPatterns"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2026-01-02"}],["$","p",null,{"style":{"color":"#333"},"children":"MLIR IR - ArithPatterns"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"MLIR의 Arith Dialect에서 산술 연산을 최적화하고 단순화하기 위한 DRR(Declarative Rewrite Patterns) 정의서\n단순한 계산 식이 아니라 정적 분석 및 정규화(Canonicalization) 과정에서 그래프를 어떻게 변형하는지에 초점을 맞춰야 한다."}],"\n",["$","p",null,{"children":"1) 핵심 설계 구조\n패턴 정의에 앞서 효율적인 변환을 위한 유틸리티들이 선언되어 있음"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["NativeCodeCall : TableGen만으로 처리하기 복잡한 C++ 로직(속성 값 계산, 오버플로우 플래그 병합 등)을 호출","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"ex) AddIntAttrs, MergeOverflow, invertPredicate"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["Constraints : 패턴 매칭 조건(Predicate)을 정의","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"ex) IsScalarOrSplatNegativeOne (값이 -1인지 확인), ValueWiderThan (비트 폭 비교)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"Overflow Handline: none을 기본값으로 하며, 연산 병합 시 상호 간의 오버플로우 플래그를 보수적으로 유지하도록 설계"}],"\n"]}],"\n",["$","p",null,{"children":"2) 주요 최적화 패턴"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"상수 폴딩 및 재결합 (Constant Folding & Reassociation)\n연속된 상수 연산을 하나의 연산으로 합쳐 연산 횟수를 줄임.\naddi는 가환성(Commutative)을 가지므로 상수가 항상 두 번째 피연산자로 오도록 정규화됨을 전제로 함."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["Add / Sub / Mul 합치기","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"addi(addi(x, c0), c1) $\\rightarrow$ addi(x, c0 + c1)"}],"\n",["$","li",null,{"children":"subi(subi(x, c0), c1) $\\rightarrow$ subi(x, c0 + c1)"}],"\n",["$","li",null,{"children":"muli(muli(x, c0), c1) $\\rightarrow$ muli(x, c0 * c1)"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"연산 단순화 (Strength Reduction)\n더 복잡하거나 비용이 큰 연산을 단순한 연산으로 대체"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"곱셈을 뺄셈으로: addi(x, muli(y, -1)) $\\rightarrow$ subi(x, y)"}],"\n",["$","li",null,{"children":"부호 반전 활용: subi(subi(a, b), a) $\\rightarrow$ subi(0, b)"}],"\n",["$","li",null,{"children":"확장 연산 제거: addui_extended나 mulsi_extended에서 상위 비트(Overflow/High) 결과가 사용되지 않으면 일반 addi/muli로 대체"}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"캐스트 및 비트 조작 (Cast & Bit Manipulation)\n형변환 연산이 중첩될 때 발생하는 중복을 제거"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Idempotency (멱등성): index_cast(index_cast(x)) $\\rightarrow$ x (타입이 같을 경우)"}],"\n",["$","li",null,{"children":["Extension 합치기","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"extsi(extui(x)) $\\rightarrow$ extui(x) (부호 없는 확장이 우선됨)"}],"\n",["$","li",null,{"children":"and/or/xor(extui(x), extui(y)) $\\rightarrow$ extui(and/or/xor(x, y)) (연산 후 확장)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"Truncation 최적화: trunci(extsi(x))에서 잘려 나가는 부분이 부호 확장 비트뿐이라면 extsi(x)로 바로 연결"}],"\n"]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"비교 및 선택문 (Comparison & Select)\n논리 흐름을 정규화하여 제어 흐름 최적화를 도움"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"비교 연산 반전: not(cmpi(pred, a, b)) $\\rightarrow$ cmpi(~pred, a, b)"}],"\n",["$","li",null,{"children":["Select 중복 제거","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"select(pred, select(pred, a, b), c) $\\rightarrow$ select(pred, a, c)"}],"\n",["$","li",null,{"children":"select(pred, false, true) $\\rightarrow$ not(pred) (i1 타입인 경우)"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"부동 소수점 (Floating Point)"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"부호 반전 상쇄: mulf(negf(x), negf(y)) $\\rightarrow$ mulf(x, y)"}],"\n",["$","li",null,{"children":"Rounding Mode 고려: truncf(sitofp(x))에서 기본 라운딩 모드일 경우 연산을 단순함"}],"\n"]}],"\n",["$","p",null,{"children":"3) 컴파일러 엔지니어링 관점의 포인트"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Pattern Priority: TableGen에 정의된 순서대로 매칭을 시도하므로, 더 구체적인 패턴이 일반적인 패턴보다 앞에 위치"}],"\n","$L2","\n","$L3","\n"]}],"\n","$L4"]}],"$L5","$L6"]}],["$L7"],"$L8"]}],"loading":null,"isPartial":false}
2:["$","li",null,{"children":["Type Safety: ",["$","code",null,{"children":"Constraint<CPred<\"$0.getType() == $1.getType()\">>"}],"와 같이 타입 일치 여부를 엄격히 체크하여 잘못된 IR 생성을 방지"]}]
3:["$","li",null,{"children":["TODO Flags: 코드 곳곳에 ",["$","code",null,{"children":"// TODO: overflow flags"}],"가 적혀 있음"]}]
4:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이는 현재 패턴이 오버플로우 플래그(nsw, nuw 등)를 완벽하게 전파하지 못하고 있음을 의미"}],"\n",["$","li",null,{"children":"실제 컴파일러 구현 시 이 부분의 정밀도가 최적화 성능을 좌우"}],"\n"]}]
5:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
6:["$","$L9",null,{}]
7:["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true}]
8:["$","$La",null,{"children":["$","$b",null,{"name":"Next.MetadataOutlet","children":"$@c"}]}]
c:null
