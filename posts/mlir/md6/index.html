<!DOCTYPE html><!--5hTOFQgAyP0gWgEA_2kpB--><html lang="ko"><head><meta charSet="utf-8"/><link rel="preconnect" href="/" crossorigin=""/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/743a8f8bdb738f7f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR Toy Tutorial Ch 6 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Lowering to LLVM and code generation. Here we&#x27;ll target LLVM IR for code generation, and detail more of the lowering framework."/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article style="max-width:800px;margin:0 auto;padding:20px"><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Toy Tutorial Ch 6 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-11-09</div><p style="color:#333;font-style:italic">Lowering to LLVM and code generation. Here we&#x27;ll target LLVM IR for code generation, and detail more of the lowering framework.</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose" style="line-height:1.6"><ol>
<li>이제 Toy 언어 -&gt; MLIR -&gt; LLVM -&gt; 실제 실행되는 코드 (JIT) 로 간다.
진짜 프로그램을 돌리는 것.</li>
</ol>
<p>여기서 LLVM으로 낮춘다는 말을 쓰느데
LLVM은 컴파일러 인프라이고, MLIR이 LLVM이 사용할 수 있는 IR을 만들어 주는 것이다.
즉 LLVM 인프라가 처리할 수 있는 IR 형태로 바꿔주는 것이 MLIR</p>
<pre><code>Toy / TensorFlow / PyTorch / DSL
        ↓
     MLIR (여러 dialect)
        ↓
   MLIR LLVM dialect
        ↓
     LLVM IR (.ll)
        ↓
   LLVM Optimizer + Backend
        ↓
    실행 파일 / JIT 실행
</code></pre>
<p>그리고 LLVM의 구성요소도 짤막하게 정리해 보자면</p>
<ul>
<li>LLVM IR : 저수준 중간 표현</li>
<li>Optimizer : IR 최적화</li>
<li>CodeGen : IR <code>-&gt;</code> 머신 코드</li>
<li>JIT : 즉석 컴파일</li>
<li>Backend : x86, ARM 등 타깃 아키텍쳐에 맞게 LLVM IR 을 머신 코드로 변환</li>
</ul>
<ol start="2">
<li>Step 1 : Toy -&gt; LLVM (Lowering)
이전 장에서 다룬 내용을 통해 toy 연산은 이미 affine / scf / arith 같은 표준 MLIR로 바꿔놓았다.
남은건 toy.print 이다.</li>
</ol>
<p>toy.print 는</p>
<ul>
<li>내부적으로 C의 printf를 부르거나</li>
<li>배열을 이중 for-loop 로 돌면서 하나씩 출력하거나</li>
<li>MLIR의 transitive lowering 덕분에 바로 LLVM을 만들지 않더라도, 중간 단계를 거쳐 자동으로 LLVM 까지 갈수 있다.</li>
</ul>
<ul>
<li>printf 함수는 어디에서 오는가?
필요한 경우 LLVM 모듈 안에서 printf 선언을 자동으로 추가함</li>
</ul>
<pre><code>i32 printf(i8*, ...)
</code></pre>
<ul>
<li>이미 있으면 재사용</li>
<li>없으면 새로 만들어 넣기</li>
<li>필요한 외부함수는 알아서 미리 준비한다.</li>
</ul>
<ol start="3">
<li>Step 2 : Conversion 설정
(1) Conversion target</li>
</ol>
<ul>
<li>목표는 LLVM dialect 만 남기기</li>
<li>ModuleOp + LLVMDialect 만 허용</li>
</ul>
<p>(2) Type Converter</p>
<ul>
<li>memref <code>-&gt;</code> LLVM 포인터 구조체로 변환</li>
<li>Toy 전용 타입이 없어서 기본 LLVMTypeConverter면 충분</li>
</ul>
<p>(3) Conversion Patterns</p>
<ul>
<li>affine -&gt; std</li>
<li>scf -&gt; control flow</li>
<li>arith -&gt; LLVM</li>
<li>func -&gt; LLVM</li>
<li>cf -&gt; LLVM</li>
<li>toy.print 전용 lowering 패턴
즉 모든 연산을 LLVM으로 변환 가능하다는 것.
이 것들은 dialect를 다른 dialect로 바꾸는 변환 패턴임.
dialect 는 연산(op) 와 타입(type) 의 언어 묶음 이었음. (아래 예시와 같이)</li>
</ul>
<pre><code>affine dialect → affine.for, affine.load
scf dialect → scf.for, scf.if
arith dialect → arith.addf, arith.mulf
llvm dialect → llvm.load, llvm.call
</code></pre>
<p>즉 어떤 연산들이 있는지를 정의하는 것.
그리고 이 연산을 다른 연산으로 바꾸는 것이 바로 Conversion pattern (Rewrite Pattern)</p>
<pre><code>affine.for → scf.for
scf.for → cf.br + 블록
arith.addf → llvm.fadd
func.func → llvm.func

MLIR 코드에서는 아래와 같이 Conversion 레시피 묶음을 등록함.
populateAffineToStdConversionPatterns(...)
populateSCFToControlFlowConversionPatterns(...)
populateArithToLLVMConversionPatterns(...)
populateFuncToLLVMConversionPatterns(...)
</code></pre>
<p>대부분의 dialect 에서 자기 자신을 LLVM으로 낮추는 변환 패턴을 함께 제공하지만, dialect != conversion pattern이다.</p>
<p>(4) Full Conversion</p>
<pre><code>applyFullConversion(...)
</code></pre>
<p>LLVM 아닌 연산이 하나라도 남으면 실패
이는 곧 아주 깔끔한 LLVM-only IR 이다.</p>
<p>(5) 예제 결과 : LLVM dialect MLIR</p>
<ul>
<li>malloc, free, printf 호출</li>
<li>포인터 연산</li>
<li>GEP, load, call, br 등</li>
<li>완전한 저수준 코드
컴파일러가 본격적으로 시작하는 느낌이다.</li>
</ul>
<ol start="4">
<li>Step 3 : LLVM IR로 변환
MLIR이 끝났기 때문에 LLVM IR(.ll) 로 변환을 한다.</li>
</ol>
<pre><code>translateModuleToLLVMIR(...)
</code></pre>
<ul>
<li>이 결과를 보면 처음에는 되게 길고 복잡한 IR 처럼 보이지만</li>
<li>최적화를 켜면 반복문도 사라지고, 상수가 계산되고, printf만 쭉 남게 된다.</li>
<li>이는 컴파일러가 계산을 미리 다 해버리기 때문이다.</li>
</ul>
<ol start="5">
<li>Step 4 : JIT로 바로 실행
이는 MLIR의 ExecutionEngine을 사용해서 가능하다.
(1) LLVM 타겟을 초기화하고
(2) 최적화 파이프라인을 설정하고
(3) JIT 컴파일을 진행하고
(4) main() 을 호출한다.</li>
</ol>
<pre><code>engine-&gt;invoke(&quot;main&quot;);
</code></pre>
<p>파일을 바로 저장하는 것이 아닌 바로 메모리에서 실행을 한다.</p>
<pre><code>$ echo &#x27;def main() { print([[1, 2], [3, 4]]); }&#x27; | ./toyc-ch6 -emit=jit

했을때 출력 결과는

1.000000 2.000000
3.000000 4.000000
</code></pre>
<p>Toy 언어가 실제 프로그램 처럼 실행된다.</p>
<p>=====================================================================</p>
<p>이 장의 내용을 요약해 보자면</p>
<ul>
<li>MLIR은 단계적으로 LLVM 까지 낮츨 수 있고</li>
<li>Dialect Conversion + Transitive Lowering = 자동 변환이고</li>
<li>toy.print <code>-&gt;</code> printf</li>
<li>LLVM IR <code>-&gt;</code> 최적화 <code>-&gt;</code> JIT 실행</li>
<li>Toy 를 실행 가능한 언어로 만들었다.</li>
</ul></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/743a8f8bdb738f7f.css\",\"style\"]\n:HC[\"/\",\"\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"5hTOFQgAyP0gWgEA_2kpB\",\"c\":[\"\",\"posts\",\"mlir\",\"md6\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md6\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/743a8f8bdb738f7f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"style\":{\"maxWidth\":\"800px\",\"margin\":\"0 auto\",\"padding\":\"20px\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Toy Tutorial Ch 6 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-11-09\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\",\"fontStyle\":\"italic\"},\"children\":\"Lowering to LLVM and code generation. Here we'll target LLVM IR for code generation, and detail more of the lowering framework.\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"style\":{\"lineHeight\":1.6},\"children\":[[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이제 Toy 언어 -\u003e MLIR -\u003e LLVM -\u003e 실제 실행되는 코드 (JIT) 로 간다.\\n진짜 프로그램을 돌리는 것.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"여기서 LLVM으로 낮춘다는 말을 쓰느데\\nLLVM은 컴파일러 인프라이고, MLIR이 LLVM이 사용할 수 있는 IR을 만들어 주는 것이다.\\n즉 LLVM 인프라가 처리할 수 있는 IR 형태로 바꿔주는 것이 MLIR\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"Toy / TensorFlow / PyTorch / DSL\\n        ↓\\n     MLIR (여러 dialect)\\n        ↓\\n   MLIR LLVM dialect\\n        ↓\\n     LLVM IR (.ll)\\n        ↓\\n   LLVM Optimizer + Backend\\n        ↓\\n    실행 파일 / JIT 실행\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"그리고 LLVM의 구성요소도 짤막하게 정리해 보자면\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM IR : 저수준 중간 표현\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Optimizer : IR 최적화\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"CodeGen : IR \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 머신 코드\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"JIT : 즉석 컴파일\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Backend : x86, ARM 등 타깃 아키텍쳐에 맞게 LLVM IR 을 머신 코드로 변환\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Step 1 : Toy -\u003e LLVM (Lowering)\\n이전 장에서 다룬 내용을 통해 toy 연산은 이미 affine / scf / arith 같은 표준 MLIR로 바꿔놓았다.\\n남은건 toy.print 이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"toy.print 는\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"내부적으로 C의 printf를 부르거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"배열을 이중 for-loop 로 돌면서 하나씩 출력하거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR의 transitive lowering 덕분에 바로 LLVM을 만들지 않더라도, 중간 단계를 거쳐 자동으로 LLVM 까지 갈수 있다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"printf 함수는 어디에서 오는가?\\n필요한 경우 LLVM 모듈 안에서 printf 선언을 자동으로 추가함\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"i32 printf(i8*, ...)\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이미 있으면 재사용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"없으면 새로 만들어 넣기\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"필요한 외부함수는 알아서 미리 준비한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Step 2 : Conversion 설정\\n(1) Conversion target\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"목표는 LLVM dialect 만 남기기\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"ModuleOp + LLVMDialect 만 허용\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"(2) Type Converter\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"memref \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" LLVM 포인터 구조체로 변환\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Toy 전용 타입이 없어서 기본 LLVMTypeConverter면 충분\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"(3) Conversion Patterns\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"affine -\u003e std\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"scf -\u003e control flow\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"arith -\u003e LLVM\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"func -\u003e LLVM\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"cf -\u003e LLVM\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"toy.print 전용 lowering 패턴\\n즉 모든 연산을 LLVM으로 변환 가능하다는 것.\\n이 것들은 dialect를 다른 dialect로 바꾸는 변환 패턴임.\\ndialect 는 연산(op) 와 타입(type) 의 언어 묶음 이었음. (아래 예시와 같이)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"affine dialect → affine.for, affine.load\\nscf dialect → scf.for, scf.if\\narith dialect → arith.addf, arith.mulf\\nllvm dialect → llvm.load, llvm.call\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"즉 어떤 연산들이 있는지를 정의하는 것.\\n그리고 이 연산을 다른 연산으로 바꾸는 것이 바로 Conversion pattern (Rewrite Pattern)\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"affine.for → scf.for\\nscf.for → cf.br + 블록\\narith.addf → llvm.fadd\\nfunc.func → llvm.func\\n\\nMLIR 코드에서는 아래와 같이 Conversion 레시피 묶음을 등록함.\\npopulateAffineToStdConversionPatterns(...)\\npopulateSCFToControlFlowConversionPatterns(...)\\npopulateArithToLLVMConversionPatterns(...)\\npopulateFuncToLLVMConversionPatterns(...)\\n\"}]}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\"]}],\"$L1f\",\"$L20\"]}]\n"])</script><script>self.__next_f.push([1,"21:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"p\",null,{\"children\":\"대부분의 dialect 에서 자기 자신을 LLVM으로 낮추는 변환 패턴을 함께 제공하지만, dialect != conversion pattern이다.\"}]\nf:[\"$\",\"p\",null,{\"children\":\"(4) Full Conversion\"}]\n10:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"applyFullConversion(...)\\n\"}]}]\n11:[\"$\",\"p\",null,{\"children\":\"LLVM 아닌 연산이 하나라도 남으면 실패\\n이는 곧 아주 깔끔한 LLVM-only IR 이다.\"}]\n12:[\"$\",\"p\",null,{\"children\":\"(5) 예제 결과 : LLVM dialect MLIR\"}]\n13:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"malloc, free, printf 호출\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"포인터 연산\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"GEP, load, call, br 등\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"완전한 저수준 코드\\n컴파일러가 본격적으로 시작하는 느낌이다.\"}],\"\\n\"]}]\n14:[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Step 3 : LLVM IR로 변환\\nMLIR이 끝났기 때문에 LLVM IR(.ll) 로 변환을 한다.\"}],\"\\n\"]}]\n15:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"translateModuleToLLVMIR(...)\\n\"}]}]\n16:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 결과를 보면 처음에는 되게 길고 복잡한 IR 처럼 보이지만\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"최적화를 켜면 반복문도 사라지고, 상수가 계산되고, printf만 쭉 남게 된다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이는 컴파일러가 계산을 미리 다 해버리기 때문이다.\"}],\"\\n\"]}]\n17:[\"$\",\"ol\",null,{\"start\":\"5\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Step 4 : JIT로 바로 실행\\n이는 MLIR의 ExecutionEngine을 사용해서 가능하다.\\n(1) LLVM 타겟을 초기화하고\\n(2) 최적화 파이프라인을 설정하고\\n(3) JIT 컴파일을 진행하고\\n(4) main() 을 호출한다.\"}],\"\\n\"]}]\n18:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"engine-\u003einvoke(\\\"main\\\");\\n\"}]}]\n19:[\"$\",\"p\",null,{\"children\":\"파일을 바로 저장하는 것이 아닌 바로 메모리에서 실행을 한다.\"}]\n1a:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$$ echo 'def main() { print([[1, 2], [3, 4]]); }' | ./toyc-ch6 -emit=jit\\n\\n했을때 출력 결과는\\n\\n1.000000 2.000000\\n3.000000 4.000000\\n\"}]}]\n1b:[\"$\",\"p\",null,{\"children\":\"Toy 언어가 실제 프로그램 처럼 실행된다.\"}]\n1c:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n1d:[\"$\",\"p\",null,{\"children\":\"이 장의 내용을 요약해 보자면\"}]\n1e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR은 단계적으로 LLVM 까지 낮츨 수 있고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Dialect Conversion + Transitive Lowering = 자동 변환이고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"toy.print \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" printf\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"LLVM IR \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" 최적화 \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" JIT 실행\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Toy 를 실행 가능한 언어로 만들었다.\"}],\"\\n\"]}]\n1f:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n20:[\"$\",\"$L21\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"22:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Toy Tutorial Ch 6 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Lowering to LLVM and code generation. Here we'll target LLVM IR for code generation, and detail more of the lowering framework.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L22\",\"3\",{}]]\n8:null\n"])</script></body></html>