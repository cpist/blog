1:"$Sreact.fragment"
5:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
6:"$Sreact.suspense"
0:{"buildId":"ud85Qdc4drAPBLjcIj7DW","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Tutorial md6 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-11-09"}],["$","p",null,{"style":{"color":"#333"},"children":"Lowering to LLVM and code generation. Here we'll target LLVM IR for code generation, and detail more of the lowering framework."}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"이제 Toy 언어 -> MLIR -> LLVM -> 실제 실행되는 코드 (JIT) 로 간다.\n진짜 프로그램을 돌리는 것."}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"Step 1 : Toy -> LLVM (Lowering)\n이전 장에서 다룬 내용을 통해 toy 연산은 이미 affine / scf / arith 같은 표준 MLIR로 바꿔놓았다.\n남은건 toy.print 이다."}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":"toy.print 는"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"내부적으로 C의 printf를 부르거나"}],"\n",["$","li",null,{"children":"배열을 이중 for-loop 로 돌면서 하나씩 출력하거나"}],"\n",["$","li",null,{"children":"MLIR의 transitive lowering 덕분에 바로 LLVM을 만들지 않더라도, 중간 단계를 거쳐 자동으로 LLVM 까지 갈수 있다."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"printf 함수는 어디에서 오는가?\n필요한 경우 LLVM 모듈 안에서 printf 선언을 자동으로 추가함"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"i32 printf(i8*, ...)\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이미 있으면 재사용"}],"\n",["$","li",null,{"children":"없으면 새로 만들어 넣기"}],"\n",["$","li",null,{"children":"필요한 외부함수는 알아서 미리 준비한다."}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"Step 2 : Conversion 설정\n(1) Conversion target"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"목표는 LLVM dialect 만 남기기"}],"\n",["$","li",null,{"children":"ModuleOp + LLVMDialect 만 허용"}],"\n"]}],"\n",["$","p",null,{"children":"(2) Type Converter"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["memref ",["$","code",null,{"children":"->"}]," LLVM 포인터 구조체로 변환"]}],"\n",["$","li",null,{"children":"Toy 전용 타입이 없어서 기본 LLVMTypeConverter면 충분"}],"\n"]}],"\n",["$","p",null,{"children":"(3) Conversion Patterns"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"affine -> std"}],"\n",["$","li",null,{"children":"scf -> control flow"}],"\n",["$","li",null,{"children":"arith -> LLVM"}],"\n",["$","li",null,{"children":"func -> LLVM"}],"\n",["$","li",null,{"children":"cf -> LLVM"}],"\n",["$","li",null,{"children":"toy.print 전용 lowering 패턴\n즉 모든 연산을 LLVM으로 변환 가능하다는 것."}],"\n"]}],"\n",["$","p",null,{"children":"(4) Full Conversion"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"applyFullConversion(...)\n"}]}],"\n",["$","p",null,{"children":"LLVM 아닌 연산이 하나라도 남으면 실패\n이는 곧 아주 깔끔한 LLVM-only IR 이다."}],"\n",["$","p",null,{"children":"(5) 예제 결과 : LLVM dialect MLIR"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"malloc, free, printf 호출"}],"\n",["$","li",null,{"children":"포인터 연산"}],"\n",["$","li",null,{"children":"GEP, load, call, br 등"}],"\n",["$","li",null,{"children":"완전한 저수준 코드\n컴파일러가 본격적으로 시작하는 느낌이다."}],"\n"]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"Step 3 : LLVM IR로 변환\nMLIR이 끝났기 때문에 LLVM IR(.ll) 로 변환을 한다."}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"translateModuleToLLVMIR(...)\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 결과를 보면 처음에는 되게 길고 복잡한 IR 처럼 보이지만"}],"\n",["$","li",null,{"children":"최적화를 켜면 반복문도 사라지고, 상수가 계산되고, printf만 쭉 남게 된다."}],"\n",["$","li",null,{"children":"이는 컴파일러가 계산을 미리 다 해버리기 때문이다."}],"\n"]}],"\n",["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"Step 4 : JIT로 바로 실행\n이는 MLIR의 ExecutionEngine을 사용해서 가능하다.\n(1) LLVM 타겟을 초기화하고\n(2) 최적화 파이프라인을 설정하고\n(3) JIT 컴파일을 진행하고\n(4) main() 을 호출한다."}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"engine->invoke(\"main\");\n"}]}],"\n",["$","p",null,{"children":"파일을 바로 저장하는 것이 아닌 바로 메모리에서 실행을 한다."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$$ echo 'def main() { print([[1, 2], [3, 4]]); }' | ./toyc-ch6 -emit=jit\n\n했을때 출력 결과는\n\n1.000000 2.000000\n3.000000 4.000000\n"}]}],"\n",["$","p",null,{"children":"Toy 언어가 실제 프로그램 처럼 실행된다."}],"\n",["$","p",null,{"children":"====================================================================="}],"\n","$L2","\n","$L3"]}]]}],null,"$L4"]}],"loading":null,"isPartial":false}
2:["$","p",null,{"children":"이 장의 내용을 요약해 보자면"}]
3:["$","ul",null,{"children":["\n",["$","li",null,{"children":"MLIR은 단계적으로 LLVM 까지 낮츨 수 있고"}],"\n",["$","li",null,{"children":"Dialect Conversion + Transitive Lowering = 자동 변환이고"}],"\n",["$","li",null,{"children":["toy.print ",["$","code",null,{"children":"->"}]," printf"]}],"\n",["$","li",null,{"children":["LLVM IR ",["$","code",null,{"children":"->"}]," 최적화 ",["$","code",null,{"children":"->"}]," JIT 실행"]}],"\n",["$","li",null,{"children":"Toy 를 실행 가능한 언어로 만들었다."}],"\n"]}]
4:["$","$L5",null,{"children":["$","$6",null,{"name":"Next.MetadataOutlet","children":"$@7"}]}]
7:null
