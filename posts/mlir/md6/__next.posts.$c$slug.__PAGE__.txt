1:"$Sreact.fragment"
17:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
18:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
19:"$Sreact.suspense"
0:{"buildId":"l8yvcX2zcoGhp9hpJxEKS","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Toy Tutorial Ch 6 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-11-09"}],["$","p",null,{"style":{"color":"#333"},"children":"Lowering to LLVM and code generation. Here we'll target LLVM IR for code generation, and detail more of the lowering framework."}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"1) 이제 Toy 언어 -> MLIR -> LLVM -> 실제 실행되는 코드 (JIT) 로 간다.\n진짜 프로그램을 돌리는 것."}],"\n",["$","p",null,{"children":"여기서 LLVM으로 낮춘다는 말을 쓰느데\nLLVM은 컴파일러 인프라이고, MLIR이 LLVM이 사용할 수 있는 IR을 만들어 주는 것이다.\n즉 LLVM 인프라가 처리할 수 있는 IR 형태로 바꿔주는 것이 MLIR"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"Toy / TensorFlow / PyTorch / DSL\n        ↓\n     MLIR (여러 dialect)\n        ↓\n   MLIR LLVM dialect\n        ↓\n     LLVM IR (.ll)\n        ↓\n   LLVM Optimizer + Backend\n        ↓\n    실행 파일 / JIT 실행\n"}]}],"\n",["$","p",null,{"children":"그리고 LLVM의 구성요소도 짤막하게 정리해 보자면"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"LLVM IR : 저수준 중간 표현"}],"\n",["$","li",null,{"children":"Optimizer : IR 최적화"}],"\n",["$","li",null,{"children":["CodeGen : IR ",["$","code",null,{"children":"->"}]," 머신 코드"]}],"\n",["$","li",null,{"children":"JIT : 즉석 컴파일"}],"\n",["$","li",null,{"children":"Backend : x86, ARM 등 타깃 아키텍쳐에 맞게 LLVM IR 을 머신 코드로 변환"}],"\n"]}],"\n",["$","p",null,{"children":"2) Step 1 : Toy -> LLVM (Lowering)\n이전 장에서 다룬 내용을 통해 toy 연산은 이미 affine / scf / arith 같은 표준 MLIR로 바꿔놓았다.\n남은건 toy.print 이다."}],"\n",["$","p",null,{"children":"toy.print 는"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"내부적으로 C의 printf를 부르거나"}],"\n",["$","li",null,{"children":"배열을 이중 for-loop 로 돌면서 하나씩 출력하거나"}],"\n",["$","li",null,{"children":"MLIR의 transitive lowering 덕분에 바로 LLVM을 만들지 않더라도, 중간 단계를 거쳐 자동으로 LLVM 까지 갈수 있다."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"printf 함수는 어디에서 오는가?\n필요한 경우 LLVM 모듈 안에서 printf 선언을 자동으로 추가함"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"i32 printf(i8*, ...)\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이미 있으면 재사용"}],"\n",["$","li",null,{"children":"없으면 새로 만들어 넣기"}],"\n",["$","li",null,{"children":"필요한 외부함수는 알아서 미리 준비한다."}],"\n"]}],"\n",["$","p",null,{"children":"3) Step 2 : Conversion 설정\n(1) Conversion target"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"목표는 LLVM dialect 만 남기기"}],"\n",["$","li",null,{"children":"ModuleOp + LLVMDialect 만 허용"}],"\n"]}],"\n",["$","p",null,{"children":"(2) Type Converter"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["memref ",["$","code",null,{"children":"->"}]," LLVM 포인터 구조체로 변환"]}],"\n",["$","li",null,{"children":"Toy 전용 타입이 없어서 기본 LLVMTypeConverter면 충분"}],"\n"]}],"\n",["$","p",null,{"children":"(3) Conversion Patterns"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"affine -> std"}],"\n",["$","li",null,{"children":"scf -> control flow"}],"\n",["$","li",null,{"children":"arith -> LLVM"}],"\n",["$","li",null,{"children":"func -> LLVM"}],"\n",["$","li",null,{"children":"cf -> LLVM"}],"\n",["$","li",null,{"children":"toy.print 전용 lowering 패턴\n즉 모든 연산을 LLVM으로 변환 가능하다는 것.\n이 것들은 dialect를 다른 dialect로 바꾸는 변환 패턴임.\ndialect 는 연산(op) 와 타입(type) 의 언어 묶음 이었음. (아래 예시와 같이)"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"affine dialect → affine.for, affine.load\nscf dialect → scf.for, scf.if\narith dialect → arith.addf, arith.mulf\nllvm dialect → llvm.load, llvm.call\n"}]}],"\n",["$","p",null,{"children":"즉 어떤 연산들이 있는지를 정의하는 것.\n그리고 이 연산을 다른 연산으로 바꾸는 것이 바로 Conversion pattern (Rewrite Pattern)"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"affine.for → scf.for\nscf.for → cf.br + 블록\narith.addf → llvm.fadd\nfunc.func → llvm.func\n\nMLIR 코드에서는 아래와 같이 Conversion 레시피 묶음을 등록함.\npopulateAffineToStdConversionPatterns(...)\npopulateSCFToControlFlowConversionPatterns(...)\npopulateArithToLLVMConversionPatterns(...)\npopulateFuncToLLVMConversionPatterns(...)\n"}]}],"\n","$L2","\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12"]}],"$L13","$L14"]}],["$L15"],"$L16"]}],"loading":null,"isPartial":false}
2:["$","p",null,{"children":"대부분의 dialect 에서 자기 자신을 LLVM으로 낮추는 변환 패턴을 함께 제공하지만, dialect != conversion pattern이다."}]
3:["$","p",null,{"children":"(4) Full Conversion"}]
4:["$","pre",null,{"children":["$","code",null,{"children":"applyFullConversion(...)\n"}]}]
5:["$","p",null,{"children":"LLVM 아닌 연산이 하나라도 남으면 실패\n이는 곧 아주 깔끔한 LLVM-only IR 이다."}]
6:["$","p",null,{"children":"(5) 예제 결과 : LLVM dialect MLIR"}]
7:["$","ul",null,{"children":["\n",["$","li",null,{"children":"malloc, free, printf 호출"}],"\n",["$","li",null,{"children":"포인터 연산"}],"\n",["$","li",null,{"children":"GEP, load, call, br 등"}],"\n",["$","li",null,{"children":"완전한 저수준 코드\n컴파일러가 본격적으로 시작하는 느낌이다."}],"\n"]}]
8:["$","p",null,{"children":"4) Step 3 : LLVM IR로 변환\nMLIR이 끝났기 때문에 LLVM IR(.ll) 로 변환을 한다."}]
9:["$","pre",null,{"children":["$","code",null,{"children":"translateModuleToLLVMIR(...)\n"}]}]
a:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 결과를 보면 처음에는 되게 길고 복잡한 IR 처럼 보이지만"}],"\n",["$","li",null,{"children":"최적화를 켜면 반복문도 사라지고, 상수가 계산되고, printf만 쭉 남게 된다."}],"\n",["$","li",null,{"children":"이는 컴파일러가 계산을 미리 다 해버리기 때문이다."}],"\n"]}]
b:["$","p",null,{"children":"5) Step 4 : JIT로 바로 실행\n이는 MLIR의 ExecutionEngine을 사용해서 가능하다.\n(1) LLVM 타겟을 초기화하고\n(2) 최적화 파이프라인을 설정하고\n(3) JIT 컴파일을 진행하고\n(4) main() 을 호출한다."}]
c:["$","pre",null,{"children":["$","code",null,{"children":"engine->invoke(\"main\");\n"}]}]
d:["$","p",null,{"children":"파일을 바로 저장하는 것이 아닌 바로 메모리에서 실행을 한다."}]
e:["$","pre",null,{"children":["$","code",null,{"children":"$$ echo 'def main() { print([[1, 2], [3, 4]]); }' | ./toyc-ch6 -emit=jit\n\n했을때 출력 결과는\n\n1.000000 2.000000\n3.000000 4.000000\n"}]}]
f:["$","p",null,{"children":"Toy 언어가 실제 프로그램 처럼 실행된다."}]
10:["$","p",null,{"children":"====================================================================="}]
11:["$","p",null,{"children":"이 장의 내용을 요약해 보자면"}]
12:["$","ul",null,{"children":["\n",["$","li",null,{"children":"MLIR은 단계적으로 LLVM 까지 낮츨 수 있고"}],"\n",["$","li",null,{"children":"Dialect Conversion + Transitive Lowering = 자동 변환이고"}],"\n",["$","li",null,{"children":["toy.print ",["$","code",null,{"children":"->"}]," printf"]}],"\n",["$","li",null,{"children":["LLVM IR ",["$","code",null,{"children":"->"}]," 최적화 ",["$","code",null,{"children":"->"}]," JIT 실행"]}],"\n",["$","li",null,{"children":"Toy 를 실행 가능한 언어로 만들었다."}],"\n"]}]
13:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
14:["$","$L17",null,{}]
15:["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true}]
16:["$","$L18",null,{"children":["$","$19",null,{"name":"Next.MetadataOutlet","children":"$@1a"}]}]
1a:null
