1:"$Sreact.fragment"
29:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
2a:"$Sreact.suspense"
0:{"buildId":"PTU0wTDwtLucBHok_-Hv8","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR Toy Tutorial Ch 3 에 대하여"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-11-01"}],["$","p",null,{"style":{"color":"#333"},"children":"High-level language-specific optimization using pattern rewriting system."}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"왜 고수준 dialect인가?\nLLVM IR로 내려가면 많은 게 루프와 메모리 load / store로 풀림."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"당연히 이런 구조면 transpose(transpose(x)) 같은 걸 알아 보기 어렵고"}],"\n",["$","li",null,{"children":"임시 배열, 중간 버퍼가 끼면 더더욱 힘들어짐.\n반면 MLIR의 Toy IR은 toy.transpose 같은 의미 있는 op로 남아 있어서"}],"\n",["$","li",null,{"children":"연산 의미를 그대로 보고"}],"\n",["$","li",null,{"children":"간단한 규칙으로 최적화 할 수 있다."}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"로컬 최적화는 패턴 매칭과 치환에 있다.\n컴파일러 변환은 크게 두가지로 나뉨"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Local : 가까운 몇 개 op만 보고 바꾸는 최적화"}],"\n",["$","li",null,{"children":"Global : 함수 전체 / 프로그램 전체를 보고 바꾸는 최적화"}],"\n"]}],"\n",["$","p",null,{"children":"이번에 다루는 것은 Local인데, '이런 모양이면 이렇게 바꾼다'라는 것을 계속 적용하는 방식이다.\nMLIR에는 이를 위한 두가지의 엔진이 있다."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Generic DAG Rewriter"}],"\n",["$","li",null,{"children":"대표 실행 패스가 Canonicalizer (greedy 한 반복 적용 + deadcode 정리)"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"여기서 패스(pass) 라는 개념이 중요하다.\npass는 IR을 한번 훑으면서 분석하거나 변환하는 독립적인 단계를 말함.\n즉, IR을 입력으로 받아서 정보를 얻거나 IR을 바꾸고 다음 단계로 넘기는 작업 단위를 말함."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"pass는 IR을 한번 지나간다(pass through)"}],"\n",["$","li",null,{"children":"따라서 한 pass는 한번의 IR 통과를 의미하고, 여러 pass 를 연결하면 pass pipeline 이 되는 셈."}],"\n",["$","li",null,{"children":["패스의 이점은 아래와 같음","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"분리와 재사용 (한 pass는 하나의 책임만, 다른 컴파일러와 언어에서도 재사용 가능)"}],"\n",["$","li",null,{"children":"순서 조절 가능 (최적화 순서 바꾸기 쉽고 실험하기 좋다.)"}],"\n",["$","li",null,{"children":"디버깅 쉬움 (이 패스를 돌린 뒤 IR이 어떻게 변했는지 바로 확인이 가능)\n패스에는 크게 2가지로 나뉨. 분석 패스 (Analysis Pass) 와 변환 패스 (Transformation Pass)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["Analysis Pass는 IR을 읽기만 하고, 정보만 계산하는것","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"따라서 IR 변경을 안하고"}],"\n",["$","li",null,{"children":"메타정보 (analysis result)를 생성하고"}],"\n",["$","li",null,{"children":"다른 패스가 참고용으로 사용함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["Transformation Pass 는 IR을 실제로 바꾸는 것","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"불필요한 연산을 제거한다던지, 연산 순서를 변경 한다던지, 고수준 op -> 저수준 op로 변환 (lowering) 한다던지, 최적화를 한다."}],"\n",["$","li",null,{"children":"우리가 다루는 Canonicalizer가 대표적인 변환 패스다."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"여기서 Canonicalizer 패스도 알아볼 필요가 있음."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["알려진 단순 규칙들을 IR 전체에 반복적으로 적용해서 깔끔하게 만듦.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"패턴 매칭 -> Rewrite"}],"\n",["$","li",null,{"children":"더 이상 바뀔 게 없을 때까지 반복"}],"\n",["$","li",null,{"children":"dead code 정리를 포함함."}],"\n",["$","li",null,{"children":"그래서 대표 실행 패스라고 부름."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["패스는 적용 대상 (scope) 이 있음.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"ModulePass -> 모듈 전체"}],"\n",["$","li",null,{"children":"FunctionPass -> 함수 하나"}],"\n",["$","li",null,{"children":"LoopPass -> 루프 하나"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"pm.addNestedPass<toy::FuncOp>(createCanonicalizerPass());\n"}]}],"\n",["$","p",null,{"children":"이건 모듈 안에 있는 각 toy.func 마다 canonicalizer를 돌리라는 의미임."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"근데 여기서 어떻게 모듈 단위 / 함수 단위를 알수 있는 걸까?"}],"\n",["$","li",null,{"children":"PassManager는 ModuleOp 기준으로 만들어진 매니저임."}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"mlir::PassManager pm(module->getName());\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"MLIR에서 최상위 IR 컨테이너는 항상 ModuleOp 임."}],"\n",["$","li",null,{"children":"PassManger 는 기본적으로 ModuleOp에서 실행된다."}],"\n","$L2","\n"]}],"\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27"]}]]}],null,"$L28"]}],"loading":null,"isPartial":false}
2:["$","li",null,{"children":"이 시점에서 패스 파이프라인은 모듈 단위로 시작한다는 것이 정해져 있다는 것."}]
3:["$","p",null,{"children":"다시"}]
4:["$","pre",null,{"children":["$","code",null,{"children":"pm.addNestedPass<toy::FuncOp>(createCanonicalizerPass());\n\n는 대충 아래같은 의미라는 것\nrunOnModule(module) {\n  for (toy::FuncOp f : module.getOps<toy::FuncOp>()) {\n    runCanonicalizerOnFunc(f);\n  }\n}\n"}]}]
5:["$","p",null,{"children":"를 보면, ModuleOp 안에 중첩된(nested) toy::FuncOp를 대상으로 이 패스를 실행하라는게 명확해짐."}]
6:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Nested는 최상위(Module) 가 아니라, 그 안쪽에 들어있는 op들을 말하고 (2단계 scope)"}],"\n",["$","li",null,{"children":[["$","code",null,{"children":"<toy::FuncOp>"}]," 는 그 안쪽 op 중에서 타입이 toy::FuncOp 인것을 말한다."]}],"\n"]}]
7:["$","pre",null,{"children":["$","code",null,{"children":"ModuleOp\n ├─ toy.func @f1\n ├─ toy.func @f2\n └─ toy.func @f3\n\n여기서 패스를 실행하면\n\nfor (auto func : module.getOps<toy::FuncOp>()) {\n    run canonicalizer on func;\n}\n"}]}]
8:["$","p",null,{"children":"즉,"}]
9:["$","ul",null,{"children":["\n",["$","li",null,{"children":"모듈을 한번 순회하고"}],"\n",["$","li",null,{"children":"그 안에서 각 toy.func를 찾아서 각 함수에 대해 canonicalizer 를 실행하라는 것이다."}],"\n",["$","li",null,{"children":["다시 한번 말하지만 PassManager는 ModuleOp 기준이고, CanonicalizerPass는 FuncOp 기준이다.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["그렇기 때문에 ",["$","code",null,{"children":"addNestedPass<FuncOp>"}]," 로 연결하는 것이다."]}],"\n",["$","li",null,{"children":"모듈을 기준으로 파이프라인을 시작해서, 그 안에 있는 각 함수 단위로 canonicalizer를 실행한다."}],"\n"]}],"\n"]}],"\n"]}]
a:["$","ul",null,{"children":["\n",["$","li",null,{"children":"만약 모듈단위 패스로 실행하고 싶다면?"}],"\n"]}]
b:["$","pre",null,{"children":["$","code",null,{"children":"pm.addPass(createCanonicalizerPass());\n"}]}]
c:["$","ul",null,{"children":["\n",["$","li",null,{"children":"만약 함수 단위 패스 매니저를 따로 만든다면?"}],"\n"]}]
d:["$","pre",null,{"children":["$","code",null,{"children":"OpPassManager &funcPM = pm.nest<toy::FuncOp>();\nfuncPM.addPass(createCanonicalizerPass());\n"}]}]
e:["$","p",null,{"children":"길게 확인해 봤는데 다시 본문으로 돌아오면"}]
f:["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"예제 1: transpose(transpose(x)) → x (C++ 패턴 리라이터)\nToy 코드는"}],"\n"]}]
10:["$","pre",null,{"children":["$","code",null,{"children":"return transpose(transpose(x));\n"}]}]
11:["$","p",null,{"children":"Toy IR은"}]
12:["$","pre",null,{"children":["$","code",null,{"children":"%0 = toy.transpose(%arg0)\n%1 = toy.transpose(%0)\nreturn %1\n"}]}]
13:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이걸 C++로도 할수 있음 (OpRewritePattern)"}],"\n",["$","li",null,{"children":"여기서 %0는 아무도 안쓰는 거니까, 사용처(use)가 0개인 값을 만드는 셈. 이런 op를 죽은코드(dead) 라고 함."}],"\n",["$","li",null,{"children":["Pure trait 라는 것이 있음. op는 부작용이 없고, 같은 입력이면 항상 같은 출력만 만든다는 것.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"transpose가 대표적인 예인데, 출력 tensor를 계산해서 만들어 내지만"}],"\n",["$","li",null,{"children":"출력 외에 프린트 / 메모리 변경 / IO / 전역상태 변경 같은 부작용이 없음"}],"\n",["$","li",null,{"children":"입력이 같으면 결과도 항상 같다."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"결과 SSA 값이 안쓰이는, 즉 안쓰이는 경우라면 얘를 제거해도 프로그램 관찰 가능한 결과 (출력, 메모리, 리턴값) 가 바뀌지 않기 때문에 제거해도 의미가 변하지 않음."}],"\n",["$","li",null,{"children":"그래서 지울 수 있음."}],"\n",["$","li",null,{"children":["MLIR은 SSA 기반이기 때문에 참조하는 곳이 0개면 그냥 dead value이고, 만약 op가 Pure(부작용 없음) 인 경우 바로 삭제함.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이것이 바로 dead code elimination(DCE) 의 기본 원리임.\n다시 Toy case로 돌아와서"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"MLIR이 op에 부작용 (side effect) 가 있을지도 몰라 보수적인 판단으로 함부로 못지울 수가 있음."}],"\n",["$","li",null,{"children":"그래서 아래와 같이 Pure trait을 붙이는 것임."}],"\n"]}]
14:["$","pre",null,{"children":["$","code",null,{"children":"def TransposeOp : Toy_Op<\"transpose\", [Pure]> {...}\n"}]}]
15:["$","ul",null,{"children":["\n",["$","li",null,{"children":"MLIR은 transpose 는 부작용이 없기에 -> 안쓰이면 지워도 된다고 판단함."}],"\n",["$","li",null,{"children":"이에 따라 최종 결과가 toy.return %arg0 로 깔끔하게 나옴."}],"\n"]}]
16:["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"reshape 최적화는 DRR(Declarative Rewrite Rules) 로 더 깔끔하게\nReshape 최적화는 규칙이 많고 반복적이기 떄문에, C++ 보다는 MLIR의 경우 DRR 라는 룰 기반 시스템을 활용함.\n우리가 md2에서 ODS로 op를 정의했을때 DRR을 쓸수 있었다."}],"\n"]}]
17:["$","ul",null,{"children":["\n",["$","li",null,{"children":"DRR Rule example 1: Reshape(Reshape(x)) -> Reshape(x)"}],"\n"]}]
18:["$","pre",null,{"children":["$","code",null,{"children":"def ReshapeReshapeOptPattern : Pat<(ReshapeOp(ReshapeOp $arg)),\n                                   (ReshapeOp $arg)>;\n"}]}]
19:["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"sourcePattern: reshape(reshape(arg))"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"resultPattern: reshape(arg) 하나만 남김"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"DRR Rule example 2 : 진짜 불필요한 reshape는 제거하기\n만약 입력 타입과 출려 타입이 똑같은 경우 reshape는 완전히 쓸모가 없.\n따라서 아래와 같이 조건을 추가함."}],"\n"]}],"\n"]}]
1a:["$","pre",null,{"children":["$","code",null,{"children":"TypesAreIdentical: $0.getType() == $1.getType()\nReshapeOp:$res $arg  =>  replaceWithValue $arg\n"}]}]
1b:["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"reshpae 결과 타입이 입력 타입과 같은 경우"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"reshape op를 없애고 입력을 그대로 쓰게 한다."}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"DRR Rule example 3 : Constant reshape는 상수 자체를 바꿔치기 하는 것"}],"\n"]}],"\n"]}]
1c:["$","p",null,{"children":"reshape(constant) 는"}]
1d:["$","ul",null,{"children":["\n",["$","li",null,{"children":"constant 의 dense 데이터를 그 shape으로 미리 바꿔서"}],"\n",["$","li",null,{"children":"reshape op를 통째로 삭제 가능하게 함."}],"\n"]}]
1e:["$","pre",null,{"children":["$","code",null,{"children":"(ReshapeOp:$res (ConstantOp $arg))\n  =>\n(ConstantOp (ReshapeConstant $arg, $res))\n"}]}]
1f:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이건 Runtime reshape 이 아니라 Compile time에 상수 모양을 바꿔서 끝내는 것이다."}],"\n"]}]
20:["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"실제 케이스: trivial_reshape"}],"\n"]}]
21:["$","pre",null,{"children":["$","code",null,{"children":"%1 = toy.reshape(%0) to tensor<2x1xf64>\n%2 = toy.reshape(%1) to tensor<2x1xf64>\n%3 = toy.reshape(%2) to tensor<2x1xf64>\n"}]}]
22:["$","p",null,{"children":"초기 IR은 reshpae이 이렇게 3번 연달아 있었지만\nDRR과 canonicalizer를 돌리게 되면"}]
23:["$","pre",null,{"children":["$","code",null,{"children":"%0 = toy.constant dense<[[1.0],[2.0]]> : tensor<2x1xf64>\ntoy.print %0\n"}]}]
24:["$","p",null,{"children":"이런 식으로 reshape이 전부 사라지고, constant 모양만 깔끔하게 맞춰진다."}]
25:["$","p",null,{"children":"====================================================================="}]
26:["$","p",null,{"children":"이번에도 긴글을 정리해 보자면"}]
27:["$","ul",null,{"children":["\n",["$","li",null,{"children":["Toy IR 처럼 의미가 살아있는 고수준 op들에 대해, 패턴 매칭으로 '쓸데없는 연산'을 싹 걷어내는 것.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"C++ 방식 : OpRewritePattern 으로 직접 구현하는 것"}],"\n",["$","li",null,{"children":"선언형 방식 : DRR(TableGen 룰)로 간단히 정의되었음"}],"\n",["$","li",null,{"children":"Canonicalizer가 greedy 하게 반복 적용 + Pure 면 dead op 제거까지"}],"\n"]}],"\n"]}],"\n"]}]
28:["$","$L29",null,{"children":["$","$2a",null,{"name":"Next.MetadataOutlet","children":"$@2b"}]}]
2b:null
