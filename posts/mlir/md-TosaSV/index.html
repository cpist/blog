<!DOCTYPE html><!--iP1VKKh5IpKVfa_WVjKWE--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/blog/images/Capture-1.png" as="image"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR TOSA Static Analysis - CPIST&#x27;s blog</title><meta name="description" content="MLIR TOSA Static Analysis 방법론"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR TOSA Static Analysis</h2><div style="color:#666;margin-bottom:18px">2026-01-07</div><p style="color:#333">MLIR TOSA Static Analysis 방법론</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>1) TOSA (Tensor Operator Set Architecture)란?
TOSA는 다양한 하드웨어 타겟(CPU, GPU, NPU)에서 추론을 수행하기 위해 설계된 표준 텐서 연산 집합임.
Arm에서 처음 제안했으며, 현재는 MLIR의 핵심 Dialect로 포함되어 있음.</p>
<ul>
<li>목적은 상위 프레임워크(TensorFlow, PyTorch)와 하위 코드 생성(LLVM IR, 하드웨어 특화 IR) 사이의 안정적인 교량(Stable Bridge) 역할</li>
<li>특징은 아래와 같음<!-- -->
<ul>
<li>하드웨어 독립적: 특정 가속기에 치우치지 않는 범용적인 연산을 정의</li>
<li>양자화(Quantization) 최적화: 정수 연산 및 양자화 파라미터를 정교하게 다룸</li>
<li>낮은 복잡도: 약 100개 미만의 기본 연산으로 구성되어 백엔드 구현 부담을 줄임</li>
</ul>
</li>
</ul>
<p>2) TOSA 정적 오류 분석 패스 작성법
MLIR에서 &quot;정적 오류&quot;를 찾는 방법은 크게 두 가지</p>
<ul>
<li>ODS 내장 Verifier: 각 Op의 타입, 랭크 등 구조적 정당성 체크</li>
<li>Custom Analysis Pass: 특정 하드웨어 제약 조건 위반이나 데이터 흐름상의 논리 오류 검출</li>
</ul>
<p>우리가 테스트 해볼것은
TOSA 연산 중 특정 하드웨어가 지원하지 않는 설정(예: 커널 사이즈 제한)을 정적으로 찾아내는 패스</p>
<p>3) Pass 정의 (TableGen)
먼저 패스의 메타데이터를 정의</p>
<pre><code>// MyTosaAnalysis.td
def MyTosaAnalysis : Pass&lt;&quot;my-tosa-analysis&quot;, &quot;mlir::func::FuncOp&quot;&gt; {
  let summary = &quot;TOSA 연산의 하드웨어 호환성을 정적으로 검토.&quot;;
  let description = [{
    이 패스는 TOSA Conv2D 연산의 커널 크기가 3x3보다 큰 경우 에러를 발생시킴.
  }];
  let constructor = &quot;mlir::tosa::createMyTosaAnalysisPass()&quot;;
}
</code></pre>
<p>4) 분석 로직 구현 (C++)
walk 함수를 사용해 IR을 순회하며 검사</p>
<pre><code>// MyTosaAnalysis.cpp
#include &quot;mlir/Dialect/Tosa/IR/TosaOps.h&quot;
#include &quot;mlir/Dialect/Func/IR/FuncOps.h&quot;  // func::FuncOp를 위해 필요
#include &quot;mlir/IR/BuiltinTypes.h&quot;         // ShapedType을 위해 필요
#include &quot;mlir/Pass/Pass.h&quot;

using namespace mlir;

namespace {
// 1. PassWrapper의 두 번째 인자는 실제 구현될 베이스 클래스임.
struct MyTosaAnalysisPass 
    : public PassWrapper&lt;MyTosaAnalysisPass, OperationPass&lt;func::FuncOp&gt;&gt; {
  
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MyTosaAnalysisPass)

  // 최신 MLIR에서는 아래 함수들을 virtual로 인식시키기 위해 
  // StringRef를 반환하는 오버라이딩이 필요.
  StringRef getArgument() const final { return &quot;my-tosa-analysis&quot;; }
  StringRef getDescription() const final { return &quot;TOSA Conv2D 커널 크기 정적 검증&quot;; }

  void runOnOperation() override {
    // getOperation()은 이제 func::FuncOp를 반환.
    func::FuncOp func = getOperation();

    func.walk([&amp;](tosa::Conv2DOp op) {
      // getType() 뒤에 바로 .cast를 쓰는 것보다 
      // llvm::dyn_cast 또는 llvm::cast를 사용하는 것이 더 안전함.
      auto weightType = llvm::dyn_cast&lt;ShapedType&gt;(op.getWeight().getType());
      if (!weightType) return;

      auto shape = weightType.getShape(); // [OC, H, W, IC]
      
      // TOSA Conv2D의 Weight는 보통 [OC, H, W, IC] 순서.
      if (shape.size() &gt;= 3\) {
        int64_t h = shape[1];
        int64_t w = shape[2];

        if (h &gt; 3 || w &gt; 3\) {
          op.emitError() &lt;&lt; &quot;정적 검증 실패: 하드웨어 제약 조건 위반 (커널 &quot; 
                         &lt;&lt; h &lt;&lt; &quot;x&quot; &lt;&lt; w &lt;&lt; &quot; 미지원)&quot;;
          return signalPassFailure();
        }
      }
    });
  }
};
} // namespace

namespace mlir {
namespace tosa {
void registerMyTosaAnalysisPass() {
  PassRegistration&lt;MyTosaAnalysisPass&gt;();
}
} // namespace tosa
} // namespace mlir
</code></pre>
<ul>
<li>여기서 walk 함수는 MLIR에서 IR 계층 구조를 자동으로 순회(Traversal) 하는 핵심.
MLIR은 Module -&gt; Function -&gt; Block -&gt; Operation -&gt; Region 의 계층적(Nested) 구조.<!-- -->
<ul>
<li>walk이 없다면, 특정 Op(예: tosa.conv2d)를 찾기 위해 4~5중 for문을 직접 작성해야 함</li>
<li>재귀적 순회를 자동화 함: 최상위 Op(예: 함수)에서 호출하면 그 안에 포함된 모든 하위 Op들을 DFS 방식으로 탐색</li>
<li>특정 타입을 필터링함: 템플릿 인자를 통해 내가 관심 있는 특정 Dialect의 Op만 골라서 콜백 함수를 실행할 수 있음</li>
<li>보일러플레이트 제거: 반복문 관리, 반복자(Iterator) 무효화 등의 복잡한 처리를 내부적으로 해결</li>
</ul>
</li>
</ul>
<p>여기서 walk를 사용한건 함수 내부에 tosa.conv2d 가 어디에 있든 (루프 안이든, 조건문 안이든) 상관없이 모두 찾아내어 검증하기 위함.</p>
<ul>
<li>llvm::dyn_cast 에 대해서
내가 궁금했던 부분은 MLIR인데 왜 llvm 소스를 썼는가임.
MLIR은 LLVM의 인프라 위에 구축된 프로젝트임.</li>
</ul>
<ul>
<li>이말인 즉슨 LLVM이 제공하는 사용자 정의 RTTI(Run-Time Type Information) 메커니즘을 공유</li>
<li>MLIR 소스 코드를 보면 mlir/Support/LLVM.h를 자주 포함<!-- -->
<ul>
<li>즉, MLIR은 LLVM의 기초 유틸리티 모음인 LLVM Support Library에 깊게 의존</li>
</ul>
</li>
<li>llvm::dyn_cast, llvm::cast, llvm::isa 등은 특정 클래스에 종속된 함수가 아니라, 템플릿 기반의 범용 유틸리티<!-- -->
<ul>
<li>이 템플릿들은 대상 객체가 특정한 규칙(인터페이스)만 지키고 있다면 어떤 타입이든 캐스팅할 수 있도록 설계</li>
</ul>
</li>
</ul>
<p>가벼운 RTTI (Hand-rolled RTTI)</p>
<ul>
<li>C++ 표준의 dynamic_cast는 실행 성능이 느리고 바이너리 사이즈를 키우는 경향이 있음</li>
<li>LLVM/MLIR은 표준 RTTI 대신 classof라는 정적 메서드를 사용하는 커스텀 RTTI를 직접 구현해서 씀</li>
<li>설계 구조의 핵심 (classof): 모든 MLIR Operation(예: tosa::Conv2DOp)이나 Type은 내부에 classof라는 정적 함수를 가짐</li>
</ul>
<pre><code>// TableGen에 의해 자동 생성되는 코드의 개념적 모습
struct Conv2DOp : public Op&lt;Conv2DOp, ...&gt; {
  static bool classof(Operation *op) {
    // 이 Operation의 이름이 &quot;tosa.conv2d&quot;인지 확인
    return op-&gt;getName().getStringRef() == &quot;tosa.conv2d&quot;;
  }
};
</code></pre>
<p><code>llvm::dyn_cast&lt;T&gt;(obj)</code>를 호출하면, 템플릿 내부에서 T::classof(obj)를 호출</p>
<ul>
<li>&quot;이 객체가 정말 T 타입으로 변환 가능한가?&quot;를 체크</li>
<li>맞다면 포인터를 변환해주고, 틀리다면 nullptr을 반환</li>
</ul>
<p>포인터 래퍼(Pointer Wrapper) 설계</p>
<ul>
<li>tosa::Conv2DOp는 실제 거대한 객체가 아니라, Operation* 포인터 하나를 들고 있는 아주 가벼운 래퍼(Wrapper) 클래스</li>
<li>구조적으로 tosa::Conv2DOp 객체를 복사해도 실제로는 포인터 하나만 복사됩니다. (값 복사가 아닌 참조 복사처럼 동작)</li>
<li>유연성 측면에서 이러한 설계 덕분에 Operation*라는 범용 포인터를 하드웨어 제약 조건이 담긴 tosa::Conv2DOp라는 구체적인 클래스로 아주 가볍고 빠르게 재해석할 수 있음</li>
</ul>
<p>Dialect 간의 확장성 (Extensibility)</p>
<ul>
<li>MLIR은 수많은 Dialect(TOSA, Linalg, Affine 등)가 공존<!-- -->
<ul>
<li>이들이 모두 dyn_cast를 쓸 수 있는 이유</li>
</ul>
</li>
<li>모든 연산은 결국 최상위 부모인 <strong>mlir::Operation</strong>으로 통하기 때문</li>
<li>각 Dialect는 TableGen을 통해 자신만의 **Unique ID(또는 이름)**를 가짐</li>
<li>llvm::dyn_cast는 이 ID나 이름을 대조하여 캐스팅 여부를 판단</li>
</ul>
<p>5) 실제 테스트</p>
<ol>
<li>4)에 언급된 소스를 llvm-project/mlir/lib/Dialect/Tosa/Transforms/ 에 MyTOsaAnalysis.cpp 같은 파일로 저장하자.</li>
<li>mlir/lib/Dialect/Tosa/Transforms/CMakeLists.txt 를 열어서 add_mlir_dialect_library 부분에 MyTosaAnalysis.cpp를 추가하자</li>
</ol>
<pre><code>add_mlir_dialect_library(MLIRTosaTransforms
  TosaDecomposeConv2D.cpp
  TosaInferShapes.cpp
  MyTosaAnalysis.cpp  # &lt;-- 추가
  ...
)
</code></pre>
<ol start="3">
<li>mlir/tools/mlir-opt/mlir-opt.cpp 에</li>
</ol>
<pre><code>namespace tosa {
  void registerMyTosaAnalysisPass();
}
</code></pre>
<p>를 namespace mlir 안에 넣자.
그리고 main 함수에 아래 내용을 registerAllPasses(); 아래에 넣자.</p>
<pre><code>mlir::tosa::registerMyTosaAnalysisPass();
</code></pre>
<ol start="4">
<li>이제 빌드를 다시 진행하자. 빌드 디렉토리로 가서 ninja mlir-opt 로 빌드할 수 있음.</li>
<li>임의로 아래와 같은 테스트 파일을 만들자.</li>
</ol>
<pre><code>func.func @test_conv_too_large(%input: tensor&lt;1x28x28x32xf32&gt;, %weight: tensor&lt;16x5x5x32xf32&gt;, %bias: tensor&lt;16xf32&gt;) -&gt; tensor&lt;1x24x24x16xf32&gt; {
  // 5x5 커널이므로 에러가 발생해야 함
  %0 = &quot;tosa.conv2d&quot;(%input, %weight, %bias) {
    dilation = [1, 1],
    pad = [0, 0, 0, 0],
    stride = [1, 1]
  } : (tensor&lt;1x28x28x32xf32&gt;, tensor&lt;16x5x5x32xf32&gt;, tensor&lt;16xf32&gt;) -&gt; tensor&lt;1x24x24x16xf32&gt;
  return %0 : tensor&lt;1x24x24x16xf32&gt;
}
</code></pre>
<ol start="6">
<li>아래와 같은 커맨드로 수행 가능</li>
</ol>
<pre><code>./bin/mlir-opt --my-tosa-analysis test_tosa.mlir
</code></pre>
<p><img src="/blog/images/Capture-1.png" alt="TOSA 분석 결과"/></p>
<p>=====================================================================</p>
<p>물론 이건 테스트를 위한 쉬운 방법
더 좋고 일반적인 방법에 대해서는 다른 포스트에서 논의해 보겠음.</p></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"iP1VKKh5IpKVfa-WVjKWE\",\"c\":[\"\",\"posts\",\"mlir\",\"md-TosaSV\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-TosaSV\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:T777,"])</script><script>self.__next_f.push([1,"// MyTosaAnalysis.cpp\n#include \"mlir/Dialect/Tosa/IR/TosaOps.h\"\n#include \"mlir/Dialect/Func/IR/FuncOps.h\"  // func::FuncOp를 위해 필요\n#include \"mlir/IR/BuiltinTypes.h\"         // ShapedType을 위해 필요\n#include \"mlir/Pass/Pass.h\"\n\nusing namespace mlir;\n\nnamespace {\n// 1. PassWrapper의 두 번째 인자는 실제 구현될 베이스 클래스임.\nstruct MyTosaAnalysisPass \n    : public PassWrapper\u003cMyTosaAnalysisPass, OperationPass\u003cfunc::FuncOp\u003e\u003e {\n  \n  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MyTosaAnalysisPass)\n\n  // 최신 MLIR에서는 아래 함수들을 virtual로 인식시키기 위해 \n  // StringRef를 반환하는 오버라이딩이 필요.\n  StringRef getArgument() const final { return \"my-tosa-analysis\"; }\n  StringRef getDescription() const final { return \"TOSA Conv2D 커널 크기 정적 검증\"; }\n\n  void runOnOperation() override {\n    // getOperation()은 이제 func::FuncOp를 반환.\n    func::FuncOp func = getOperation();\n\n    func.walk([\u0026](tosa::Conv2DOp op) {\n      // getType() 뒤에 바로 .cast를 쓰는 것보다 \n      // llvm::dyn_cast 또는 llvm::cast를 사용하는 것이 더 안전함.\n      auto weightType = llvm::dyn_cast\u003cShapedType\u003e(op.getWeight().getType());\n      if (!weightType) return;\n\n      auto shape = weightType.getShape(); // [OC, H, W, IC]\n      \n      // TOSA Conv2D의 Weight는 보통 [OC, H, W, IC] 순서.\n      if (shape.size() \u003e= 3\\) {\n        int64_t h = shape[1];\n        int64_t w = shape[2];\n\n        if (h \u003e 3 || w \u003e 3\\) {\n          op.emitError() \u003c\u003c \"정적 검증 실패: 하드웨어 제약 조건 위반 (커널 \" \n                         \u003c\u003c h \u003c\u003c \"x\" \u003c\u003c w \u003c\u003c \" 미지원)\";\n          return signalPassFailure();\n        }\n      }\n    });\n  }\n};\n} // namespace\n\nnamespace mlir {\nnamespace tosa {\nvoid registerMyTosaAnalysisPass() {\n  PassRegistration\u003cMyTosaAnalysisPass\u003e();\n}\n} // namespace tosa\n} // namespace mlir\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR TOSA Static Analysis\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2026-01-07\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"MLIR TOSA Static Analysis 방법론\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"1) TOSA (Tensor Operator Set Architecture)란?\\nTOSA는 다양한 하드웨어 타겟(CPU, GPU, NPU)에서 추론을 수행하기 위해 설계된 표준 텐서 연산 집합임.\\nArm에서 처음 제안했으며, 현재는 MLIR의 핵심 Dialect로 포함되어 있음.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"목적은 상위 프레임워크(TensorFlow, PyTorch)와 하위 코드 생성(LLVM IR, 하드웨어 특화 IR) 사이의 안정적인 교량(Stable Bridge) 역할\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"특징은 아래와 같음\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"하드웨어 독립적: 특정 가속기에 치우치지 않는 범용적인 연산을 정의\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"양자화(Quantization) 최적화: 정수 연산 및 양자화 파라미터를 정교하게 다룸\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"낮은 복잡도: 약 100개 미만의 기본 연산으로 구성되어 백엔드 구현 부담을 줄임\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) TOSA 정적 오류 분석 패스 작성법\\nMLIR에서 \\\"정적 오류\\\"를 찾는 방법은 크게 두 가지\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"ODS 내장 Verifier: 각 Op의 타입, 랭크 등 구조적 정당성 체크\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Custom Analysis Pass: 특정 하드웨어 제약 조건 위반이나 데이터 흐름상의 논리 오류 검출\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"우리가 테스트 해볼것은\\nTOSA 연산 중 특정 하드웨어가 지원하지 않는 설정(예: 커널 사이즈 제한)을 정적으로 찾아내는 패스\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3) Pass 정의 (TableGen)\\n먼저 패스의 메타데이터를 정의\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"// MyTosaAnalysis.td\\ndef MyTosaAnalysis : Pass\u003c\\\"my-tosa-analysis\\\", \\\"mlir::func::FuncOp\\\"\u003e {\\n  let summary = \\\"TOSA 연산의 하드웨어 호환성을 정적으로 검토.\\\";\\n  let description = [{\\n    이 패스는 TOSA Conv2D 연산의 커널 크기가 3x3보다 큰 경우 에러를 발생시킴.\\n  }];\\n  let constructor = \\\"mlir::tosa::createMyTosaAnalysisPass()\\\";\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4) 분석 로직 구현 (C++)\\nwalk 함수를 사용해 IR을 순회하며 검사\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$e\"}]}],\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\",\"\\n\",\"$L28\",\"\\n\",\"$L29\"]}],\"$L2a\",\"$L2b\"]}]\n"])</script><script>self.__next_f.push([1,"2c:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\n:HL[\"/blog/images/Capture-1.png\",\"image\"]\nf:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"여기서 walk 함수는 MLIR에서 IR 계층 구조를 자동으로 순회(Traversal) 하는 핵심.\\nMLIR은 Module -\u003e Function -\u003e Block -\u003e Operation -\u003e Region 의 계층적(Nested) 구조.\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"walk이 없다면, 특정 Op(예: tosa.conv2d)를 찾기 위해 4~5중 for문을 직접 작성해야 함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"재귀적 순회를 자동화 함: 최상위 Op(예: 함수)에서 호출하면 그 안에 포함된 모든 하위 Op들을 DFS 방식으로 탐색\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"특정 타입을 필터링함: 템플릿 인자를 통해 내가 관심 있는 특정 Dialect의 Op만 골라서 콜백 함수를 실행할 수 있음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"보일러플레이트 제거: 반복문 관리, 반복자(Iterator) 무효화 등의 복잡한 처리를 내부적으로 해결\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n10:[\"$\",\"p\",null,{\"children\":\"여기서 walk를 사용한건 함수 내부에 tosa.conv2d 가 어디에 있든 (루프 안이든, 조건문 안이든) 상관없이 모두 찾아내어 검증하기 위함.\"}]\n11:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"llvm::dyn_cast 에 대해서\\n내가 궁금했던 부분은 MLIR인데 왜 llvm 소스를 썼는가임.\\nMLIR은 LLVM의 인프라 위에 구축된 프로젝트임.\"}],\"\\n\"]}]\n12:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이말인 즉슨 LLVM이 제공하는 사용자 정의 RTTI(Run-Time Type Information) 메커니즘을 공유\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"MLIR 소스 코드를 보면 mlir/Support/LLVM.h를 자주 포함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"즉, MLIR은 LLVM의 기초 유틸리티 모음인 LLVM Support Library에 깊게 의존\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"llvm::dyn_cast, llvm::cast, llvm::isa 등은 특정 클래스에 종속된 함수가 아니라, 템플릿 기반의 범용 유틸리티\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 템플릿들은 대상 객체가 특정한 규칙(인터페이스)만 지키고 있다면 어떤 타입이든 캐스팅할 수 있도록 설계\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n13:[\"$\",\"p\",null,{\"children\":\"가벼운 RTTI (Hand-rolled RTTI)\"}]\n14:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"C++ 표준의 dynamic_cast는 실행 성능이 느리고 바이너리 사이즈를 키우는 경향이 있음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM/MLIR은 표준 RTTI 대신 classof라는 정적 메서드를 사용하는 커스텀 RTTI를 직접 구현해서 씀\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"설계 구조의 핵심 (classof): 모든 MLIR Operation(예: tosa::Conv2DOp)이나 Type은 내부에 classof라는 정적 함수를 가짐\"}],\"\\n\"]}]\n15:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"// TableGen에 의해 자동 생성되는 코드의 개념적 모습\\nstruct Conv2DOp : public Op\u003cConv2DOp, ...\u003e {\\n  static bool classof(Operation *op) {\\n    // 이 Operation의 이름이 \\\"tosa.conv2d\\\"인지 확인\\n    return op-\u003egetName().getStringRef() == \\\"tosa.conv2d\\\";\\n  }\\n};\\n\"}]}]\n16:[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"llvm::dyn_cast\u003cT\u003e(obj)\"}],\"를 호출하면, 템플릿 내부에서 T::classof(obj)를 호출\"]}]\n17:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"\\\"이 객체가 정말 T 타입으로 변환 가능한가?\\\"를 체크\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"맞다면 포인터를 변환해주고, 틀리다면 nullptr을 반환\"}],\"\\n\"]}]\n18:[\"$\",\"p\",null,{\"children\":\"포인터 래퍼(Pointer Wrapper) 설계\"}]\n19:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"tosa::Conv2DOp는 실제 거대한 객체가 아니라, Operation* 포인터 하나를 들고 있는 아주 가벼운 래퍼(Wrapper) 클래"])</script><script>self.__next_f.push([1,"스\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"구조적으로 tosa::Conv2DOp 객체를 복사해도 실제로는 포인터 하나만 복사됩니다. (값 복사가 아닌 참조 복사처럼 동작)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"유연성 측면에서 이러한 설계 덕분에 Operation*라는 범용 포인터를 하드웨어 제약 조건이 담긴 tosa::Conv2DOp라는 구체적인 클래스로 아주 가볍고 빠르게 재해석할 수 있음\"}],\"\\n\"]}]\n1a:[\"$\",\"p\",null,{\"children\":\"Dialect 간의 확장성 (Extensibility)\"}]\n1b:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"MLIR은 수많은 Dialect(TOSA, Linalg, Affine 등)가 공존\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이들이 모두 dyn_cast를 쓸 수 있는 이유\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"모든 연산은 결국 최상위 부모인 \",[\"$\",\"strong\",null,{\"children\":\"mlir::Operation\"}],\"으로 통하기 때문\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"각 Dialect는 TableGen을 통해 자신만의 **Unique ID(또는 이름)**를 가짐\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"llvm::dyn_cast는 이 ID나 이름을 대조하여 캐스팅 여부를 판단\"}],\"\\n\"]}]\n1c:[\"$\",\"p\",null,{\"children\":\"5) 실제 테스트\"}]\n1d:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"4)에 언급된 소스를 llvm-project/mlir/lib/Dialect/Tosa/Transforms/ 에 MyTOsaAnalysis.cpp 같은 파일로 저장하자.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"mlir/lib/Dialect/Tosa/Transforms/CMakeLists.txt 를 열어서 add_mlir_dialect_library 부분에 MyTosaAnalysis.cpp를 추가하자\"}],\"\\n\"]}]\n1e:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"add_mlir_dialect_library(MLIRTosaTransforms\\n  TosaDecomposeConv2D.cpp\\n  TosaInferShapes.cpp\\n  MyTosaAnalysis.cpp  # \u003c-- 추가\\n  ...\\n)\\n\"}]}]\n1f:[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"mlir/tools/mlir-opt/mlir-opt.cpp 에\"}],\"\\n\"]}]\n20:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"namespace tosa {\\n  void registerMyTosaAnalysisPass();\\n}\\n\"}]}]\n21:[\"$\",\"p\",null,{\"children\":\"를 namespace mlir 안에 넣자.\\n그리고 main 함수에 아래 내용을 registerAllPasses(); 아래에 넣자.\"}]\n22:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"mlir::tosa::registerMyTosaAnalysisPass();\\n\"}]}]\n23:[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이제 빌드를 다시 진행하자. 빌드 디렉토리로 가서 ninja mlir-opt 로 빌드할 수 있음.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"임의로 아래와 같은 테스트 파일을 만들자.\"}],\"\\n\"]}]\n24:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"func.func @test_conv_too_large(%input: tensor\u003c1x28x28x32xf32\u003e, %weight: tensor\u003c16x5x5x32xf32\u003e, %bias: tensor\u003c16xf32\u003e) -\u003e tensor\u003c1x24x24x16xf32\u003e {\\n  // 5x5 커널이므로 에러가 발생해야 함\\n  %0 = \\\"tosa.conv2d\\\"(%input, %weight, %bias) {\\n    dilation = [1, 1],\\n    pad = [0, 0, 0, 0],\\n    stride = [1, 1]\\n  } : (tensor\u003c1x28x28x32xf32\u003e, tensor\u003c16x5x5x32xf32\u003e, tensor\u003c16xf32\u003e) -\u003e tensor\u003c1x24x24x16xf32\u003e\\n  return %0 : tensor\u003c1x24x24x16xf32\u003e\\n}\\n\"}]}]\n25:[\"$\",\"ol\",null,{\"start\":\"6\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"아래와 같은 커맨드로 수행 가능\"}],\"\\n\"]}]\n26:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"./bin/mlir-opt --my-tosa-analysis test_tosa.mlir\\n\"}]}]\n27:[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/blog/images/Capture-1.png\",\"alt\":\"TOSA 분석 결과\"}]}]\n28:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n29:[\"$\",\"p\",null,{\"children\":\"물론 이건 테스트를 위한 쉬운 방법\\n더 좋고 일반적인 방법에 대해서는 다른 포스트에서 논의해 보겠음.\"}]\n2a:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n2b:[\"$\",\"$L2c\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"2d:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR TOSA Static Analysis - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"MLIR TOSA Static Analysis 방법론\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L2d\",\"3\",{}]]\n8:null\n"])</script></body></html>