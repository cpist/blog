1:"$Sreact.fragment"
2:I[22016,["/blog/_next/static/chunks/796e69ae18b2784c.js"],""]
3:I[39756,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
4:I[37457,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
6:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"ViewportBoundary"]
b:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"MetadataBoundary"]
d:I[68027,[],"default"]
:HL["/blog/_next/static/chunks/743a8f8bdb738f7f.css","style"]
:HC["/",""]
:HL["https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css","style",{"crossOrigin":"anonymous","integrity":"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"}]
0:{"P":null,"b":"TmeFl9XvlrdQDoLIMxpL3","c":["","posts","mlir","md-TosaSV",""],"q":"","i":false,"f":[[["",{"children":["posts",{"children":[["slug","mlir/md-TosaSV","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/blog/_next/static/chunks/743a8f8bdb738f7f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","script","script-0",{"src":"/blog/_next/static/chunks/796e69ae18b2784c.js","async":true,"nonce":"$undefined"}]],["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":["$","link",null,{"rel":"stylesheet","href":"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css","integrity":"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu","crossOrigin":"anonymous"}]}],["$","body",null,{"children":["$","main",null,{"children":[["$","header",null,{"style":{"display":"flex","justifyContent":"space-between","alignItems":"baseline","gap":12},"children":[["$","h1",null,{"style":{"margin":"8px 0"},"children":["$","$L2",null,{"href":"/","style":{"textDecoration":"none"},"children":"CPIST's blog"}]}],["$","nav",null,{"style":{"display":"flex","gap":12},"children":["$","$L2",null,{"href":"/posts","children":"Posts"}]}]]}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"12px 0 24px"}}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","footer",null,{"style":{"marginTop":48,"paddingTop":16,"borderTop":"1px solid #eee","color":"#666"},"children":["© ",2026," CPIST's blog"]}]]}]}]]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",[["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true,"nonce":"$undefined"}]],["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],null]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:T775,// MyTosaAnalysis.cpp
#include "mlir/Dialect/Tosa/IR/TosaOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"  // func::FuncOp를 위해 필요
#include "mlir/IR/BuiltinTypes.h"         // ShapedType을 위해 필요
#include "mlir/Pass/Pass.h"

using namespace mlir;

namespace {
// 1. PassWrapper의 두 번째 인자는 실제 구현될 베이스 클래스임.
struct MyTosaAnalysisPass 
    : public PassWrapper<MyTosaAnalysisPass, OperationPass<func::FuncOp>> {
  
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MyTosaAnalysisPass)

  // 최신 MLIR에서는 아래 함수들을 virtual로 인식시키기 위해 
  // StringRef를 반환하는 오버라이딩이 필요.
  StringRef getArgument() const final { return "my-tosa-analysis"; }
  StringRef getDescription() const final { return "TOSA Conv2D 커널 크기 정적 검증"; }

  void runOnOperation() override {
    // getOperation()은 이제 func::FuncOp를 반환.
    func::FuncOp func = getOperation();

    func.walk([&](tosa::Conv2DOp op) {
      // getType() 뒤에 바로 .cast를 쓰는 것보다 
      // llvm::dyn_cast 또는 llvm::cast를 사용하는 것이 더 안전함.
      auto weightType = llvm::dyn_cast<ShapedType>(op.getWeight().getType());
      if (!weightType) return;

      auto shape = weightType.getShape(); // [OC, H, W, IC]
      
      // TOSA Conv2D의 Weight는 보통 [OC, H, W, IC] 순서.
      if (shape.size() >= 3) {
        int64_t h = shape[1];
        int64_t w = shape[2];

        if (h > 3 || w > 3) {
          op.emitError() << "정적 검증 실패: 하드웨어 제약 조건 위반 (커널 " 
                         << h << "x" << w << " 미지원)";
          return signalPassFailure();
        }
      }
    });
  }
};
} // namespace

namespace mlir {
namespace tosa {
void registerMyTosaAnalysisPass() {
  PassRegistration<MyTosaAnalysisPass>();
}
} // namespace tosa
} // namespace mlir
5:["$","article",null,{"style":{"maxWidth":"800px","margin":"0 auto","padding":"20px"},"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/mlir","style":{"textDecoration":"none"},"children":["/","mlir"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR TOSA Static Analysis"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2026-01-07"}],["$","p",null,{"style":{"color":"#333","fontStyle":"italic"},"children":"MLIR TOSA Static Analysis 방법론"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","style":{"lineHeight":1.6},"children":[["$","ol",null,{"children":["\n",["$","li",null,{"children":"TOSA (Tensor Operator Set Architecture)란?\nTOSA는 다양한 하드웨어 타겟(CPU, GPU, NPU)에서 추론을 수행하기 위해 설계된 표준 텐서 연산 집합임.\nArm에서 처음 제안했으며, 현재는 MLIR의 핵심 Dialect로 포함되어 있음."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"목적은 상위 프레임워크(TensorFlow, PyTorch)와 하위 코드 생성(LLVM IR, 하드웨어 특화 IR) 사이의 안정적인 교량(Stable Bridge) 역할"}],"\n",["$","li",null,{"children":["특징은 아래와 같음","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"하드웨어 독립적: 특정 가속기에 치우치지 않는 범용적인 연산을 정의"}],"\n",["$","li",null,{"children":"양자화(Quantization) 최적화: 정수 연산 및 양자화 파라미터를 정교하게 다룸"}],"\n",["$","li",null,{"children":"낮은 복잡도: 약 100개 미만의 기본 연산으로 구성되어 백엔드 구현 부담을 줄임"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"TOSA 정적 오류 분석 패스 작성법\nMLIR에서 \"정적 오류\"를 찾는 방법은 크게 두 가지"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"ODS 내장 Verifier: 각 Op의 타입, 랭크 등 구조적 정당성 체크"}],"\n",["$","li",null,{"children":"Custom Analysis Pass: 특정 하드웨어 제약 조건 위반이나 데이터 흐름상의 논리 오류 검출"}],"\n"]}],"\n",["$","p",null,{"children":"우리가 테스트 해볼것은\nTOSA 연산 중 특정 하드웨어가 지원하지 않는 설정(예: 커널 사이즈 제한)을 정적으로 찾아내는 패스"}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"Pass 정의 (TableGen)\n먼저 패스의 메타데이터를 정의"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"// MyTosaAnalysis.td\ndef MyTosaAnalysis : Pass<\"my-tosa-analysis\", \"mlir::func::FuncOp\"> {\n  let summary = \"TOSA 연산의 하드웨어 호환성을 정적으로 검토.\";\n  let description = [{\n    이 패스는 TOSA Conv2D 연산의 커널 크기가 3x3보다 큰 경우 에러를 발생시킴.\n  }];\n  let constructor = \"mlir::tosa::createMyTosaAnalysisPass()\";\n}\n"}]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"분석 로직 구현 (C++)\nwalk 함수를 사용해 IR을 순회하며 검사"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$e"}]}],"\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27","\n","$L28","\n","$L29"]}],"$L2a","$L2b"]}]
2c:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
:HL["/blog/images/Capture-1.png","image"]
f:["$","ul",null,{"children":["\n",["$","li",null,{"children":["여기서 walk 함수는 MLIR에서 IR 계층 구조를 자동으로 순회(Traversal) 하는 핵심.\nMLIR은 Module -> Function -> Block -> Operation -> Region 의 계층적(Nested) 구조.","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"walk이 없다면, 특정 Op(예: tosa.conv2d)를 찾기 위해 4~5중 for문을 직접 작성해야 함"}],"\n",["$","li",null,{"children":"재귀적 순회를 자동화 함: 최상위 Op(예: 함수)에서 호출하면 그 안에 포함된 모든 하위 Op들을 DFS 방식으로 탐색"}],"\n",["$","li",null,{"children":"특정 타입을 필터링함: 템플릿 인자를 통해 내가 관심 있는 특정 Dialect의 Op만 골라서 콜백 함수를 실행할 수 있음"}],"\n",["$","li",null,{"children":"보일러플레이트 제거: 반복문 관리, 반복자(Iterator) 무효화 등의 복잡한 처리를 내부적으로 해결"}],"\n"]}],"\n"]}],"\n"]}]
10:["$","p",null,{"children":"여기서 walk를 사용한건 함수 내부에 tosa.conv2d 가 어디에 있든 (루프 안이든, 조건문 안이든) 상관없이 모두 찾아내어 검증하기 위함."}]
11:["$","ul",null,{"children":["\n",["$","li",null,{"children":"llvm::dyn_cast 에 대해서\n내가 궁금했던 부분은 MLIR인데 왜 llvm 소스를 썼는가임.\nMLIR은 LLVM의 인프라 위에 구축된 프로젝트임."}],"\n"]}]
12:["$","ul",null,{"children":["\n",["$","li",null,{"children":"이말인 즉슨 LLVM이 제공하는 사용자 정의 RTTI(Run-Time Type Information) 메커니즘을 공유"}],"\n",["$","li",null,{"children":["MLIR 소스 코드를 보면 mlir/Support/LLVM.h를 자주 포함","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"즉, MLIR은 LLVM의 기초 유틸리티 모음인 LLVM Support Library에 깊게 의존"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["llvm::dyn_cast, llvm::cast, llvm::isa 등은 특정 클래스에 종속된 함수가 아니라, 템플릿 기반의 범용 유틸리티","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이 템플릿들은 대상 객체가 특정한 규칙(인터페이스)만 지키고 있다면 어떤 타입이든 캐스팅할 수 있도록 설계"}],"\n"]}],"\n"]}],"\n"]}]
13:["$","p",null,{"children":"가벼운 RTTI (Hand-rolled RTTI)"}]
14:["$","ul",null,{"children":["\n",["$","li",null,{"children":"C++ 표준의 dynamic_cast는 실행 성능이 느리고 바이너리 사이즈를 키우는 경향이 있음"}],"\n",["$","li",null,{"children":"LLVM/MLIR은 표준 RTTI 대신 classof라는 정적 메서드를 사용하는 커스텀 RTTI를 직접 구현해서 씀"}],"\n",["$","li",null,{"children":"설계 구조의 핵심 (classof): 모든 MLIR Operation(예: tosa::Conv2DOp)이나 Type은 내부에 classof라는 정적 함수를 가짐"}],"\n"]}]
15:["$","pre",null,{"children":["$","code",null,{"children":"// TableGen에 의해 자동 생성되는 코드의 개념적 모습\nstruct Conv2DOp : public Op<Conv2DOp, ...> {\n  static bool classof(Operation *op) {\n    // 이 Operation의 이름이 \"tosa.conv2d\"인지 확인\n    return op->getName().getStringRef() == \"tosa.conv2d\";\n  }\n};\n"}]}]
16:["$","p",null,{"children":[["$","code",null,{"children":"llvm::dyn_cast<T>(obj)"}],"를 호출하면, 템플릿 내부에서 T::classof(obj)를 호출"]}]
17:["$","ul",null,{"children":["\n",["$","li",null,{"children":"\"이 객체가 정말 T 타입으로 변환 가능한가?\"를 체크"}],"\n",["$","li",null,{"children":"맞다면 포인터를 변환해주고, 틀리다면 nullptr을 반환"}],"\n"]}]
18:["$","p",null,{"children":"포인터 래퍼(Pointer Wrapper) 설계"}]
19:["$","ul",null,{"children":["\n",["$","li",null,{"children":"tosa::Conv2DOp는 실제 거대한 객체가 아니라, Operation* 포인터 하나를 들고 있는 아주 가벼운 래퍼(Wrapper) 클래스"}],"\n",["$","li",null,{"children":"구조적으로 tosa::Conv2DOp 객체를 복사해도 실제로는 포인터 하나만 복사됩니다. (값 복사가 아닌 참조 복사처럼 동작)"}],"\n",["$","li",null,{"children":"유연성 측면에서 이러한 설계 덕분에 Operation*라는 범용 포인터를 하드웨어 제약 조건이 담긴 tosa::Conv2DOp라는 구체적인 클래스로 아주 가볍고 빠르게 재해석할 수 있음"}],"\n"]}]
1a:["$","p",null,{"children":"Dialect 간의 확장성 (Extensibility)"}]
1b:["$","ul",null,{"children":["\n",["$","li",null,{"children":["MLIR은 수많은 Dialect(TOSA, Linalg, Affine 등)가 공존","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"이들이 모두 dyn_cast를 쓸 수 있는 이유"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["모든 연산은 결국 최상위 부모인 ",["$","strong",null,{"children":"mlir::Operation"}],"으로 통하기 때문"]}],"\n",["$","li",null,{"children":"각 Dialect는 TableGen을 통해 자신만의 **Unique ID(또는 이름)**를 가짐"}],"\n",["$","li",null,{"children":"llvm::dyn_cast는 이 ID나 이름을 대조하여 캐스팅 여부를 판단"}],"\n"]}]
1c:["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"실제 테스트"}],"\n"]}]
1d:["$","ol",null,{"children":["\n",["$","li",null,{"children":"4)에 언급된 소스를 llvm-project/mlir/lib/Dialect/Tosa/Transforms/ 에 MyTOsaAnalysis.cpp 같은 파일로 저장하자."}],"\n",["$","li",null,{"children":"mlir/lib/Dialect/Tosa/Transforms/CMakeLists.txt 를 열어서 add_mlir_dialect_library 부분에 MyTosaAnalysis.cpp를 추가하자"}],"\n"]}]
1e:["$","pre",null,{"children":["$","code",null,{"children":"add_mlir_dialect_library(MLIRTosaTransforms\n  TosaDecomposeConv2D.cpp\n  TosaInferShapes.cpp\n  MyTosaAnalysis.cpp  # <-- 추가\n  ...\n)\n"}]}]
1f:["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"mlir/tools/mlir-opt/mlir-opt.cpp 에"}],"\n"]}]
20:["$","pre",null,{"children":["$","code",null,{"children":"namespace tosa {\n  void registerMyTosaAnalysisPass();\n}\n"}]}]
21:["$","p",null,{"children":"를 namespace mlir 안에 넣자.\n그리고 main 함수에 아래 내용을 registerAllPasses(); 아래에 넣자."}]
22:["$","pre",null,{"children":["$","code",null,{"children":"mlir::tosa::registerMyTosaAnalysisPass();\n"}]}]
23:["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"이제 빌드를 다시 진행하자. 빌드 디렉토리로 가서 ninja mlir-opt 로 빌드할 수 있음."}],"\n",["$","li",null,{"children":"임의로 아래와 같은 테스트 파일을 만들자."}],"\n"]}]
24:["$","pre",null,{"children":["$","code",null,{"children":"func.func @test_conv_too_large(%input: tensor<1x28x28x32xf32>, %weight: tensor<16x5x5x32xf32>, %bias: tensor<16xf32>) -> tensor<1x24x24x16xf32> {\n  // 5x5 커널이므로 에러가 발생해야 함\n  %0 = \"tosa.conv2d\"(%input, %weight, %bias) {\n    dilation = [1, 1],\n    pad = [0, 0, 0, 0],\n    stride = [1, 1]\n  } : (tensor<1x28x28x32xf32>, tensor<16x5x5x32xf32>, tensor<16xf32>) -> tensor<1x24x24x16xf32>\n  return %0 : tensor<1x24x24x16xf32>\n}\n"}]}]
25:["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"아래와 같은 커맨드로 수행 가능"}],"\n"]}]
26:["$","pre",null,{"children":["$","code",null,{"children":"./bin/mlir-opt --my-tosa-analysis test_tosa.mlir\n"}]}]
27:["$","p",null,{"children":["$","img",null,{"src":"/blog/images/Capture-1.png","alt":"TOSA 분석 결과"}]}]
28:["$","p",null,{"children":"====================================================================="}]
29:["$","p",null,{"children":"물론 이건 테스트를 위한 쉬운 방법\n더 좋고 일반적인 방법에 대해서는 다른 포스트에서 논의해 보겠음."}]
2a:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
2b:["$","$L2c",null,{}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
2d:I[27201,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"IconMark"]
c:[["$","title","0",{"children":"MLIR TOSA Static Analysis - CPIST's blog"}],["$","meta","1",{"name":"description","content":"MLIR TOSA Static Analysis 방법론"}],["$","link","2",{"rel":"icon","href":"/blog/favicon.ico?favicon.0b3bf435.ico","sizes":"256x256","type":"image/x-icon"}],["$","$L2d","3",{}]]
8:null
