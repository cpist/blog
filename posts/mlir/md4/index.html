<!DOCTYPE html><!--5MI_6nhqJhNRlWoyIKnab--><html lang="ko"><head><meta charSet="utf-8"/><link rel="preconnect" href="/" crossorigin=""/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="stylesheet" href="/blog/_next/static/chunks/4057cc9dbcc744c0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR Toy Tutorial Ch 4 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Writing generic dialect-independent transformations with Interfaces. Here we will show how to plug dialect specific information into generic transformations like shape inference and inlining."/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article style="max-width:800px;margin:0 auto;padding:20px"><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Toy Tutorial Ch 4 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-11-02</div><p style="color:#333;font-style:italic">Writing generic dialect-independent transformations with Interfaces. Here we will show how to plug dialect specific information into generic transformations like shape inference and inlining.</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose" style="line-height:1.6"><ol>
<li>다 똑같은데 왜 새로 짜야 하는가
어떤 dialect 이든 함수 인라이닝, shape 추론, 단순 최적화 로직을 씀</li>
</ol>
<ul>
<li>그렇다는 것은 Toy용 인라이너, 또 다른 dialect용 인라이너.. 이런걸 계속 코드 복붙하는건 별로이지 않겠는가.</li>
</ul>
<ol start="2">
<li>
<p>Interface를 쓰자.
Interface는 콘센트 규격 같은 것임.</p>
<ul>
<li>MLIR이 제공하는 범용 알고리즘 (inliner, shape 추론)</li>
<li>Dialect는 자기 콘센트가 어떻게 생겼는지만 알려주면, MLIR이 알아서 꽂아서 사용하는 것</li>
</ul>
</li>
<li>
<p>Function inlining</p>
</li>
</ol>
<pre><code>toy.generic_call @multiply_transpose(...)

룰 inline 해서

toy.transpose
toy.mul

와 같이 직접 펼치는 것
</code></pre>
<pre><code>struct ToyInlinerInterface : public DialectInlinerInterface {
  bool isLegalToInline(...) const final { return true; }
};
</code></pre>
<p>이런식으로 DialectInlinerInterface를 구현하여 Toy에서는 다 인라인 해도 안전하다는 것을 보여줌.</p>
<p>이건 함수다 / 이건 호출이다를 표시하기
inliner가 묻는 내용임.</p>
<p>그래서</p>
<ul>
<li>함수는 Interface로 CallableOpInterface를</li>
<li>호출은 Interface로 CallOpInterface 를 붙여줌.</li>
<li>toy.func, toy.generic_call 에 각각 추가함.</li>
</ul>
<p>근데 inlining 이 잘 안될수가 있음 - 타입이 살짝 다르기 때문에</p>
<pre><code>call: tensor&lt;2x3xf64&gt;
func arg: tensor&lt;*xf64&gt;
</code></pre>
<p>MLIR inliner로서는 중간에 cast가 필요하다고 생각함.</p>
<ol start="4">
<li>그래서 toy.cast 가 있는 것
toy.cast는 데이터는 그대로, 모양(shape) 만 바꾸는 것.</li>
</ol>
<pre><code>%2 = toy.cast %1 : tensor&lt;2x3xf64&gt; to tensor&lt;*xf64&gt;

그리고 MLIR에 알림.

Operation *materializeCallConversion(...) {
  return CastOp::create(...);
}
</code></pre>
<p>의미는 타입이 안 맞으면 내가 cast를 만들어 주겠다는것</p>
<ul>
<li>inliner 가 성공하게 된다.</li>
</ul>
<ol start="5">
<li>Shape inference
모든 함수가 main에 inline 되었지만, 아직도 이런게 남음.</li>
</ol>
<pre><code>tensor&lt;*xf64&gt;
</code></pre>
<ul>
<li>여기서 Interface는 각 op가 자기 결과 shape 계산법을 알고 있게 하는 것임.</li>
</ul>
<pre><code>OpInterface&lt;&quot;ShapeInference&quot;&gt;
  void inferShapes();

void MulOp::inferShapes() {
  getResult().setType(getLhs().getType());
}
</code></pre>
<p>이를 통해 곱셈 결과 shape는 입력과 같다는게 명확해짐.</p>
<ol start="6">
<li>정리해 보자면 Shape Inference Pass는
(1) 아직 shape 모르는 op 들을 모아서 리스트
(2) 입력 shape 다 아는 op를 하나 고름
(3) inferShapes() 를 호출
(4) 결과 shape을 확정 -&gt; 다음 op 가능
(5) 반복 진행</li>
</ol>
<p>만약 interface 가 없다면?
너는 shape 추론을 못하고 -&gt; 에러로</p>
<p>결과적으로</p>
<pre><code>%2 = toy.mul %1, %1 : tensor&lt;*xf64&gt;

에서

%2 = toy.mul %1, %1 : tensor&lt;3x2xf64&gt;

로 된다.
</code></pre>
<p>컴파일러가 shape을 완벽하게 이해하고, 코드 생성을 가능하게 한다.</p>
<p>=====================================================================</p>
<p>정리해 보자면</p>
<ul>
<li>Interface는 이 op/dialect는 이런 능력이 있다는 것을<!-- -->
<ul>
<li>Dialect Interface 는 dialect의 전체 성질</li>
<li>Op Interface는 개별 연산 성질</li>
</ul>
</li>
<li>Inliner는 인터페이스만 보고 함수 인라이닝</li>
<li>ShapeInference는 op 스스로 shape를 계산</li>
</ul></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n:HC[\"/\",\"\"]\n:HL[\"/blog/_next/static/chunks/4057cc9dbcc744c0.css\",\"style\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"5MI-6nhqJhNRlWoyIKnab\",\"c\":[\"\",\"posts\",\"mlir\",\"md4\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md4\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/4057cc9dbcc744c0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"style\":{\"maxWidth\":\"800px\",\"margin\":\"0 auto\",\"padding\":\"20px\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Toy Tutorial Ch 4 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-11-02\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\",\"fontStyle\":\"italic\"},\"children\":\"Writing generic dialect-independent transformations with Interfaces. Here we will show how to plug dialect specific information into generic transformations like shape inference and inlining.\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"style\":{\"lineHeight\":1.6},\"children\":[[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"다 똑같은데 왜 새로 짜야 하는가\\n어떤 dialect 이든 함수 인라이닝, shape 추론, 단순 최적화 로직을 씀\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"그렇다는 것은 Toy용 인라이너, 또 다른 dialect용 인라이너.. 이런걸 계속 코드 복붙하는건 별로이지 않겠는가.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"Interface를 쓰자.\\nInterface는 콘센트 규격 같은 것임.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MLIR이 제공하는 범용 알고리즘 (inliner, shape 추론)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Dialect는 자기 콘센트가 어떻게 생겼는지만 알려주면, MLIR이 알아서 꽂아서 사용하는 것\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"Function inlining\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"toy.generic_call @multiply_transpose(...)\\n\\n룰 inline 해서\\n\\ntoy.transpose\\ntoy.mul\\n\\n와 같이 직접 펼치는 것\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"struct ToyInlinerInterface : public DialectInlinerInterface {\\n  bool isLegalToInline(...) const final { return true; }\\n};\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이런식으로 DialectInlinerInterface를 구현하여 Toy에서는 다 인라인 해도 안전하다는 것을 보여줌.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이건 함수다 / 이건 호출이다를 표시하기\\ninliner가 묻는 내용임.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"그래서\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"함수는 Interface로 CallableOpInterface를\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"호출은 Interface로 CallOpInterface 를 붙여줌.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"toy.func, toy.generic_call 에 각각 추가함.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"근데 inlining 이 잘 안될수가 있음 - 타입이 살짝 다르기 때문에\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"call: tensor\u003c2x3xf64\u003e\\nfunc arg: tensor\u003c*xf64\u003e\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"MLIR inliner로서는 중간에 cast가 필요하다고 생각함.\"}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"그래서 toy.cast 가 있는 것\\ntoy.cast는 데이터는 그대로, 모양(shape) 만 바꾸는 것.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%2 = toy.cast %1 : tensor\u003c2x3xf64\u003e to tensor\u003c*xf64\u003e\\n\\n그리고 MLIR에 알림.\\n\\nOperation *materializeCallConversion(...) {\\n  return CastOp::create(...);\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"의미는 타입이 안 맞으면 내가 cast를 만들어 주겠다는것\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"inliner 가 성공하게 된다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"5\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Shape inference\\n모든 함수가 main에 inline 되었지만, 아직도 이런게 남음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"tensor\u003c*xf64\u003e\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"여기서 Interface는 각 op가 자기 결과 shape 계산법을 알고 있게 하는 것임.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"OpInterface\u003c\\\"ShapeInference\\\"\u003e\\n  void inferShapes();\\n\\nvoid MulOp::inferShapes() {\\n  getResult().setType(getLhs().getType());\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이를 통해 곱셈 결과 shape는 입력과 같다는게 명확해짐.\"}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"6\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"정리해 보자면 Shape Inference Pass는\\n(1) 아직 shape 모르는 op 들을 모아서 리스트\\n(2) 입력 shape 다 아는 op를 하나 고름\\n(3) inferShapes() 를 호출\\n(4) 결과 shape을 확정 -\u003e 다음 op 가능\\n(5) 반복 진행\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"만약 interface 가 없다면?\\n너는 shape 추론을 못하고 -\u003e 에러로\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"결과적으로\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%2 = toy.mul %1, %1 : tensor\u003c*xf64\u003e\\n\\n에서\\n\\n%2 = toy.mul %1, %1 : tensor\u003c3x2xf64\u003e\\n\\n로 된다.\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"컴파일러가 shape을 완벽하게 이해하고, 코드 생성을 가능하게 한다.\"}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\"]}],\"$L11\",\"$L12\"]}]\n"])</script><script>self.__next_f.push([1,"13:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\nf:[\"$\",\"p\",null,{\"children\":\"정리해 보자면\"}]\n10:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Interface는 이 op/dialect는 이런 능력이 있다는 것을\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Dialect Interface 는 dialect의 전체 성질\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Op Interface는 개별 연산 성질\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Inliner는 인터페이스만 보고 함수 인라이닝\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"ShapeInference는 op 스스로 shape를 계산\"}],\"\\n\"]}]\n11:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n12:[\"$\",\"$L13\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"14:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Toy Tutorial Ch 4 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Writing generic dialect-independent transformations with Interfaces. Here we will show how to plug dialect specific information into generic transformations like shape inference and inlining.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L14\",\"3\",{}]]\n8:null\n"])</script></body></html>