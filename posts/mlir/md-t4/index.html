<!DOCTYPE html><!--G_vJ8TDfEmWLUljcPMSIZ--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/cbd55ab9639e1e66.js"/><script src="/blog/_next/static/chunks/8c4bb65ca9f95eb5.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-8ff2f6efb1e78309.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><title>MLIR Transform Tutorial Ch 4 에 대하여 - CPIST&#x27;s blog</title><meta name="description" content="Matching Payload with Transform Operations"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/mlir" style="text-decoration:none">/<!-- -->mlir</a></div><h2 style="margin-top:0">MLIR Transform Tutorial Ch 4 에 대하여</h2><div style="color:#666;margin-bottom:18px">2025-11-30</div><p style="color:#333">Matching Payload with Transform Operations</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><ol>
<li>Transform Dialect 안에서 어디를 고칠지를 직접 찾는 과정</li>
</ol>
<ul>
<li>매칭(match) 로 타깃 연산을 발견하고</li>
<li>체인 매칭으로 관련된 연산을 묶고</li>
<li>커스텀 매처로 똑똑하게 조건을 정의하고</li>
<li>추론된 특성까지 판별함.</li>
</ul>
<ol start="2">
<li>왜 Match가 필요할까? (문제 제기)</li>
</ol>
<ul>
<li>이전까지는 matmul을 고쳐야 한다는 타깃을 외부(C++/옵션) 에서 지정했음</li>
<li>Transform dialect는 이미 주어진 핸들만 변형하는 것</li>
</ul>
<ul>
<li>이것의 문제점은</li>
</ul>
<ul>
<li>인터페이스가 2개 (C++ 그리고 transform)</li>
<li>이렇게 되면 자동화 / 재사용도 어려워지고</li>
<li>Transform dialect가 주도한다라는 느낌이 약해진다.</li>
</ul>
<ul>
<li>이를 위한 해결책이</li>
</ul>
<ul>
<li>Transform dialect 자체가 &quot;이 연산이 내가 찾던 그 연산인지&quot; 를 판단하게 하는 것이다.</li>
</ul>
<ol start="3">
<li>Match 연산의 기본 개념
Match 연산의 특징은 다음과 같음</li>
</ol>
<ul>
<li>payload IR을 변경하지 않음</li>
<li>조건이 안 맞으면 실패</li>
<li>다른 match 들과 조합이 가능</li>
</ul>
<p>즉 조건 검사 전용 transform op라고 할 수 있음.</p>
<pre><code>transform.match.operation_name %op [&quot;linalg.matmul&quot;]
</code></pre>
<p>즉, matmul이 아니면 실패라는 것이다.</p>
<ol start="4">
<li>Simple Match : 이름으로 찾는 과정
목표는 IR 전체에서</li>
</ol>
<ul>
<li>linalg.matmul</li>
<li>linalg.elementwise를 찾는 것이다</li>
</ul>
<p>방법은</p>
<ol>
<li>matcher named_sequence를 정의하거나</li>
<li>transform.collect_matching 으로 전부 수집하는 것.</li>
</ol>
<pre><code>%matmul = transform.collect_matching @match_matmul in %root
</code></pre>
<p>이 결과</p>
<ul>
<li>외부 인자 없이 transform script 만으로 원하는 연산들을 자동 발견 할 수 있음.</li>
</ul>
<pre><code>-debug-only=transform-matcher
</code></pre>
<p>이렇게 하면 왜 매칭을 실패했는지 로그로 확인이 가능함.</p>
<ol start="5">
<li>Chain Matching : 연관된 연산만 묶기</li>
</ol>
<p>일반적인 경우에서의 문제는</p>
<ul>
<li>matmul이 여러개이고</li>
<li>elementwise도 여러개이고</li>
<li>서로 관련 없는 연산까지 다 잡힌 다는 것</li>
</ul>
<pre><code>// 이런 패턴을 원하기에
matmul → elementwise(add) → elementwise(max)
</code></pre>
<ul>
<li>해결 전략은 아래와 같음</li>
</ul>
<ul>
<li>use-def 체인을 거꾸로 추적함</li>
<li>마지막 연산 부터 시작을 함</li>
</ul>
<pre><code>%middle = transform.get_producer_of_operand %last[0]
%matmul = transform.get_producer_of_operand %middle[0]
</code></pre>
<p>이 결과</p>
<ul>
<li>진짜로 연결된 3개 연산만 묶어서 반환을 하고</li>
<li>순서도 의미있게 보존을 함</li>
</ul>
<ol start="6">
<li>어떤 operand도 괜찮다.
기존에는</li>
</ol>
<pre><code>get_producer_of_operand %op[0]
</code></pre>
<ul>
<li>항상 0번 operand 라는 가정</li>
<li>하지만 max(a, b) vs max(b, a) 는 같지 않겠는가</li>
</ul>
<p>이를 해결하기 위해 Custom Match Op를 만드는 것이다
목표 지점은 operand 중 하나라도 조건을 만족하면 OK 라는 것이다.</p>
<p>새 연산은</p>
<pre><code>transform.match.my.has_operand_satisfying
</code></pre>
<p>이것이 동작하는 원리는</p>
<ul>
<li>payload op의 모든 operand를 순회하면서</li>
<li>각 operand에 대해<!-- -->
<ul>
<li>내부 matcher 들을 실행하고</li>
<li>하나라도 성공하면 체크를</li>
</ul>
</li>
<li>성공 할 경우<!-- -->
<ul>
<li>어떤 operand 였는지 (position)</li>
<li>매칭된 연산 handle을 반환함.</li>
</ul>
</li>
</ul>
<ul>
<li>핵심 포인트는</li>
</ul>
<ul>
<li>MatchOpInterface를 구현하고</li>
<li>payload는 절대 수정하지 않는 다는 것</li>
<li>실패는 silenceable failure로 처리함.</li>
</ul>
<pre><code>max(add(matmul, bias), 0)
max(0, add(matmul, bias))
</code></pre>
<p>이 덕분에 둘다 동일한 패턴으로 매칭이 가능하게 되는 것이다</p>
<ol start="7">
<li>Parameter는 transform 중에도 변하지 않는 값임.</li>
</ol>
<ul>
<li><code> %pos: !transform.param&lt;i32&gt;</code></li>
<li>operand 위치 같은 상수 정보</li>
<li>transform 전반에서 안전하게 사용이 가능함.
즉, 핸들(handle) != 파라미터(parameter)</li>
</ul>
<ol start="8">
<li>foreach_match : 미니 패턴리라이터</li>
</ol>
<pre><code>transform.foreach_match
  @matcher -&gt; @rewriter
</code></pre>
<ul>
<li>payload IR 전체 순회</li>
<li>matcher가 성공 할 때 마다</li>
<li>rewriter를 실행함
Transform dialect 만으로</li>
<li>&quot;패턴 매칭 + 액션&quot;</li>
<li>간단한 패턴 리라이터 완성</li>
</ul>
<ol start="9">
<li>진짜 강력한 매칭은 추론된 특성에 있음
예를 들어서</li>
</ol>
<ul>
<li>matmul이 linalg.matmul 이 아니라</li>
<li>linalg.generic 로 표현된 경우라면</li>
</ul>
<p>이를 해결하기 위해서는 이게 의미적으로 matmul 인가를 판단해야 함.
그렇다면 체크해야 하는 특성들을 아래와 같을 것이다.</p>
<ul>
<li>iterator rank = 3</li>
<li>입력 2개, 출력 1개</li>
<li>projected permutation access</li>
<li>body 가 mulf + addf</li>
<li>contraction dimension 분류 결과가 적절한지</li>
</ul>
<p>이건</p>
<ul>
<li>단순 attribute 비교는 X</li>
<li>분석 + 추론이 필요함.</li>
</ul>
<ol start="10">
<li>Structured Matchers의 위력
Transform dialect는 이미 제공하고 있음</li>
</ol>
<ul>
<li>match.structured.rank</li>
<li>match.structured.body</li>
<li>classify_contraction_dims</li>
<li>등등..</li>
</ul>
<p>이 덕분에</p>
<ul>
<li>복잡한 수학적 의미라던지</li>
<li>C++ matcher로 캡슐화를 하고</li>
<li>Transform script는 선언적으로 유지함</li>
</ul>
<p>Flow 를 정리해 보자면</p>
<ol>
<li>Transform 안에서 타깃을 직접 찾고</li>
<li>Match op = 조건 검사 전용 transform으로서</li>
<li>collect_matching으로 자동 발견하고</li>
<li>use-def 체인으로 연관된 연산을 묶고</li>
<li>커스텀 matcher로 유연성을 확보하고</li>
<li>parameter로 불변 정보를 전달하고</li>
<li>foreach_match로 패턴 리라이터를 구현하고</li>
<li>추론 기반 매칭으로 진짜 의미를 판별한다.</li>
</ol>
<p>=====================================================================</p>
<p>요약해 보자면 Transform dialect를 연산을 단순히 고치는 도구에서 패턴을 이해하고 판단하는 역할까지 진화시키는 과정을 학습하였다.</p></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2025<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/cbd55ab9639e1e66.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"G-vJ8TDfEmWLUljcPMSIZ\",\"c\":[\"\",\"posts\",\"mlir\",\"md-t4\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"mlir/md-t4\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2025,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/mlir\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"mlir\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR Transform Tutorial Ch 4 에 대하여\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-11-30\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Matching Payload with Transform Operations\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform Dialect 안에서 어디를 고칠지를 직접 찾는 과정\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"매칭(match) 로 타깃 연산을 발견하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"체인 매칭으로 관련된 연산을 묶고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"커스텀 매처로 똑똑하게 조건을 정의하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"추론된 특성까지 판별함.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"왜 Match가 필요할까? (문제 제기)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이전까지는 matmul을 고쳐야 한다는 타깃을 외부(C++/옵션) 에서 지정했음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform dialect는 이미 주어진 핸들만 변형하는 것\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이것의 문제점은\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"인터페이스가 2개 (C++ 그리고 transform)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이렇게 되면 자동화 / 재사용도 어려워지고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform dialect가 주도한다라는 느낌이 약해진다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"이를 위한 해결책이\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform dialect 자체가 \\\"이 연산이 내가 찾던 그 연산인지\\\" 를 판단하게 하는 것이다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Match 연산의 기본 개념\\nMatch 연산의 특징은 다음과 같음\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload IR을 변경하지 않음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"조건이 안 맞으면 실패\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다른 match 들과 조합이 가능\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"즉 조건 검사 전용 transform op라고 할 수 있음.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"transform.match.operation_name %op [\\\"linalg.matmul\\\"]\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"즉, matmul이 아니면 실패라는 것이다.\"}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Simple Match : 이름으로 찾는 과정\\n목표는 IR 전체에서\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"linalg.matmul\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"linalg.elementwise를 찾는 것이다\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"방법은\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"matcher named_sequence를 정의하거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform.collect_matching 으로 전부 수집하는 것.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%matmul = transform.collect_matching @match_matmul in %root\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이 결과\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"외부 인자 없이 transform script 만으로 원하는 연산들을 자동 발견 할 수 있음.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"-debug-only=transform-matcher\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이렇게 하면 왜 매칭을 실패했는지 로그로 확인이 가능함.\"}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"5\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Chain Matching : 연관된 연산만 묶기\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"일반적인 경우에서의 문제는\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"matmul이 여러개이고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"elementwise도 여러개이고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"서로 관련 없는 연산까지 다 잡힌 다는 것\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"// 이런 패턴을 원하기에\\nmatmul → elementwise(add) → elementwise(max)\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"해결 전략은 아래와 같음\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"use-def 체인을 거꾸로 추적함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"마지막 연산 부터 시작을 함\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"%middle = transform.get_producer_of_operand %last[0]\\n%matmul = transform.get_producer_of_operand %middle[0]\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이 결과\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"진짜로 연결된 3개 연산만 묶어서 반환을 하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"순서도 의미있게 보존을 함\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"6\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"어떤 operand도 괜찮다.\\n기존에는\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"get_producer_of_operand %op[0]\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"항상 0번 operand 라는 가정\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"하지만 max(a, b) vs max(b, a) 는 같지 않겠는가\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이를 해결하기 위해 Custom Match Op를 만드는 것이다\\n목표 지점은 operand 중 하나라도 조건을 만족하면 OK 라는 것이다.\"}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\",\"\\n\",\"$L28\"]}]]}]\n"])</script><script>self.__next_f.push([1,"e:[\"$\",\"p\",null,{\"children\":\"새 연산은\"}]\nf:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"transform.match.my.has_operand_satisfying\\n\"}]}]\n10:[\"$\",\"p\",null,{\"children\":\"이것이 동작하는 원리는\"}]\n11:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload op의 모든 operand를 순회하면서\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"각 operand에 대해\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"내부 matcher 들을 실행하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"하나라도 성공하면 체크를\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"성공 할 경우\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"어떤 operand 였는지 (position)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"매칭된 연산 handle을 반환함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n12:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핵심 포인트는\"}],\"\\n\"]}]\n13:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MatchOpInterface를 구현하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload는 절대 수정하지 않는 다는 것\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"실패는 silenceable failure로 처리함.\"}],\"\\n\"]}]\n14:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"max(add(matmul, bias), 0)\\nmax(0, add(matmul, bias))\\n\"}]}]\n15:[\"$\",\"p\",null,{\"children\":\"이 덕분에 둘다 동일한 패턴으로 매칭이 가능하게 되는 것이다\"}]\n16:[\"$\",\"ol\",null,{\"start\":\"7\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Parameter는 transform 중에도 변하지 않는 값임.\"}],\"\\n\"]}]\n17:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\" %pos: !transform.param\u003ci32\u003e\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"operand 위치 같은 상수 정보\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"transform 전반에서 안전하게 사용이 가능함.\\n즉, 핸들(handle) != 파라미터(parameter)\"}],\"\\n\"]}]\n18:[\"$\",\"ol\",null,{\"start\":\"8\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"foreach_match : 미니 패턴리라이터\"}],\"\\n\"]}]\n19:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"transform.foreach_match\\n  @matcher -\u003e @rewriter\\n\"}]}]\n1a:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"payload IR 전체 순회\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"matcher가 성공 할 때 마다\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"rewriter를 실행함\\nTransform dialect 만으로\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"\\\"패턴 매칭 + 액션\\\"\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"간단한 패턴 리라이터 완성\"}],\"\\n\"]}]\n1b:[\"$\",\"ol\",null,{\"start\":\"9\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"진짜 강력한 매칭은 추론된 특성에 있음\\n예를 들어서\"}],\"\\n\"]}]\n1c:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"matmul이 linalg.matmul 이 아니라\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"linalg.generic 로 표현된 경우라면\"}],\"\\n\"]}]\n1d:[\"$\",\"p\",null,{\"children\":\"이를 해결하기 위해서는 이게 의미적으로 matmul 인가를 판단해야 함.\\n그렇다면 체크해야 하는 특성들을 아래와 같을 것이다.\"}]\n1e:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"iterator rank = 3\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"입력 2개, 출력 1개\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"projected permutation access\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"body 가 mulf + addf\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"contraction dimension 분류 결과가 적절한지\"}],\"\\n\"]}]\n1f:[\"$\",\"p\",null,{\"children\":\"이건\"}]\n20:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"단순 attribute 비교는 X\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석 + 추론이 필요함.\"}],\"\\n\"]}]\n21:[\"$\",\"ol\",null,{\"start\":\"10\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Structured Matchers의 위력\\nTransform dialect는 이미 제공하고 있음\"}],\"\\n\"]}]\n22:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"match.structured.rank\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"match.structured.body\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"classify_contraction_dims\"}],\"\\n\",[\"$\",\"li\",null"])</script><script>self.__next_f.push([1,",{\"children\":\"등등..\"}],\"\\n\"]}]\n23:[\"$\",\"p\",null,{\"children\":\"이 덕분에\"}]\n24:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"복잡한 수학적 의미라던지\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"C++ matcher로 캡슐화를 하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform script는 선언적으로 유지함\"}],\"\\n\"]}]\n25:[\"$\",\"p\",null,{\"children\":\"Flow 를 정리해 보자면\"}]\n26:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Transform 안에서 타깃을 직접 찾고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Match op = 조건 검사 전용 transform으로서\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"collect_matching으로 자동 발견하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"use-def 체인으로 연관된 연산을 묶고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"커스텀 matcher로 유연성을 확보하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"parameter로 불변 정보를 전달하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"foreach_match로 패턴 리라이터를 구현하고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"추론 기반 매칭으로 진짜 의미를 판별한다.\"}],\"\\n\"]}]\n27:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n28:[\"$\",\"p\",null,{\"children\":\"요약해 보자면 Transform dialect를 연산을 단순히 고치는 도구에서 패턴을 이해하고 판단하는 역할까지 진화시키는 과정을 학습하였다.\"}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"29:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR Transform Tutorial Ch 4 에 대하여 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Matching Payload with Transform Operations\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L29\",\"3\",{}]]\n8:null\n"])</script></body></html>