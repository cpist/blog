1:"$Sreact.fragment"
1b:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
1c:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
1d:"$Sreact.suspense"
0:{"buildId":"TmeFl9XvlrdQDoLIMxpL3","rsc":["$","$1","c",{"children":[["$","article",null,{"style":{"maxWidth":"800px","margin":"0 auto","padding":"20px"},"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/llvm","style":{"textDecoration":"none"},"children":["/","llvm"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"LLVM MallocChecker"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-12-29"}],["$","p",null,{"style":{"color":"#333","fontStyle":"italic"},"children":"Clang Static Analyzer - MallocCheckeranalyze"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","style":{"lineHeight":1.6},"children":[["$","p",null,{"children":"LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.\n이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음."}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"개요 및 목적"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸."}],"\n",["$","li",null,{"children":["주요 탐지 오류는 아래와 같음","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨"}],"\n",["$","li",null,{"children":"Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함"}],"\n",["$","li",null,{"children":"Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함"}],"\n",["$","li",null,{"children":"Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용"}],"\n",["$","li",null,{"children":"Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"핵심 데이터 구조"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"AllocationFamily\n메모리가 어떤 계열로 할당되었는지 정의함.\n이를 통해 할당-해제 쌍이 맞는지 검사함."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"AF_Malloc: malloc, free 계열."}],"\n",["$","li",null,{"children":"AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열."}],"\n",["$","li",null,{"children":"AF_Alloca: 스택 할당(alloca). 해제하면 안 됨."}],"\n",["$","li",null,{"children":"AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"RefState (메모리의 상태)\n분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Allocated: 메모리가 성공적으로 할당됨."}],"\n",["$","li",null,{"children":"Released: 메모리가 해제됨."}],"\n",["$","li",null,{"children":"Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음."}],"\n",["$","li",null,{"children":"Relinquished: 소유권이 이전됨 (스마트 포인터 등)."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"주요 동작 메커니즘"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"evalCall: 함수 호출 모델링\n분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈."}],"\n",["$","li",null,{"children":"FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"checkDeadSymbols: 누수(Leak) 탐지"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"ReallocMemAux: realloc의 복잡성 처리"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐."}],"\n",["$","li",null,{"children":"코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"특이 사항 및 고급 기능"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"스마트 포인터 대응 (handleSmartPointerRelatedCalls)"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"최신 C++ 코드에서는 std::unique_ptr 등을 사용함."}],"\n",["$","li",null,{"children":["분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 ",["$","strong",null,{"children":"Relinquished"}],"로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함."]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"커널 메모리 모델링 (performKernelMalloc)"}],"\n",["$","ul",null,{"children":["\n","$L2","\n","$L3","\n"]}],"\n"]}],"\n","$L4","\n"]}],"\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16"]}],"$L17","$L18"]}],["$L19"],"$L1a"]}],"loading":null,"isPartial":false}
2:["$","li",null,{"children":"Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함."}]
3:["$","li",null,{"children":"특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함."}]
4:["$","li",null,{"children":["\n",["$","p",null,{"children":"오염 분석 (checkTaintedness)"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함."}],"\n"]}],"\n"]}]
5:["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"상태 전이 모델링 (State Machine Implementation)\n메모리 심볼의 상태를 단순히 저장하는 것이 아닌 Immutable Map을 통해 관리함"}],"\n"]}]
6:["$","pre",null,{"children":["$","code",null,{"children":"REGISTER_MAP_WITH_PROGRAMSTATE(RegionState, SymbolRef, RefState)\n"}]}]
7:["$","p",null,{"children":"이 매크로는 ProgramState 내부에 SymbolRef(포인터 심볼) 와 RefState(상태 정보)를 매핑하는 테이블을 생성함.\n분석기가 경로를 탐색할 때 마다 Map이 복사되는 것이 아니라, 변경된 부분만 공유(Persistent Data Structure) 되어 효율성을 극대화 함."}]
8:["$","p",null,{"children":"상태 전이의 핵심 로직"}]
9:["$","ul",null,{"children":["\n",["$","li",null,{"children":"할당 때는 (MallocUpdateRefState): 심볼을 Allocated 상태로 등록."}],"\n",["$","li",null,{"children":"해제 때는 (FreeMemAux): 상태를 Released로 변경. 만약 이미 Released라면 HandleDoubleFree 호출."}],"\n",["$","li",null,{"children":"사용 때는 (checkUseAfterFree): 상태가 Released인 심볼에 접근하면 에러 보고."}],"\n"]}]
a:["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"evalCall vs checkPreCall/checkPostCall\n코드에서 함수 호출을 처리하는 방식이 두 가지로 나뉨.\n이 차이를 아는 것이 정적 분석기 코드 분석의 핵심"}],"\n"]}]
b:["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"evalCall (모델링): malloc, realloc 같은 시스템 함수를 만났을 때, 분석기가 \"이 함수의 동작은 내가 직접 정의하겠다\"라고 선언하는 것."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"실제 함수의 본문을 분석하는 대신, 리턴값으로 가상의 심볼을 생성함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"checkPreCall (검증): 함수가 실행되기 직전에 인자값이 유효한지(예: 이미 해제된 포인터를 free에 넘기지는 않는지) 검사함."}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"checkPostCall (사후 처리): 함수 실행 직후에 상태를 업데이트함. (예: 스마트 포인터 생성자가 호출된 후 소유권 이전 처리)"}],"\n"]}],"\n"]}]
c:["$","ol",null,{"start":"7","children":["\n",["$","li",null,{"children":"정교한 예외 처리 (False Positive Suppression)\n정적 분석기에서 가장 어려운 것은 \"버그가 아닌데 버그라고 하는 것\"을 막는 일임.\n이 코드에는 이를 위한 고도의 기교가 숨어 있음."}],"\n"]}]
d:["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"스마트 포인터와 임시 객체 (isRvalueByValueRecord)\nC++에서 임시 객체가 값으로 전달될 때 소멸자가 호출되는 시점이 복잡함.\n이 코드는 해당 객체 내부에 스마트 포인터 필드가 있는지 검사하고, 있다면 메모리 누수 보고를 일시적으로 유예하거나 Escaped 처리하여 오탐을 줄임."}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"아토믹 연산과 참조 카운팅"}],"\n"]}],"\n"]}]
e:["$","pre",null,{"children":["$","code",null,{"children":"if (isReferenceCountingPointerDestructor(DD)) { ... }\n"}]}]
f:["$","p",null,{"children":"참조 카운팅 기반의 객체(shared_ptr 등)는 참조 횟수가 0이 될 때만 메모리를 해제함.\n이 체커는 소멸자 내부에 fetch_add나 fetch_sub 같은 아토믹 연산이 있다면, 이는 참조 카운팅 로직일 확률이 높다고 보고 분석의 엄격함을 조절함."}]
10:["$","ol",null,{"start":"8","children":["\n",["$","li",null,{"children":"BugVisitor를 통한 원인 추적\n버그 리포트가 단순히 \"여기서 메모리 누수임\"이라고 말하면 개발자는 이해하기 어려움.\n이 코드의 MallocBugVisitor는 Exploded Graph(분석기가 지나온 경로 그래프)를 역추적함."}],"\n"]}]
11:["$","ul",null,{"children":["\n",["$","li",null,{"children":"역추적 로직: 현재 에러가 난 지점에서 뒤로 가면서 \"이 메모리가 어디서 할당되었는가?\"를 찾아내어 리포트에 **\"메모리가 여기서 할당되었습니다\"**라는 노트를 추가해줌. (getAllocationSite 함수)"}],"\n"]}]
12:["$","ol",null,{"start":"9","children":["\n",["$","li",null,{"children":"테인드 데이터 분석 (checkTaintedness)"}],"\n"]}]
13:["$","pre",null,{"children":["$","code",null,{"children":"void MallocChecker::checkTaintedness(..., const SVal SizeSVal, ...) const\n"}]}]
14:["$","p",null,{"children":"이 부분은 보안 분석의 핵심임.\n외부에서 들어온 값(SizeSVal)이 malloc의 인자로 쓰일 때, 이 값이 너무 크지는 않은지 검사함.\n만약 사용자가 제어 가능한 값이 검증 없이 할당 크기로 쓰인다면 이를 **\"Tainted Memory Allocation\"**으로 분류하여 보안 취약점으로 보고함."}]
15:["$","p",null,{"children":"====================================================================="}]
16:["$","p",null,{"children":["요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임.\n포인터의 생애 주기(",["$","code",null,{"children":"할당 → 사용 → 해제"}],")를 추적하며 각 단계에서 정의된 규칙(ex: \"해제된 상태에서 사용 금지\")을 위반하는지 감시합니다."]}]
17:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
18:["$","$L1b",null,{}]
19:["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true}]
1a:["$","$L1c",null,{"children":["$","$1d",null,{"name":"Next.MetadataOutlet","children":"$@1e"}]}]
1e:null
