1:"$Sreact.fragment"
7:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
8:"$Sreact.suspense"
0:{"buildId":"yapzT6Zt_kqDTi363HAcP","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/llvm","style":{"textDecoration":"none"},"children":["/","llvm"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"LLVM MallocChecker"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-12-29"}],["$","p",null,{"style":{"color":"#333"},"children":"Clang Static Analyzer - MallocCheckeranalyze"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.\n이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음."}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"개요 및 목적"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸."}],"\n",["$","li",null,{"children":["주요 탐지 오류는 아래와 같음","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨"}],"\n",["$","li",null,{"children":"Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함"}],"\n",["$","li",null,{"children":"Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함"}],"\n",["$","li",null,{"children":"Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용"}],"\n",["$","li",null,{"children":"Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"핵심 데이터 구조"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"AllocationFamily\n메모리가 어떤 계열로 할당되었는지 정의함.\n이를 통해 할당-해제 쌍이 맞는지 검사함."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"AF_Malloc: malloc, free 계열."}],"\n",["$","li",null,{"children":"AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열."}],"\n",["$","li",null,{"children":"AF_Alloca: 스택 할당(alloca). 해제하면 안 됨."}],"\n",["$","li",null,{"children":"AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"RefState (메모리의 상태)\n분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Allocated: 메모리가 성공적으로 할당됨."}],"\n",["$","li",null,{"children":"Released: 메모리가 해제됨."}],"\n",["$","li",null,{"children":"Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음."}],"\n",["$","li",null,{"children":"Relinquished: 소유권이 이전됨 (스마트 포인터 등)."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"주요 동작 메커니즘"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"evalCall: 함수 호출 모델링\n분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함."}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈."}],"\n",["$","li",null,{"children":"FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"checkDeadSymbols: 누수(Leak) 탐지"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"ReallocMemAux: realloc의 복잡성 처리"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐."}],"\n",["$","li",null,{"children":"코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"특이 사항 및 고급 기능"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"스마트 포인터 대응 (handleSmartPointerRelatedCalls)"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"최신 C++ 코드에서는 std::unique_ptr 등을 사용함."}],"\n",["$","li",null,{"children":["분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 ",["$","strong",null,{"children":"Relinquished"}],"로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함."]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"커널 메모리 모델링 (performKernelMalloc)"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함."}],"\n","$L2","\n"]}],"\n"]}],"\n","$L3","\n"]}],"\n","$L4","\n","$L5"]}]]}],null,"$L6"]}],"loading":null,"isPartial":false}
2:["$","li",null,{"children":"특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함."}]
3:["$","li",null,{"children":["\n",["$","p",null,{"children":"오염 분석 (checkTaintedness)"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함."}],"\n"]}],"\n"]}]
4:["$","p",null,{"children":"====================================================================="}]
5:["$","p",null,{"children":["요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임.\n포인터의 생애 주기(",["$","code",null,{"children":"할당 → 사용 → 해제"}],")를 추적하며 각 단계에서 정의된 규칙(ex: \"해제된 상태에서 사용 금지\")을 위반하는지 감시합니다."]}]
6:["$","$L7",null,{"children":["$","$8",null,{"name":"Next.MetadataOutlet","children":"$@9"}]}]
9:null
