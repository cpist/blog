<!DOCTYPE html><!--yapzT6Zt_kqDTi363HAcP--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/cbd55ab9639e1e66.js"/><script src="/blog/_next/static/chunks/8c4bb65ca9f95eb5.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-8ff2f6efb1e78309.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><title>LLVM MallocChecker - CPIST&#x27;s blog</title><meta name="description" content="Clang Static Analyzer - MallocCheckeranalyze"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/llvm" style="text-decoration:none">/<!-- -->llvm</a></div><h2 style="margin-top:0">LLVM MallocChecker</h2><div style="color:#666;margin-bottom:18px">2025-12-29</div><p style="color:#333">Clang Static Analyzer - MallocCheckeranalyze</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.
이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음.</p>
<ol>
<li>개요 및 목적</li>
</ol>
<ul>
<li>MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸.</li>
<li>주요 탐지 오류는 아래와 같음<!-- -->
<ul>
<li>Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨</li>
<li>Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함</li>
<li>Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함</li>
<li>Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용</li>
<li>Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>핵심 데이터 구조</li>
</ol>
<ul>
<li>
<p>AllocationFamily
메모리가 어떤 계열로 할당되었는지 정의함.
이를 통해 할당-해제 쌍이 맞는지 검사함.</p>
<ul>
<li>AF_Malloc: malloc, free 계열.</li>
<li>AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열.</li>
<li>AF_Alloca: 스택 할당(alloca). 해제하면 안 됨.</li>
<li>AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성.</li>
</ul>
</li>
<li>
<p>RefState (메모리의 상태)
분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다.</p>
<ul>
<li>Allocated: 메모리가 성공적으로 할당됨.</li>
<li>Released: 메모리가 해제됨.</li>
<li>Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음.</li>
<li>Relinquished: 소유권이 이전됨 (스마트 포인터 등).</li>
</ul>
</li>
</ul>
<ol start="3">
<li>주요 동작 메커니즘</li>
</ol>
<ul>
<li>
<p>evalCall: 함수 호출 모델링
분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함.</p>
<ul>
<li>AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈.</li>
<li>FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함.</li>
</ul>
</li>
<li>
<p>checkDeadSymbols: 누수(Leak) 탐지</p>
<ul>
<li>분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함.</li>
</ul>
</li>
<li>
<p>ReallocMemAux: realloc의 복잡성 처리</p>
<ul>
<li>realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐.</li>
<li>코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>특이 사항 및 고급 기능</li>
</ol>
<ul>
<li>
<p>스마트 포인터 대응 (handleSmartPointerRelatedCalls)</p>
<ul>
<li>최신 C++ 코드에서는 std::unique_ptr 등을 사용함.</li>
<li>분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 <strong>Relinquished</strong>로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함.</li>
</ul>
</li>
<li>
<p>커널 메모리 모델링 (performKernelMalloc)</p>
<ul>
<li>Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함.</li>
<li>특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함.</li>
</ul>
</li>
<li>
<p>오염 분석 (checkTaintedness)</p>
<ul>
<li>사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함.</li>
</ul>
</li>
</ul>
<p>=====================================================================</p>
<p>요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임.
포인터의 생애 주기(<code>할당 → 사용 → 해제</code>)를 추적하며 각 단계에서 정의된 규칙(ex: &quot;해제된 상태에서 사용 금지&quot;)을 위반하는지 감시합니다.</p></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2025<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/cbd55ab9639e1e66.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"yapzT6Zt_kqDTi363HAcP\",\"c\":[\"\",\"posts\",\"llvm\",\"md-MallocChecker\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"llvm/md-MallocChecker\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2025,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/llvm\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"llvm\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"LLVM MallocChecker\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-12-29\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Clang Static Analyzer - MallocCheckeranalyze\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.\\n이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음.\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"개요 및 목적\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"주요 탐지 오류는 아래와 같음\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핵심 데이터 구조\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"AllocationFamily\\n메모리가 어떤 계열로 할당되었는지 정의함.\\n이를 통해 할당-해제 쌍이 맞는지 검사함.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_Malloc: malloc, free 계열.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_Alloca: 스택 할당(alloca). 해제하면 안 됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"RefState (메모리의 상태)\\n분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Allocated: 메모리가 성공적으로 할당됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Released: 메모리가 해제됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Relinquished: 소유권이 이전됨 (스마트 포인터 등).\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"주요 동작 메커니즘\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"evalCall: 함수 호출 모델링\\n분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"checkDeadSymbols: 누수(Leak) 탐지\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"ReallocMemAux: realloc의 복잡성 처리\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"특이 사항 및 고급 기능\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"스마트 포인터 대응 (handleSmartPointerRelatedCalls)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"최신 C++ 코드에서는 std::unique_ptr 등을 사용함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 \",[\"$\",\"strong\",null,{\"children\":\"Relinquished\"}],\"로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"커널 메모리 모델링 (performKernelMalloc)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$Le\",\"\\n\"]}],\"\\n\",\"$Lf\",\"\\n\",\"$L10\"]}]]}]\n"])</script><script>self.__next_f.push([1,"e:[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"오염 분석 (checkTaintedness)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함.\"}],\"\\n\"]}],\"\\n\"]}]\nf:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n10:[\"$\",\"p\",null,{\"children\":[\"요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임.\\n포인터의 생애 주기(\",[\"$\",\"code\",null,{\"children\":\"할당 → 사용 → 해제\"}],\")를 추적하며 각 단계에서 정의된 규칙(ex: \\\"해제된 상태에서 사용 금지\\\")을 위반하는지 감시합니다.\"]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"11:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"LLVM MallocChecker - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Clang Static Analyzer - MallocCheckeranalyze\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L11\",\"3\",{}]]\n8:null\n"])</script></body></html>