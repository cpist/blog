<!DOCTYPE html><!--Rx5bBwvk2gP0K4H82T2jS--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><title>LLVM MallocChecker - CPIST&#x27;s blog</title><meta name="description" content="Clang Static Analyzer - MallocCheckeranalyze"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/llvm" style="text-decoration:none">/<!-- -->llvm</a></div><h2 style="margin-top:0">LLVM MallocChecker</h2><div style="color:#666;margin-bottom:18px">2025-12-29</div><p style="color:#333">Clang Static Analyzer - MallocCheckeranalyze</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.
이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음.</p>
<p>1) 개요 및 목적</p>
<ul>
<li>MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸.</li>
<li>주요 탐지 오류는 아래와 같음<!-- -->
<ul>
<li>Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨</li>
<li>Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함</li>
<li>Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함</li>
<li>Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용</li>
<li>Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함.</li>
</ul>
</li>
</ul>
<p>2) 핵심 데이터 구조</p>
<ul>
<li>
<p>AllocationFamily
메모리가 어떤 계열로 할당되었는지 정의함.
이를 통해 할당-해제 쌍이 맞는지 검사함.</p>
<ul>
<li>AF_Malloc: malloc, free 계열.</li>
<li>AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열.</li>
<li>AF_Alloca: 스택 할당(alloca). 해제하면 안 됨.</li>
<li>AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성.</li>
</ul>
</li>
<li>
<p>RefState (메모리의 상태)
분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다.</p>
<ul>
<li>Allocated: 메모리가 성공적으로 할당됨.</li>
<li>Released: 메모리가 해제됨.</li>
<li>Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음.</li>
<li>Relinquished: 소유권이 이전됨 (스마트 포인터 등).</li>
</ul>
</li>
</ul>
<p>3) 주요 동작 메커니즘</p>
<ul>
<li>
<p>evalCall: 함수 호출 모델링
분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함.</p>
<ul>
<li>AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈.</li>
<li>FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함.</li>
</ul>
</li>
<li>
<p>checkDeadSymbols: 누수(Leak) 탐지</p>
<ul>
<li>분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함.</li>
</ul>
</li>
<li>
<p>ReallocMemAux: realloc의 복잡성 처리</p>
<ul>
<li>realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐.</li>
<li>코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음.</li>
</ul>
</li>
</ul>
<p>4) 특이 사항 및 고급 기능</p>
<ul>
<li>
<p>스마트 포인터 대응 (handleSmartPointerRelatedCalls)</p>
<ul>
<li>최신 C++ 코드에서는 std::unique_ptr 등을 사용함.</li>
<li>분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 <strong>Relinquished</strong>로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함.</li>
</ul>
</li>
<li>
<p>커널 메모리 모델링 (performKernelMalloc)</p>
<ul>
<li>Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함.</li>
<li>특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함.</li>
</ul>
</li>
<li>
<p>오염 분석 (checkTaintedness)</p>
<ul>
<li>사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함.</li>
</ul>
</li>
</ul>
<p>5) 상태 전이 모델링 (State Machine Implementation)
메모리 심볼의 상태를 단순히 저장하는 것이 아닌 Immutable Map을 통해 관리함</p>
<pre><code>REGISTER_MAP_WITH_PROGRAMSTATE(RegionState, SymbolRef, RefState)
</code></pre>
<p>이 매크로는 ProgramState 내부에 SymbolRef(포인터 심볼) 와 RefState(상태 정보)를 매핑하는 테이블을 생성함.
분석기가 경로를 탐색할 때 마다 Map이 복사되는 것이 아니라, 변경된 부분만 공유(Persistent Data Structure) 되어 효율성을 극대화 함.</p>
<p>상태 전이의 핵심 로직</p>
<ul>
<li>할당 때는 (MallocUpdateRefState): 심볼을 Allocated 상태로 등록.</li>
<li>해제 때는 (FreeMemAux): 상태를 Released로 변경. 만약 이미 Released라면 HandleDoubleFree 호출.</li>
<li>사용 때는 (checkUseAfterFree): 상태가 Released인 심볼에 접근하면 에러 보고.</li>
</ul>
<p>6) evalCall vs checkPreCall/checkPostCall
코드에서 함수 호출을 처리하는 방식이 두 가지로 나뉨.
이 차이를 아는 것이 정적 분석기 코드 분석의 핵심</p>
<ul>
<li>
<p>evalCall (모델링): malloc, realloc 같은 시스템 함수를 만났을 때, 분석기가 &quot;이 함수의 동작은 내가 직접 정의하겠다&quot;라고 선언하는 것.</p>
<ul>
<li>실제 함수의 본문을 분석하는 대신, 리턴값으로 가상의 심볼을 생성함.</li>
</ul>
</li>
<li>
<p>checkPreCall (검증): 함수가 실행되기 직전에 인자값이 유효한지(예: 이미 해제된 포인터를 free에 넘기지는 않는지) 검사함.</p>
</li>
<li>
<p>checkPostCall (사후 처리): 함수 실행 직후에 상태를 업데이트함. (예: 스마트 포인터 생성자가 호출된 후 소유권 이전 처리)</p>
</li>
</ul>
<p>7) 정교한 예외 처리 (False Positive Suppression)
정적 분석기에서 가장 어려운 것은 &quot;버그가 아닌데 버그라고 하는 것&quot;을 막는 일임.
이 코드에는 이를 위한 고도의 기교가 숨어 있음.</p>
<ol>
<li>
<p>스마트 포인터와 임시 객체 (isRvalueByValueRecord)
C++에서 임시 객체가 값으로 전달될 때 소멸자가 호출되는 시점이 복잡함.
이 코드는 해당 객체 내부에 스마트 포인터 필드가 있는지 검사하고, 있다면 메모리 누수 보고를 일시적으로 유예하거나 Escaped 처리하여 오탐을 줄임.</p>
</li>
<li>
<p>아토믹 연산과 참조 카운팅</p>
</li>
</ol>
<pre><code>if (isReferenceCountingPointerDestructor(DD)) { ... }
</code></pre>
<p>참조 카운팅 기반의 객체(shared_ptr 등)는 참조 횟수가 0이 될 때만 메모리를 해제함.
이 체커는 소멸자 내부에 fetch_add나 fetch_sub 같은 아토믹 연산이 있다면, 이는 참조 카운팅 로직일 확률이 높다고 보고 분석의 엄격함을 조절함.</p>
<p>8) BugVisitor를 통한 원인 추적
버그 리포트가 단순히 &quot;여기서 메모리 누수임&quot;이라고 말하면 개발자는 이해하기 어려움.
이 코드의 MallocBugVisitor는 Exploded Graph(분석기가 지나온 경로 그래프)를 역추적함.</p>
<ul>
<li>역추적 로직: 현재 에러가 난 지점에서 뒤로 가면서 &quot;이 메모리가 어디서 할당되었는가?&quot;를 찾아내어 리포트에 **&quot;메모리가 여기서 할당되었습니다&quot;**라는 노트를 추가해줌. (getAllocationSite 함수)</li>
</ul>
<p>9) 테인드 데이터 분석 (checkTaintedness)</p>
<pre><code>void MallocChecker::checkTaintedness(..., const SVal SizeSVal, ...) const
</code></pre>
<p>이 부분은 보안 분석의 핵심임.
외부에서 들어온 값(SizeSVal)이 malloc의 인자로 쓰일 때, 이 값이 너무 크지는 않은지 검사함.
만약 사용자가 제어 가능한 값이 검증 없이 할당 크기로 쓰인다면 이를 **&quot;Tainted Memory Allocation&quot;**으로 분류하여 보안 취약점으로 보고함.</p>
<p>=====================================================================</p>
<p>요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임.
포인터의 생애 주기(<code>할당 → 사용 → 해제</code>)를 추적하며 각 단계에서 정의된 규칙(ex: &quot;해제된 상태에서 사용 금지&quot;)을 위반하는지 감시합니다.</p></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"Rx5bBwvk2gP0K4H82T2jS\",\"c\":[\"\",\"posts\",\"llvm\",\"md-MallocChecker\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"llvm/md-MallocChecker\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/llvm\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"llvm\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"LLVM MallocChecker\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-12-29\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Clang Static Analyzer - MallocCheckeranalyze\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.\\n이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"1) 개요 및 목적\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"주요 탐지 오류는 아래와 같음\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) 핵심 데이터 구조\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"AllocationFamily\\n메모리가 어떤 계열로 할당되었는지 정의함.\\n이를 통해 할당-해제 쌍이 맞는지 검사함.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_Malloc: malloc, free 계열.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_Alloca: 스택 할당(alloca). 해제하면 안 됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"RefState (메모리의 상태)\\n분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Allocated: 메모리가 성공적으로 할당됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Released: 메모리가 해제됨.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Relinquished: 소유권이 이전됨 (스마트 포인터 등).\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3) 주요 동작 메커니즘\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"evalCall: 함수 호출 모델링\\n분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"checkDeadSymbols: 누수(Leak) 탐지\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"ReallocMemAux: realloc의 복잡성 처리\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4) 특이 사항 및 고급 기능\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"스마트 포인터 대응 (handleSmartPointerRelatedCalls)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"최신 C++ 코드에서는 std::unique_ptr 등을 사용함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 \",[\"$\",\"strong\",null,{\"children\":\"Relinquished\"}],\"로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함.\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"커널 메모리 모델링 (performKernelMalloc)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"오염 분석 (checkTaintedness)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",\"$Le\",\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\"]}],\"$L21\",\"$L22\"]}]\n"])</script><script>self.__next_f.push([1,"23:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"li\",null,{\"children\":\"사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함.\"}]\nf:[\"$\",\"p\",null,{\"children\":\"5) 상태 전이 모델링 (State Machine Implementation)\\n메모리 심볼의 상태를 단순히 저장하는 것이 아닌 Immutable Map을 통해 관리함\"}]\n10:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"REGISTER_MAP_WITH_PROGRAMSTATE(RegionState, SymbolRef, RefState)\\n\"}]}]\n11:[\"$\",\"p\",null,{\"children\":\"이 매크로는 ProgramState 내부에 SymbolRef(포인터 심볼) 와 RefState(상태 정보)를 매핑하는 테이블을 생성함.\\n분석기가 경로를 탐색할 때 마다 Map이 복사되는 것이 아니라, 변경된 부분만 공유(Persistent Data Structure) 되어 효율성을 극대화 함.\"}]\n12:[\"$\",\"p\",null,{\"children\":\"상태 전이의 핵심 로직\"}]\n13:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"할당 때는 (MallocUpdateRefState): 심볼을 Allocated 상태로 등록.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"해제 때는 (FreeMemAux): 상태를 Released로 변경. 만약 이미 Released라면 HandleDoubleFree 호출.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"사용 때는 (checkUseAfterFree): 상태가 Released인 심볼에 접근하면 에러 보고.\"}],\"\\n\"]}]\n14:[\"$\",\"p\",null,{\"children\":\"6) evalCall vs checkPreCall/checkPostCall\\n코드에서 함수 호출을 처리하는 방식이 두 가지로 나뉨.\\n이 차이를 아는 것이 정적 분석기 코드 분석의 핵심\"}]\n15:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"evalCall (모델링): malloc, realloc 같은 시스템 함수를 만났을 때, 분석기가 \\\"이 함수의 동작은 내가 직접 정의하겠다\\\"라고 선언하는 것.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"실제 함수의 본문을 분석하는 대신, 리턴값으로 가상의 심볼을 생성함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"checkPreCall (검증): 함수가 실행되기 직전에 인자값이 유효한지(예: 이미 해제된 포인터를 free에 넘기지는 않는지) 검사함.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"checkPostCall (사후 처리): 함수 실행 직후에 상태를 업데이트함. (예: 스마트 포인터 생성자가 호출된 후 소유권 이전 처리)\"}],\"\\n\"]}],\"\\n\"]}]\n16:[\"$\",\"p\",null,{\"children\":\"7) 정교한 예외 처리 (False Positive Suppression)\\n정적 분석기에서 가장 어려운 것은 \\\"버그가 아닌데 버그라고 하는 것\\\"을 막는 일임.\\n이 코드에는 이를 위한 고도의 기교가 숨어 있음.\"}]\n17:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"스마트 포인터와 임시 객체 (isRvalueByValueRecord)\\nC++에서 임시 객체가 값으로 전달될 때 소멸자가 호출되는 시점이 복잡함.\\n이 코드는 해당 객체 내부에 스마트 포인터 필드가 있는지 검사하고, 있다면 메모리 누수 보고를 일시적으로 유예하거나 Escaped 처리하여 오탐을 줄임.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"아토믹 연산과 참조 카운팅\"}],\"\\n\"]}],\"\\n\"]}]\n18:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"if (isReferenceCountingPointerDestructor(DD)) { ... }\\n\"}]}]\n19:[\"$\",\"p\",null,{\"children\":\"참조 카운팅 기반의 객체(shared_ptr 등)는 참조 횟수가 0이 될 때만 메모리를 해제함.\\n이 체커는 소멸자 내부에 fetch_add나 fetch_sub 같은 아토믹 연산이 있다면, 이는 참조 카운팅 로직일 확률이 높다고 보고 분석의 엄격함을 조절함.\"}]\n1a:[\"$\",\"p\",null,{\"children\":\"8) BugVisitor를 통한 원인 추적\\n버그 리포트가 단순히 \\\"여기"])</script><script>self.__next_f.push([1,"서 메모리 누수임\\\"이라고 말하면 개발자는 이해하기 어려움.\\n이 코드의 MallocBugVisitor는 Exploded Graph(분석기가 지나온 경로 그래프)를 역추적함.\"}]\n1b:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"역추적 로직: 현재 에러가 난 지점에서 뒤로 가면서 \\\"이 메모리가 어디서 할당되었는가?\\\"를 찾아내어 리포트에 **\\\"메모리가 여기서 할당되었습니다\\\"**라는 노트를 추가해줌. (getAllocationSite 함수)\"}],\"\\n\"]}]\n1c:[\"$\",\"p\",null,{\"children\":\"9) 테인드 데이터 분석 (checkTaintedness)\"}]\n1d:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"void MallocChecker::checkTaintedness(..., const SVal SizeSVal, ...) const\\n\"}]}]\n1e:[\"$\",\"p\",null,{\"children\":\"이 부분은 보안 분석의 핵심임.\\n외부에서 들어온 값(SizeSVal)이 malloc의 인자로 쓰일 때, 이 값이 너무 크지는 않은지 검사함.\\n만약 사용자가 제어 가능한 값이 검증 없이 할당 크기로 쓰인다면 이를 **\\\"Tainted Memory Allocation\\\"**으로 분류하여 보안 취약점으로 보고함.\"}]\n1f:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n20:[\"$\",\"p\",null,{\"children\":[\"요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임.\\n포인터의 생애 주기(\",[\"$\",\"code\",null,{\"children\":\"할당 → 사용 → 해제\"}],\")를 추적하며 각 단계에서 정의된 규칙(ex: \\\"해제된 상태에서 사용 금지\\\")을 위반하는지 감시합니다.\"]}]\n21:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n22:[\"$\",\"$L23\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"24:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"LLVM MallocChecker - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Clang Static Analyzer - MallocCheckeranalyze\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L24\",\"3\",{}]]\n8:null\n"])</script></body></html>