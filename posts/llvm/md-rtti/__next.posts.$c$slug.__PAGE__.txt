1:"$Sreact.fragment"
c:I[80852,["/blog/_next/static/chunks/796e69ae18b2784c.js","/blog/_next/static/chunks/631eeae4923b8465.js"],"default"]
d:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
e:"$Sreact.suspense"
0:{"buildId":"qpYlHngKSPQ9cyVqK9zM6","rsc":["$","$1","c",{"children":[["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/llvm","style":{"textDecoration":"none"},"children":["/","llvm"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"MLIR에서 RTTI이 의미하는 것"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2026-01-08"}],["$","p",null,{"style":{"color":"#333"},"children":"RTTI Stands For"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"1) LLVM에서 **RTTI(Run-Time Type Information)**는 객체의 타입을 런타임에 식별하고 안전하게 다운캐스팅(Downcasting)하기 위한 메커니즘\nBut, LLVM은 표준 C++에서 제공하는 dynamic_cast나 typeid 같은 표준 RTTI를 사용하지 않음.\n대신 **'LLVM-style RTTI'**라고 불리는 자체적인 경량 시스템을 구축하여 사용."}],"\n",["$","p",null,{"children":"2) LLVM이 표준 RTTI를 버린 이유\n표준 C++의 RTTI는 편리하지만, 컴파일러와 같은 거대한 프레임워크에서는 다음과 같은 단점이 있음"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"바이너리 크기 증가: 모든 다형성 클래스에 대해 타입 정보(Type Info)와 VTable을 생성해야 하므로 실행 파일이 매우 커짐"}],"\n",["$","li",null,{"children":"성능 저하: dynamic_cast는 런타임에 클래스 계층 구조를 순회하며 타입을 체크하므로 오버헤드가 큼"}],"\n",["$","li",null,{"children":"의존성: 표준 RTTI는 특정 컴파일러 플래그(-fno-rtti)로 꺼버리는 경우가 많아, 라이브러리 간 호환성 문제를 일으킬 수 있음\n이 때문에 LLVM은 성능을 극대화하기 위해 표준 RTTI를 끄고(-fno-rtti), 수동으로 구현한 커스텀 RTTI를 사용"}],"\n"]}],"\n",["$","p",null,{"children":["3) LLVM-style RTTI의 핵심 구조\n이 시스템의 핵심은 ",["$","strong",null,{"children":"\"객체 스스로가 자신이 누구인지 알고 있게 만드는 것\""}],"\n이를 위해 두 가지 장치가 필요"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Type Kind (Enum): 베이스 클래스에 자신이 어떤 서브 클래스인지 나타내는 열거형 값을 저장"}],"\n",["$","li",null,{"children":"classof(): 각 서브 클래스에 \"이 객체가 내 타입이 맞는가?\"를 판단하는 정적 메서드를 구현"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"#include <iostream>\n#include <llvm/Support/Casting.h> // isa, cast, dyn_cast 정의\n\n// 1. 베이스 클래스 정의\nclass Shape {\npublic:\n  enum ShapeKind { SK_Circle, SK_Square }; // 서브 클래스 식별자\n\nprivate:\n  const ShapeKind Kind; // 객체의 실제 타입을 저장\n\npublic:\n  ShapeKind getKind() const { return Kind; }\n  Shape(ShapeKind K) : Kind(K) {}\n  virtual ~Shape() {}\n};\n\n// 2. 서브 클래스 정의\nclass Circle : public Shape {\npublic:\n  Circle() : Shape(SK_Circle) {}\n\n  // LLVM RTTI의 핵심: classof 구현\n  static bool classof(const Shape *S) {\n    return S->getKind() == SK_Circle;\n  }\n};\n\nclass Square : public Shape {\npublic:\n  Square() : Shape(SK_Square) {}\n\n  static bool classof(const Shape *S) {\n    return S->getKind() == SK_Square;\n  }\n};\n"}]}],"\n",["$","p",null,{"children":"4) 어떻게 사용하나? (Casting.h)\nclassof가 구현되어 있다면, LLVM이 제공하는 강력한 캐스팅 도구들을 사용 가능"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":[["$","code",null,{"children":"isa<T>(ptr)"}],": 객체가 특정 타입인지 확인 (bool 반환)"]}],"\n",["$","li",null,{"children":[["$","code",null,{"children":"cast<T>(ptr)"}],": 특정 타입으로 강제 캐스팅 (타입이 다르면 Assertion Error 발생)"]}],"\n",["$","li",null,{"children":[["$","code",null,{"children":"dyn_cast<T>(ptr)"}],": dynamic_cast와 유사. 타입이 맞으면 포인터 반환, 틀리면 nullptr 반환"]}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"void processShape(Shape *S) {\n  if (llvm::isa<Circle>(S)) {\n    // S가 Circle임을 확인\n  }\n\n  if (Circle *C = llvm::dyn_cast<Circle>(S)) {\n    // 안전하게 Circle의 멤버에 접근\n    std::cout << \"This is a circle!\" << std::endl;\n  }\n}\n"}]}],"\n",["$","p",null,{"children":["5) 구현의 원리\n",["$","code",null,{"children":"llvm::dyn_cast<T>(val)"}]," 내부적으로는 대략 다음과 같은 템플릿 로직이 동작"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"입력받은 val의 타입에서 T::classof(val)가 존재하는지 확인"}],"\n",["$","li",null,{"children":["T::classof(val)를 호출하여 true가 나오면 ",["$","code",null,{"children":"static_cast<T*>(val)"}],"를 수행"]}],"\n",["$","li",null,{"children":"false라면 nullptr를 반환\n이 방식은 단순히 정수값(Enum) 비교만 수행하므로 dynamic_cast보다 훨씬 빠르고, VTable 이외의 추가적인 메타데이터를 생성하지 않아 효율적"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"LLVM이나 MLIR 코드를 보실 때 classof라는 함수가 보인다면, 대충 LLVM 스타일의 RTTI를 지원한다고 이해하면 됨."}],"\n"]}],"\n","$L2","\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7"]}],"$L8","$L9"]}],["$La"],"$Lb"]}],"loading":null,"isPartial":false}
2:["$","p",null,{"children":"6) llvm::dyn_cast 내부에 classof를 쓴다.\n일단 llvm-project/llvm/include/llvm/Support/Casting.h 를 들어가보면"}]
3:["$","pre",null,{"children":["$","code",null,{"children":"template <typename To, typename From>\n[[nodiscard]] inline decltype(auto) dyn_cast(const From &Val) {\n  assert(detail::isPresent(Val) && \"dyn_cast on a non-existent value\");\n  return CastInfo<To, const From>::doCastIfPossible(Val);\n}\n\ntemplate <typename To, typename From>\n[[nodiscard]] inline decltype(auto) dyn_cast(From &Val) {\n  assert(detail::isPresent(Val) && \"dyn_cast on a non-existent value\");\n  return CastInfo<To, From>::doCastIfPossible(Val);\n}\n\ntemplate <typename To, typename From>\n[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {\n  assert(detail::isPresent(Val) && \"dyn_cast on a non-existent value\");\n  return CastInfo<To, From *>::doCastIfPossible(Val);\n}\n\ntemplate <typename To, typename From>\n[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr<From> &Val) {\n  assert(detail::isPresent(Val) && \"dyn_cast on a non-existent value\");\n  return CastInfo<To, std::unique_ptr<From>>::doCastIfPossible(Val);\n}\n"}]}]
4:["$","p",null,{"children":"요런식으로 구현 되어있음.\nInterface 부분에서는 classof가 없고\nCastInfo 라는 Trait 구조체 뒤로 구현 상세가 숨겨져 있음."}]
5:["$","p",null,{"children":["즉 CastInfo ",["$","code",null,{"children":"->"}]," isa ",["$","code",null,{"children":"->"}]," classof 로 가는데\n함수로 보자면 doCastIfPossible ",["$","code",null,{"children":"->"}]," isPossible ",["$","code",null,{"children":"->"}]," doit 으로 가고\n가장 마지막 바닥에 있는 isa_impl 에서"]}]
6:["$","pre",null,{"children":["$","code",null,{"children":"template <typename To, typename From, typename Enabler = void> struct isa_impl {\n  static inline bool doit(const From &Val) { return To::classof(&Val); }\n};\n"}]}]
7:["$","p",null,{"children":"classof가 있음."}]
8:["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"36px 0"}}]
9:["$","$Lc",null,{}]
a:["$","script","script-0",{"src":"/blog/_next/static/chunks/631eeae4923b8465.js","async":true}]
b:["$","$Ld",null,{"children":["$","$e",null,{"name":"Next.MetadataOutlet","children":"$@f"}]}]
f:null
