<!DOCTYPE html><!--6GbxHRjYFfXuN_aMyDcOS--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" as="style" crossorigin="anonymous" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu"/><title>MLIR에서 RTTI이 의미하는 것 - CPIST&#x27;s blog</title><meta name="description" content="RTTI Stands For"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu" crossorigin="anonymous"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/llvm" style="text-decoration:none">/<!-- -->llvm</a></div><h2 style="margin-top:0">MLIR에서 RTTI이 의미하는 것</h2><div style="color:#666;margin-bottom:18px">2026-01-08</div><p style="color:#333">RTTI Stands For</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>1) LLVM에서 **RTTI(Run-Time Type Information)**는 객체의 타입을 런타임에 식별하고 안전하게 다운캐스팅(Downcasting)하기 위한 메커니즘
But, LLVM은 표준 C++에서 제공하는 dynamic_cast나 typeid 같은 표준 RTTI를 사용하지 않음.
대신 **&#x27;LLVM-style RTTI&#x27;**라고 불리는 자체적인 경량 시스템을 구축하여 사용.</p>
<p>2) LLVM이 표준 RTTI를 버린 이유
표준 C++의 RTTI는 편리하지만, 컴파일러와 같은 거대한 프레임워크에서는 다음과 같은 단점이 있음</p>
<ul>
<li>바이너리 크기 증가: 모든 다형성 클래스에 대해 타입 정보(Type Info)와 VTable을 생성해야 하므로 실행 파일이 매우 커짐</li>
<li>성능 저하: dynamic_cast는 런타임에 클래스 계층 구조를 순회하며 타입을 체크하므로 오버헤드가 큼</li>
<li>의존성: 표준 RTTI는 특정 컴파일러 플래그(-fno-rtti)로 꺼버리는 경우가 많아, 라이브러리 간 호환성 문제를 일으킬 수 있음
이 때문에 LLVM은 성능을 극대화하기 위해 표준 RTTI를 끄고(-fno-rtti), 수동으로 구현한 커스텀 RTTI를 사용</li>
</ul>
<p>3) LLVM-style RTTI의 핵심 구조
이 시스템의 핵심은 <strong>&quot;객체 스스로가 자신이 누구인지 알고 있게 만드는 것&quot;</strong>
이를 위해 두 가지 장치가 필요</p>
<ul>
<li>Type Kind (Enum): 베이스 클래스에 자신이 어떤 서브 클래스인지 나타내는 열거형 값을 저장</li>
<li>classof(): 각 서브 클래스에 &quot;이 객체가 내 타입이 맞는가?&quot;를 판단하는 정적 메서드를 구현</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include &lt;llvm/Support/Casting.h&gt; // isa, cast, dyn_cast 정의

// 1. 베이스 클래스 정의
class Shape {
public:
  enum ShapeKind { SK_Circle, SK_Square }; // 서브 클래스 식별자

private:
  const ShapeKind Kind; // 객체의 실제 타입을 저장

public:
  ShapeKind getKind() const { return Kind; }
  Shape(ShapeKind K) : Kind(K) {}
  virtual ~Shape() {}
};

// 2. 서브 클래스 정의
class Circle : public Shape {
public:
  Circle() : Shape(SK_Circle) {}

  // LLVM RTTI의 핵심: classof 구현
  static bool classof(const Shape *S) {
    return S-&gt;getKind() == SK_Circle;
  }
};

class Square : public Shape {
public:
  Square() : Shape(SK_Square) {}

  static bool classof(const Shape *S) {
    return S-&gt;getKind() == SK_Square;
  }
};
</code></pre>
<p>4) 어떻게 사용하나? (Casting.h)
classof가 구현되어 있다면, LLVM이 제공하는 강력한 캐스팅 도구들을 사용 가능</p>
<ul>
<li><code>isa&lt;T&gt;(ptr)</code>: 객체가 특정 타입인지 확인 (bool 반환)</li>
<li><code>cast&lt;T&gt;(ptr)</code>: 특정 타입으로 강제 캐스팅 (타입이 다르면 Assertion Error 발생)</li>
<li><code>dyn_cast&lt;T&gt;(ptr)</code>: dynamic_cast와 유사. 타입이 맞으면 포인터 반환, 틀리면 nullptr 반환</li>
</ul>
<pre><code>void processShape(Shape *S) {
  if (llvm::isa&lt;Circle&gt;(S)) {
    // S가 Circle임을 확인
  }

  if (Circle *C = llvm::dyn_cast&lt;Circle&gt;(S)) {
    // 안전하게 Circle의 멤버에 접근
    std::cout &lt;&lt; &quot;This is a circle!&quot; &lt;&lt; std::endl;
  }
}
</code></pre>
<p>5) 구현의 원리
<code>llvm::dyn_cast&lt;T&gt;(val)</code> 내부적으로는 대략 다음과 같은 템플릿 로직이 동작</p>
<ul>
<li>입력받은 val의 타입에서 T::classof(val)가 존재하는지 확인</li>
<li>T::classof(val)를 호출하여 true가 나오면 <code>static_cast&lt;T*&gt;(val)</code>를 수행</li>
<li>false라면 nullptr를 반환
이 방식은 단순히 정수값(Enum) 비교만 수행하므로 dynamic_cast보다 훨씬 빠르고, VTable 이외의 추가적인 메타데이터를 생성하지 않아 효율적</li>
</ul>
<ul>
<li>LLVM이나 MLIR 코드를 보실 때 classof라는 함수가 보인다면, 대충 LLVM 스타일의 RTTI를 지원한다고 이해하면 됨.</li>
</ul>
<p>6) llvm::dyn_cast 내부에 classof를 쓴다.
일단 llvm-project/llvm/include/llvm/Support/Casting.h 를 들어가보면</p>
<pre><code>template &lt;typename To, typename From&gt;
[[nodiscard]] inline decltype(auto) dyn_cast(const From &amp;Val) {
  assert(detail::isPresent(Val) &amp;&amp; &quot;dyn_cast on a non-existent value&quot;);
  return CastInfo&lt;To, const From&gt;::doCastIfPossible(Val);
}

template &lt;typename To, typename From&gt;
[[nodiscard]] inline decltype(auto) dyn_cast(From &amp;Val) {
  assert(detail::isPresent(Val) &amp;&amp; &quot;dyn_cast on a non-existent value&quot;);
  return CastInfo&lt;To, From&gt;::doCastIfPossible(Val);
}

template &lt;typename To, typename From&gt;
[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {
  assert(detail::isPresent(Val) &amp;&amp; &quot;dyn_cast on a non-existent value&quot;);
  return CastInfo&lt;To, From *&gt;::doCastIfPossible(Val);
}

template &lt;typename To, typename From&gt;
[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr&lt;From&gt; &amp;Val) {
  assert(detail::isPresent(Val) &amp;&amp; &quot;dyn_cast on a non-existent value&quot;);
  return CastInfo&lt;To, std::unique_ptr&lt;From&gt;&gt;::doCastIfPossible(Val);
}
</code></pre>
<p>요런식으로 구현 되어있음.
Interface 부분에서는 classof가 없고
CastInfo 라는 Trait 구조체 뒤로 구현 상세가 숨겨져 있음.</p>
<p>즉 CastInfo <code>-&gt;</code> isa <code>-&gt;</code> classof 로 가는데
함수로 보자면 doCastIfPossible <code>-&gt;</code> isPossible <code>-&gt;</code> doit 으로 가고
가장 마지막 바닥에 있는 isa_impl 에서</p>
<pre><code>template &lt;typename To, typename From, typename Enabler = void&gt; struct isa_impl {
  static inline bool doit(const From &amp;Val) { return To::classof(&amp;Val); }
};
</code></pre>
<p>classof가 있음.</p></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n:HL[\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"style\",{\"crossOrigin\":\"anonymous\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"6GbxHRjYFfXuN-aMyDcOS\",\"c\":[\"\",\"posts\",\"llvm\",\"md-rtti\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"llvm/md-rtti\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\",\"integrity\":\"sha384-n8MVd4RsNIU0KOVEMVIqhKyMVPsoloXttrTHYUjDkaWaXIhKbMCh2GbqNl2CAPFu\",\"crossOrigin\":\"anonymous\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/llvm\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"llvm\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"MLIR에서 RTTI이 의미하는 것\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2026-01-08\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"RTTI Stands For\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"1) LLVM에서 **RTTI(Run-Time Type Information)**는 객체의 타입을 런타임에 식별하고 안전하게 다운캐스팅(Downcasting)하기 위한 메커니즘\\nBut, LLVM은 표준 C++에서 제공하는 dynamic_cast나 typeid 같은 표준 RTTI를 사용하지 않음.\\n대신 **'LLVM-style RTTI'**라고 불리는 자체적인 경량 시스템을 구축하여 사용.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) LLVM이 표준 RTTI를 버린 이유\\n표준 C++의 RTTI는 편리하지만, 컴파일러와 같은 거대한 프레임워크에서는 다음과 같은 단점이 있음\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"바이너리 크기 증가: 모든 다형성 클래스에 대해 타입 정보(Type Info)와 VTable을 생성해야 하므로 실행 파일이 매우 커짐\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"성능 저하: dynamic_cast는 런타임에 클래스 계층 구조를 순회하며 타입을 체크하므로 오버헤드가 큼\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"의존성: 표준 RTTI는 특정 컴파일러 플래그(-fno-rtti)로 꺼버리는 경우가 많아, 라이브러리 간 호환성 문제를 일으킬 수 있음\\n이 때문에 LLVM은 성능을 극대화하기 위해 표준 RTTI를 끄고(-fno-rtti), 수동으로 구현한 커스텀 RTTI를 사용\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"3) LLVM-style RTTI의 핵심 구조\\n이 시스템의 핵심은 \",[\"$\",\"strong\",null,{\"children\":\"\\\"객체 스스로가 자신이 누구인지 알고 있게 만드는 것\\\"\"}],\"\\n이를 위해 두 가지 장치가 필요\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Type Kind (Enum): 베이스 클래스에 자신이 어떤 서브 클래스인지 나타내는 열거형 값을 저장\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"classof(): 각 서브 클래스에 \\\"이 객체가 내 타입이 맞는가?\\\"를 판단하는 정적 메서드를 구현\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"#include \u003ciostream\u003e\\n#include \u003cllvm/Support/Casting.h\u003e // isa, cast, dyn_cast 정의\\n\\n// 1. 베이스 클래스 정의\\nclass Shape {\\npublic:\\n  enum ShapeKind { SK_Circle, SK_Square }; // 서브 클래스 식별자\\n\\nprivate:\\n  const ShapeKind Kind; // 객체의 실제 타입을 저장\\n\\npublic:\\n  ShapeKind getKind() const { return Kind; }\\n  Shape(ShapeKind K) : Kind(K) {}\\n  virtual ~Shape() {}\\n};\\n\\n// 2. 서브 클래스 정의\\nclass Circle : public Shape {\\npublic:\\n  Circle() : Shape(SK_Circle) {}\\n\\n  // LLVM RTTI의 핵심: classof 구현\\n  static bool classof(const Shape *S) {\\n    return S-\u003egetKind() == SK_Circle;\\n  }\\n};\\n\\nclass Square : public Shape {\\npublic:\\n  Square() : Shape(SK_Square) {}\\n\\n  static bool classof(const Shape *S) {\\n    return S-\u003egetKind() == SK_Square;\\n  }\\n};\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4) 어떻게 사용하나? (Casting.h)\\nclassof가 구현되어 있다면, LLVM이 제공하는 강력한 캐스팅 도구들을 사용 가능\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"isa\u003cT\u003e(ptr)\"}],\": 객체가 특정 타입인지 확인 (bool 반환)\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"cast\u003cT\u003e(ptr)\"}],\": 특정 타입으로 강제 캐스팅 (타입이 다르면 Assertion Error 발생)\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"dyn_cast\u003cT\u003e(ptr)\"}],\": dynamic_cast와 유사. 타입이 맞으면 포인터 반환, 틀리면 nullptr 반환\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"void processShape(Shape *S) {\\n  if (llvm::isa\u003cCircle\u003e(S)) {\\n    // S가 Circle임을 확인\\n  }\\n\\n  if (Circle *C = llvm::dyn_cast\u003cCircle\u003e(S)) {\\n    // 안전하게 Circle의 멤버에 접근\\n    std::cout \u003c\u003c \\\"This is a circle!\\\" \u003c\u003c std::endl;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"5) 구현의 원리\\n\",[\"$\",\"code\",null,{\"children\":\"llvm::dyn_cast\u003cT\u003e(val)\"}],\" 내부적으로는 대략 다음과 같은 템플릿 로직이 동작\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"입력받은 val의 타입에서 T::classof(val)가 존재하는지 확인\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"T::classof(val)를 호출하여 true가 나오면 \",[\"$\",\"code\",null,{\"children\":\"static_cast\u003cT*\u003e(val)\"}],\"를 수행\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"false라면 nullptr를 반환\\n이 방식은 단순히 정수값(Enum) 비교만 수행하므로 dynamic_cast보다 훨씬 빠르고, VTable 이외의 추가적인 메타데이터를 생성하지 않아 효율적\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"LLVM이나 MLIR 코드를 보실 때 classof라는 함수가 보인다면, 대충 LLVM 스타일의 RTTI를 지원한다고 이해하면 됨.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"6) llvm::dyn_cast 내부에 classof를 쓴다.\\n일단 llvm-project/llvm/include/llvm/Support/Casting.h 를 들어가보면\"}],\"\\n\",\"$Le\",\"\\n\",\"$Lf\",\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\"]}],\"$L13\",\"$L14\"]}]\n"])</script><script>self.__next_f.push([1,"15:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"template \u003ctypename To, typename From\u003e\\n[[nodiscard]] inline decltype(auto) dyn_cast(const From \u0026Val) {\\n  assert(detail::isPresent(Val) \u0026\u0026 \\\"dyn_cast on a non-existent value\\\");\\n  return CastInfo\u003cTo, const From\u003e::doCastIfPossible(Val);\\n}\\n\\ntemplate \u003ctypename To, typename From\u003e\\n[[nodiscard]] inline decltype(auto) dyn_cast(From \u0026Val) {\\n  assert(detail::isPresent(Val) \u0026\u0026 \\\"dyn_cast on a non-existent value\\\");\\n  return CastInfo\u003cTo, From\u003e::doCastIfPossible(Val);\\n}\\n\\ntemplate \u003ctypename To, typename From\u003e\\n[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {\\n  assert(detail::isPresent(Val) \u0026\u0026 \\\"dyn_cast on a non-existent value\\\");\\n  return CastInfo\u003cTo, From *\u003e::doCastIfPossible(Val);\\n}\\n\\ntemplate \u003ctypename To, typename From\u003e\\n[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr\u003cFrom\u003e \u0026Val) {\\n  assert(detail::isPresent(Val) \u0026\u0026 \\\"dyn_cast on a non-existent value\\\");\\n  return CastInfo\u003cTo, std::unique_ptr\u003cFrom\u003e\u003e::doCastIfPossible(Val);\\n}\\n\"}]}]\nf:[\"$\",\"p\",null,{\"children\":\"요런식으로 구현 되어있음.\\nInterface 부분에서는 classof가 없고\\nCastInfo 라는 Trait 구조체 뒤로 구현 상세가 숨겨져 있음.\"}]\n10:[\"$\",\"p\",null,{\"children\":[\"즉 CastInfo \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" isa \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" classof 로 가는데\\n함수로 보자면 doCastIfPossible \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" isPossible \",[\"$\",\"code\",null,{\"children\":\"-\u003e\"}],\" doit 으로 가고\\n가장 마지막 바닥에 있는 isa_impl 에서\"]}]\n11:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"template \u003ctypename To, typename From, typename Enabler = void\u003e struct isa_impl {\\n  static inline bool doit(const From \u0026Val) { return To::classof(\u0026Val); }\\n};\\n\"}]}]\n12:[\"$\",\"p\",null,{\"children\":\"classof가 있음.\"}]\n13:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n14:[\"$\",\"$L15\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"16:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"MLIR에서 RTTI이 의미하는 것 - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"RTTI Stands For\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L16\",\"3\",{}]]\n8:null\n"])</script></body></html>