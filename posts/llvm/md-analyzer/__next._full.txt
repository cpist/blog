1:"$Sreact.fragment"
2:I[22016,["/blog/_next/static/chunks/796e69ae18b2784c.js"],""]
3:I[39756,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
4:I[37457,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"default"]
6:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"ViewportBoundary"]
b:I[97367,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"MetadataBoundary"]
d:I[68027,[],"default"]
:HL["/blog/_next/static/chunks/d335db6b3f1a2619.css","style"]
0:{"P":null,"b":"ECx2EdAxJn4Wxydum9dCL","c":["","posts","llvm","md-analyzer",""],"q":"","i":false,"f":[[["",{"children":["posts",{"children":[["slug","llvm/md-analyzer","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/blog/_next/static/chunks/d335db6b3f1a2619.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","script","script-0",{"src":"/blog/_next/static/chunks/796e69ae18b2784c.js","async":true,"nonce":"$undefined"}]],["$","html",null,{"lang":"ko","children":["$","body",null,{"children":["$","main",null,{"children":[["$","header",null,{"style":{"display":"flex","justifyContent":"space-between","alignItems":"baseline","gap":12},"children":[["$","h1",null,{"style":{"margin":"8px 0"},"children":["$","$L2",null,{"href":"/","style":{"textDecoration":"none"},"children":"CPIST's blog"}]}],["$","nav",null,{"style":{"display":"flex","gap":12},"children":["$","$L2",null,{"href":"/posts","children":"Posts"}]}]]}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"12px 0 24px"}}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","footer",null,{"style":{"marginTop":48,"paddingTop":16,"borderTop":"1px solid #eee","color":"#666"},"children":["© ",2026," CPIST's blog"]}]]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],null]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
5:["$","article",null,{"children":[["$","div",null,{"style":{"color":"#666","marginBottom":6},"children":["$","a",null,{"href":"/llvm","style":{"textDecoration":"none"},"children":["/","llvm"]}]}],["$","h2",null,{"style":{"marginTop":0},"children":"LLVM Static Analyzer"}],["$","div",null,{"style":{"color":"#666","marginBottom":18},"children":"2025-12-27"}],["$","p",null,{"style":{"color":"#333"},"children":"Clang Static Analyzer Basic Information"}],["$","hr",null,{"style":{"border":0,"borderTop":"1px solid #eee","margin":"18px 0"}}],["$","div",null,{"className":"prose","children":[["$","p",null,{"children":"clang은 LLVM 기반의 C/C++/Objective-C 컴파일러 프론트엔드이자 분석 인프라임."}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"라이브러리 구조 (Library Structure)\nClang Static Analyzer 는 2계층 구조로 구성되어 있음."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["정적 분석 엔진 (low-level engine)","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"핵심 파일 : ExprEngine.cpp"}],"\n",["$","li",null,{"children":"프로그램을 실제로 시뮬레이션 하면서 분석을 수행함."}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["체커 (Checkers)","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"파일 : *Checker.cpp"}],"\n",["$","li",null,{"children":"인터페이스: Checker, CheckerVisitor"}],"\n",["$","li",null,{"children":"엔진 위에서 동작하며 버그 조건을 정의"}],"\n",["$","li",null,{"children":"체커 작성자가 내부 엔진의 복잡한 구현을 몰라도 되도록 설계됨"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"기본 동작 원리"}],"\n"]}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"핵심 아이디어\nClang Static Analyzer는 소스 코드 실행 경로를 시뮬레이션 하는 분석기임."}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"실제 실행은 하지 않음"}],"\n",["$","li",null,{"children":"가능한 모든 실행 경로를 정적 분석으로 추적함"}],"\n"]}],"\n",["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"핵심 개념"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["ProgramState","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"프로그램의 상태"}],"\n",["$","li",null,{"children":"변수, 표현식 값, 제약 조건을 포함"}],"\n",["$","li",null,{"children":"불변(immutable) 객체"}],"\n",["$","li",null,{"children":"변경 시 항상 새 ProgramState 생성"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["ProgramPoint","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"프로그램 내의 특정 위치"}],"\n",["$","li",null,{"children":"CFG 상의 위치를 의미"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["ExplodedNode","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"(ProgramState, ProgramPoint) 의 쌍"}],"\n",["$","li",null,{"children":"분석 그래프의 노드"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["ExplodedGraph","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"모든 ExplodedNode 로 구성된 그래프"}],"\n",["$","li",null,{"children":"CFG의 각 엣지를 폭발(explode) 시켜서 만든 그래프"}],"\n",["$","li",null,{"children":"DAG가 아님, 루프 때문에 사이클이 가능"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"분석 방식"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["우선 Entry point 에서 시작함","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"초기 ProgramState + 시작 ProgramPoint"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["표현식 단위로 시뮬레이션","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["각 표현식 분석 시","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"상태 변경 가능"}],"\n",["$","li",null,{"children":"새로운 ExplodedNode 생성"}],"\n"]}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["버그 발견","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"특정 ExplodedNode가 버그 조건을 만족하면 발견함."}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"참고로 Explode(Exploded Graph) 의 개념에 대해 살펴보자면\nExplode 란 하나의 CFG 노드를 프로그램 상태별로 분해하여 여러 분석 노드로 확장하는 것임."}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"if (x > 0) {\n  y = 1;\n} else {\n  y = -1;\n}\n\n* CFG 관점에서는\nif 하나\ny=1, y=-1 두 경로\n\n* 반면 ExplodedGraph 관점:\nif 지점에서 상태가 두 개로 explode\n상태 A: x > 0 가정\n상태 B: x <= 0 가정\n이후 각 상태가 서로 다른 ProgramState로 독립 전파\n즉, 하나의 코드 지점이 여러 “의미 있는 상태 노드”로 폭발(explode)됨\n"}]}],"\n",["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"경로 민감 분석 (Path Sensitivity)"}],"\n"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["분기(if, while) 을 만나면","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"true 경로 / false 경로로 분기"}],"\n",["$","li",null,{"children":"각 경로마다 조건을 가정 (assumption)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["ConstraintManager","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"분기 조건에서 생성된 제약 조건 관리"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["불가능한 경로 제거","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"제약이 모순이면 해당 경로는 폐기"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"이 방식으로 path-sensitive analysis 구현함."}],"\n"]}],"\n",["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"성능 최적화 : 노드 캐싱"}],"\n"]}],"\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27","\n","$L28","\n","$L29","\n","$L2a","\n","$L2b","\n","$L2c","\n","$L2d","\n","$L2e","\n","$L2f"]}]]}]
e:["$","ul",null,{"children":["\n",["$","li",null,{"children":["동일한 (ProgramState, ProgramPoint) 가 다시 생성되면","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"새 노드를 생성하지 않고"}],"\n",["$","li",null,{"children":"기존 노드를 재사용함 (cache out)"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":"지수 폭발 (exponential blow-up) 방지"}],"\n"]}]
f:["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"불변성과 효율성"}],"\n"]}]
10:["$","ul",null,{"children":["\n",["$","li",null,{"children":"ProgramState와 ExplodedNode는 불변"}],"\n",["$","li",null,{"children":["내부 구현은 함수형 자료구조","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"(ex) ImmutableMap"}],"\n",["$","li",null,{"children":"상태 간 데이터 공유로 메모리 효율을 유지함."}],"\n"]}],"\n"]}],"\n"]}]
11:["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"Checker 의 역할과 동작"}],"\n"]}]
12:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Analyzer 엔진과 Checker 는 Visitor 패턴으로 통신함"}],"\n",["$","li",null,{"children":["예시로는 PreVisitCallExper()","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"함수 호출 전 호출됨"}],"\n",["$","li",null,{"children":"체커가 사전 조건(precondition) 을 검사함"}],"\n"]}],"\n"]}],"\n"]}]
13:["$","ul",null,{"children":["\n",["$","li",null,{"children":["Checker 가 할 수 있는 것은","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"아무것도 안하거나"}],"\n",["$","li",null,{"children":"새로운 ProgramState를 생성하거나"}],"\n",["$","li",null,{"children":"ExplodedNode를 생성하거나"}],"\n",["$","li",null,{"children":"버그 발견 시 BugReporter 에 보고함."}],"\n"]}],"\n"]}],"\n"]}]
14:["$","ol",null,{"start":"4","children":["\n",["$","li",null,{"children":"C++ 관련 특이사항"}],"\n"]}]
15:["$","ol",null,{"children":["\n",["$","li",null,{"children":"객체 생성 처리"}],"\n"]}]
16:["$","ul",null,{"children":["\n",["$","li",null,{"children":"생성자는 CFG에서 변수 선언보다 먼저 등장함"}],"\n",["$","li",null,{"children":"임시 객체 region을 생성하여 생성 대상을 저장함"}],"\n"]}]
17:["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"CXXConstructExpr 처리"}],"\n"]}]
18:["$","ul",null,{"children":["\n",["$","li",null,{"children":["processCallExit()","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"생성된 객체 region을 CXXConstructExpr 결과로 바인딩"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["VisitDeclStmt()","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"비참조 변수는 lazy compound value를 사용함"}],"\n",["$","li",null,{"children":"참조 변수는 객체 region을 직접 사용함"}],"\n"]}],"\n"]}],"\n"]}]
19:["$","ol",null,{"start":"3","children":["\n",["$","li",null,{"children":"this 포인터 처리"}],"\n"]}]
1a:["$","ul",null,{"children":["\n",["$","li",null,{"children":["메서드/생성자/소멸자 진입 시","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"'this' region 을 객체 region에 바인딩"}],"\n"]}],"\n"]}],"\n"]}]
1b:["$","pre",null,{"children":["$","code",null,{"children":"생성자의 경우 CXXREcordDecl* (타입 qualifier 무시)\n일반 메서드의 경우 CXXMethodDecl* (타입 qualifier 고려)\n"}]}]
1c:["$","p",null,{"children":"메서드 호출 단위 내에서만 일관성을 유지하면 문제가 없음."}]
1d:["$","ol",null,{"start":"5","children":["\n",["$","li",null,{"children":"Analyzer 개발 가이드"}],"\n"]}]
1e:["$","ol",null,{"children":["\n",["$","li",null,{"children":"엔진 개발 (표현식 지원 추가)"}],"\n"]}]
1f:["$","ul",null,{"children":["\n",["$","li",null,{"children":"ExprEngine의 visitation 로직을 확인"}],"\n",["$","li",null,{"children":"다양한 표현식 처리 예제가 이미 존재"}],"\n"]}]
20:["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"Checker 개발"}],"\n"]}]
21:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Checker.h, CheckerVisitor.h를 참고"}],"\n",["$","li",null,{"children":"기존 *Checker.cpp 파일들이 좋은 예제임"}],"\n"]}]
22:["$","ol",null,{"start":"6","children":["\n",["$","li",null,{"children":"디버깅 도구 (Debugging)\n유용한 옵션들"}],"\n"]}]
23:["$","pre",null,{"children":["$","code",null,{"children":"clang -cc1 -help | grep analyze\n"}]}]
24:["$","ul",null,{"children":["\n",["$","li",null,{"children":["-analyze-function","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"특정 함수만 분석"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["-analyzer-display-progress","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"현재 분석 중인 함수 출력"}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["-analyzer-viz-egraph-graphviz","\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"ExplodedGraph를 GraphViz로 출력"}],"\n"]}],"\n"]}],"\n"]}]
25:["$","p",null,{"children":"CFG 디버깅"}]
26:["$","pre",null,{"children":["$","code",null,{"children":"clang -cc1 -analyzer-checker=debug.DumpCFG\nclang -cc1 -analyzer-checker=debug.ViewCFG\n"}]}]
27:["$","ul",null,{"children":["\n",["$","li",null,{"children":"DumpCFG : 텍스트 출력"}],"\n",["$","li",null,{"children":"ViewCFG : GraphViz 시각화"}],"\n"]}]
28:["$","ol",null,{"start":"7","children":["\n",["$","li",null,{"children":"References"}],"\n"]}]
29:["$","ol",null,{"children":["\n",["$","li",null,{"children":"Reps et al., 1995"}],"\n"]}]
2a:["$","ul",null,{"children":["\n",["$","li",null,{"children":"그래프 도달성 기반 정밀 데이터플로우 분석"}],"\n"]}]
2b:["$","ol",null,{"start":"2","children":["\n",["$","li",null,{"children":"Xu, Kremenek, Zhang"}],"\n"]}]
2c:["$","ul",null,{"children":["\n",["$","li",null,{"children":"C 프로그램 정적 분석을 위한 메모리 모델"}],"\n"]}]
2d:["$","p",null,{"children":"====================================================================="}]
2e:["$","p",null,{"children":"요약해 보자면"}]
2f:["$","ul",null,{"children":["\n",["$","li",null,{"children":"Clang Static Analyzer는 CFG 기반 경로 민감 시뮬레이션 분석기로"}],"\n",["$","li",null,{"children":"불변 상태 + 제약 기반 분기 + 노드 캐싱을 통해 정확성과 성능을 동시에 달성하며"}],"\n",["$","li",null,{"children":"Checker는 엔진 위에서 버그 조건만 정의하도록 분리된 구조를 가진다"}],"\n"]}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
30:I[27201,["/blog/_next/static/chunks/ff1a16fafef87110.js","/blog/_next/static/chunks/247eb132b7f7b574.js"],"IconMark"]
c:[["$","title","0",{"children":"LLVM Static Analyzer - CPIST's blog"}],["$","meta","1",{"name":"description","content":"Clang Static Analyzer Basic Information"}],["$","link","2",{"rel":"icon","href":"/blog/favicon.ico?favicon.0b3bf435.ico","sizes":"256x256","type":"image/x-icon"}],["$","$L30","3",{}]]
8:null
