<!DOCTYPE html><!--qpYlHngKSPQ9cyVqK9zM6--><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/blog/_next/static/chunks/d335db6b3f1a2619.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/blog/_next/static/chunks/2139e000f4b5d584.js"/><script src="/blog/_next/static/chunks/8a8ef77865bda9e6.js" async=""></script><script src="/blog/_next/static/chunks/0ff423a9fcc0186e.js" async=""></script><script src="/blog/_next/static/chunks/88a8688d62cd2814.js" async=""></script><script src="/blog/_next/static/chunks/turbopack-566b9f8f22ac84c4.js" async=""></script><script src="/blog/_next/static/chunks/796e69ae18b2784c.js" async=""></script><script src="/blog/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/blog/_next/static/chunks/247eb132b7f7b574.js" async=""></script><script src="/blog/_next/static/chunks/631eeae4923b8465.js" async=""></script><title>LLVM Static Analyzer - CPIST&#x27;s blog</title><meta name="description" content="Clang Static Analyzer Basic Information"/><link rel="icon" href="/blog/favicon.ico?favicon.0b3bf435.ico" sizes="256x256" type="image/x-icon"/><script src="/blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><main><header style="display:flex;justify-content:space-between;align-items:baseline;gap:12px"><h1 style="margin:8px 0"><a style="text-decoration:none" href="/blog/">CPIST&#x27;s blog</a></h1><nav style="display:flex;gap:12px"><a href="/blog/posts/">Posts</a></nav></header><hr style="border:0;border-top:1px solid #eee;margin:12px 0 24px"/><article><div style="color:#666;margin-bottom:6px"><a href="/llvm" style="text-decoration:none">/<!-- -->llvm</a></div><h2 style="margin-top:0">LLVM Static Analyzer</h2><div style="color:#666;margin-bottom:18px">2025-12-27</div><p style="color:#333">Clang Static Analyzer Basic Information</p><hr style="border:0;border-top:1px solid #eee;margin:18px 0"/><div class="prose"><p>clang은 LLVM 기반의 C/C++/Objective-C 컴파일러 프론트엔드이자 분석 인프라임.</p>
<p>1) 라이브러리 구조 (Library Structure)
Clang Static Analyzer 는 2계층 구조로 구성되어 있음.</p>
<ul>
<li>정적 분석 엔진 (low-level engine)<!-- -->
<ul>
<li>핵심 파일 : ExprEngine.cpp</li>
<li>프로그램을 실제로 시뮬레이션 하면서 분석을 수행함.</li>
</ul>
</li>
<li>체커 (Checkers)<!-- -->
<ul>
<li>파일 : *Checker.cpp</li>
<li>인터페이스: Checker, CheckerVisitor</li>
<li>엔진 위에서 동작하며 버그 조건을 정의</li>
<li>체커 작성자가 내부 엔진의 복잡한 구현을 몰라도 되도록 설계됨</li>
</ul>
</li>
</ul>
<p>2) 기본 동작 원리</p>
<ol>
<li>핵심 아이디어
Clang Static Analyzer는 소스 코드 실행 경로를 시뮬레이션 하는 분석기임.</li>
</ol>
<ul>
<li>실제 실행은 하지 않음</li>
<li>가능한 모든 실행 경로를 정적 분석으로 추적함</li>
</ul>
<ol start="2">
<li>핵심 개념</li>
</ol>
<ul>
<li>ProgramState<!-- -->
<ul>
<li>프로그램의 상태</li>
<li>변수, 표현식 값, 제약 조건을 포함</li>
<li>불변(immutable) 객체</li>
<li>변경 시 항상 새 ProgramState 생성</li>
</ul>
</li>
<li>ProgramPoint<!-- -->
<ul>
<li>프로그램 내의 특정 위치</li>
<li>CFG 상의 위치를 의미</li>
</ul>
</li>
<li>ExplodedNode<!-- -->
<ul>
<li>(ProgramState, ProgramPoint) 의 쌍</li>
<li>분석 그래프의 노드</li>
</ul>
</li>
<li>ExplodedGraph<!-- -->
<ul>
<li>모든 ExplodedNode 로 구성된 그래프</li>
<li>CFG의 각 엣지를 폭발(explode) 시켜서 만든 그래프</li>
<li>DAG가 아님, 루프 때문에 사이클이 가능</li>
</ul>
</li>
</ul>
<ol start="3">
<li>분석 방식</li>
</ol>
<ul>
<li>우선 Entry point 에서 시작함<!-- -->
<ul>
<li>초기 ProgramState + 시작 ProgramPoint</li>
</ul>
</li>
<li>표현식 단위로 시뮬레이션<!-- -->
<ul>
<li>각 표현식 분석 시<!-- -->
<ul>
<li>상태 변경 가능</li>
<li>새로운 ExplodedNode 생성</li>
</ul>
</li>
</ul>
</li>
<li>버그 발견<!-- -->
<ul>
<li>특정 ExplodedNode가 버그 조건을 만족하면 발견함.</li>
</ul>
</li>
</ul>
<ul>
<li>참고로 Explode(Exploded Graph) 의 개념에 대해 살펴보자면
Explode 란 하나의 CFG 노드를 프로그램 상태별로 분해하여 여러 분석 노드로 확장하는 것임.</li>
</ul>
<pre><code>if (x &gt; 0\) {
  y = 1;
} else {
  y = -1;
}

* CFG 관점에서는
if 하나
y=1, y=-1 두 경로

* 반면 ExplodedGraph 관점:
if 지점에서 상태가 두 개로 explode
상태 A: x &gt; 0 가정
상태 B: x &lt;= 0 가정
이후 각 상태가 서로 다른 ProgramState로 독립 전파
즉, 하나의 코드 지점이 여러 “의미 있는 상태 노드”로 폭발(explode)됨
</code></pre>
<ol start="4">
<li>경로 민감 분석 (Path Sensitivity)</li>
</ol>
<ul>
<li>분기(if, while) 을 만나면<!-- -->
<ul>
<li>true 경로 / false 경로로 분기</li>
<li>각 경로마다 조건을 가정 (assumption)</li>
</ul>
</li>
<li>ConstraintManager<!-- -->
<ul>
<li>분기 조건에서 생성된 제약 조건 관리</li>
</ul>
</li>
<li>불가능한 경로 제거<!-- -->
<ul>
<li>제약이 모순이면 해당 경로는 폐기</li>
</ul>
</li>
<li>이 방식으로 path-sensitive analysis 구현함.</li>
</ul>
<ol start="5">
<li>성능 최적화 : 노드 캐싱</li>
</ol>
<ul>
<li>동일한 (ProgramState, ProgramPoint) 가 다시 생성되면<!-- -->
<ul>
<li>새 노드를 생성하지 않고</li>
<li>기존 노드를 재사용함 (cache out)</li>
</ul>
</li>
<li>지수 폭발 (exponential blow-up) 방지</li>
</ul>
<ol start="6">
<li>불변성과 효율성</li>
</ol>
<ul>
<li>ProgramState와 ExplodedNode는 불변</li>
<li>내부 구현은 함수형 자료구조<!-- -->
<ul>
<li>(ex) ImmutableMap</li>
<li>상태 간 데이터 공유로 메모리 효율을 유지함.</li>
</ul>
</li>
</ul>
<p>3) Checker 의 역할과 동작</p>
<ul>
<li>Analyzer 엔진과 Checker 는 Visitor 패턴으로 통신함</li>
<li>예시로는 PreVisitCallExper()<!-- -->
<ul>
<li>함수 호출 전 호출됨</li>
<li>체커가 사전 조건(precondition) 을 검사함</li>
</ul>
</li>
</ul>
<ul>
<li>Checker 가 할 수 있는 것은<!-- -->
<ul>
<li>아무것도 안하거나</li>
<li>새로운 ProgramState를 생성하거나</li>
<li>ExplodedNode를 생성하거나</li>
<li>버그 발견 시 BugReporter 에 보고함.</li>
</ul>
</li>
</ul>
<p>4) C++ 관련 특이사항</p>
<ol>
<li>객체 생성 처리</li>
</ol>
<ul>
<li>생성자는 CFG에서 변수 선언보다 먼저 등장함</li>
<li>임시 객체 region을 생성하여 생성 대상을 저장함</li>
</ul>
<ol start="2">
<li>CXXConstructExpr 처리</li>
</ol>
<ul>
<li>processCallExit()<!-- -->
<ul>
<li>생성된 객체 region을 CXXConstructExpr 결과로 바인딩</li>
</ul>
</li>
<li>VisitDeclStmt()<!-- -->
<ul>
<li>비참조 변수는 lazy compound value를 사용함</li>
<li>참조 변수는 객체 region을 직접 사용함</li>
</ul>
</li>
</ul>
<ol start="3">
<li>this 포인터 처리</li>
</ol>
<ul>
<li>메서드/생성자/소멸자 진입 시<!-- -->
<ul>
<li>&#x27;this&#x27; region 을 객체 region에 바인딩</li>
</ul>
</li>
</ul>
<pre><code>생성자의 경우 CXXREcordDecl* (타입 qualifier 무시)
일반 메서드의 경우 CXXMethodDecl* (타입 qualifier 고려)
</code></pre>
<p>메서드 호출 단위 내에서만 일관성을 유지하면 문제가 없음.</p>
<p>5) Analyzer 개발 가이드</p>
<ol>
<li>엔진 개발 (표현식 지원 추가)</li>
</ol>
<ul>
<li>ExprEngine의 visitation 로직을 확인</li>
<li>다양한 표현식 처리 예제가 이미 존재</li>
</ul>
<ol start="2">
<li>Checker 개발</li>
</ol>
<ul>
<li>Checker.h, CheckerVisitor.h를 참고</li>
<li>기존 *Checker.cpp 파일들이 좋은 예제임</li>
</ul>
<p>6) 디버깅 도구 (Debugging)
유용한 옵션들</p>
<pre><code>clang -cc1 -help | grep analyze
</code></pre>
<ul>
<li>-analyze-function<!-- -->
<ul>
<li>특정 함수만 분석</li>
</ul>
</li>
<li>-analyzer-display-progress<!-- -->
<ul>
<li>현재 분석 중인 함수 출력</li>
</ul>
</li>
<li>-analyzer-viz-egraph-graphviz<!-- -->
<ul>
<li>ExplodedGraph를 GraphViz로 출력</li>
</ul>
</li>
</ul>
<p>CFG 디버깅</p>
<pre><code>clang -cc1 -analyzer-checker=debug.DumpCFG
clang -cc1 -analyzer-checker=debug.ViewCFG
</code></pre>
<ul>
<li>DumpCFG : 텍스트 출력</li>
<li>ViewCFG : GraphViz 시각화</li>
</ul>
<p>7) References</p>
<ol>
<li>Reps et al., 1995</li>
</ol>
<ul>
<li>그래프 도달성 기반 정밀 데이터플로우 분석</li>
</ul>
<ol start="2">
<li>Xu, Kremenek, Zhang</li>
</ol>
<ul>
<li>C 프로그램 정적 분석을 위한 메모리 모델</li>
</ul>
<p>=====================================================================</p>
<p>요약해 보자면</p>
<ul>
<li>Clang Static Analyzer는 CFG 기반 경로 민감 시뮬레이션 분석기로</li>
<li>불변 상태 + 제약 기반 분기 + 노드 캐싱을 통해 정확성과 성능을 동시에 달성하며</li>
<li>Checker는 엔진 위에서 버그 조건만 정의하도록 분리된 구조를 가진다</li>
</ul></div><hr style="border:0;border-top:1px solid #eee;margin:36px 0"/><div></div></article><!--$--><!--/$--><footer style="margin-top:48px;padding-top:16px;border-top:1px solid #eee;color:#666">© <!-- -->2026<!-- --> CPIST&#x27;s blog</footer></main><script src="/blog/_next/static/chunks/2139e000f4b5d584.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[22016,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\"],\"\"]\n3:I[39756,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n4:I[37457,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"default\"]\n6:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"ViewportBoundary\"]\nb:I[97367,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"MetadataBoundary\"]\nd:I[68027,[],\"default\"]\n:HL[\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"qpYlHngKSPQ9cyVqK9zM6\",\"c\":[\"\",\"posts\",\"llvm\",\"md-analyzer\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"llvm/md-analyzer\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/blog/_next/static/chunks/d335db6b3f1a2619.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"main\",null,{\"children\":[[\"$\",\"header\",null,{\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"baseline\",\"gap\":12},\"children\":[[\"$\",\"h1\",null,{\"style\":{\"margin\":\"8px 0\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"textDecoration\":\"none\"},\"children\":\"CPIST's blog\"}]}],[\"$\",\"nav\",null,{\"style\":{\"display\":\"flex\",\"gap\":12},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/posts\",\"children\":\"Posts\"}]}]]}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"12px 0 24px\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"style\":{\"marginTop\":48,\"paddingTop\":16,\"borderTop\":\"1px solid #eee\",\"color\":\"#666\"},\"children\":[\"© \",2026,\" CPIST's blog\"]}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/blog/_next/static/chunks/631eeae4923b8465.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":6},\"children\":[\"$\",\"a\",null,{\"href\":\"/llvm\",\"style\":{\"textDecoration\":\"none\"},\"children\":[\"/\",\"llvm\"]}]}],[\"$\",\"h2\",null,{\"style\":{\"marginTop\":0},\"children\":\"LLVM Static Analyzer\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#666\",\"marginBottom\":18},\"children\":\"2025-12-27\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#333\"},\"children\":\"Clang Static Analyzer Basic Information\"}],[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"18px 0\"}}],[\"$\",\"div\",null,{\"className\":\"prose\",\"children\":[[\"$\",\"p\",null,{\"children\":\"clang은 LLVM 기반의 C/C++/Objective-C 컴파일러 프론트엔드이자 분석 인프라임.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"1) 라이브러리 구조 (Library Structure)\\nClang Static Analyzer 는 2계층 구조로 구성되어 있음.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"정적 분석 엔진 (low-level engine)\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핵심 파일 : ExprEngine.cpp\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"프로그램을 실제로 시뮬레이션 하면서 분석을 수행함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"체커 (Checkers)\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"파일 : *Checker.cpp\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"인터페이스: Checker, CheckerVisitor\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"엔진 위에서 동작하며 버그 조건을 정의\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"체커 작성자가 내부 엔진의 복잡한 구현을 몰라도 되도록 설계됨\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"2) 기본 동작 원리\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핵심 아이디어\\nClang Static Analyzer는 소스 코드 실행 경로를 시뮬레이션 하는 분석기임.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"실제 실행은 하지 않음\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"가능한 모든 실행 경로를 정적 분석으로 추적함\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"핵심 개념\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"ProgramState\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"프로그램의 상태\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"변수, 표현식 값, 제약 조건을 포함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"불변(immutable) 객체\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"변경 시 항상 새 ProgramState 생성\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"ProgramPoint\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"프로그램 내의 특정 위치\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CFG 상의 위치를 의미\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"ExplodedNode\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"(ProgramState, ProgramPoint) 의 쌍\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석 그래프의 노드\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"ExplodedGraph\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"모든 ExplodedNode 로 구성된 그래프\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"CFG의 각 엣지를 폭발(explode) 시켜서 만든 그래프\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"DAG가 아님, 루프 때문에 사이클이 가능\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분석 방식\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"우선 Entry point 에서 시작함\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"초기 ProgramState + 시작 ProgramPoint\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"표현식 단위로 시뮬레이션\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"각 표현식 분석 시\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"상태 변경 가능\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"새로운 ExplodedNode 생성\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"버그 발견\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"특정 ExplodedNode가 버그 조건을 만족하면 발견함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"참고로 Explode(Exploded Graph) 의 개념에 대해 살펴보자면\\nExplode 란 하나의 CFG 노드를 프로그램 상태별로 분해하여 여러 분석 노드로 확장하는 것임.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"if (x \u003e 0\\\\) {\\n  y = 1;\\n} else {\\n  y = -1;\\n}\\n\\n* CFG 관점에서는\\nif 하나\\ny=1, y=-1 두 경로\\n\\n* 반면 ExplodedGraph 관점:\\nif 지점에서 상태가 두 개로 explode\\n상태 A: x \u003e 0 가정\\n상태 B: x \u003c= 0 가정\\n이후 각 상태가 서로 다른 ProgramState로 독립 전파\\n즉, 하나의 코드 지점이 여러 “의미 있는 상태 노드”로 폭발(explode)됨\\n\"}]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"경로 민감 분석 (Path Sensitivity)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"분기(if, while) 을 만나면\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"true 경로 / false 경로로 분기\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"각 경로마다 조건을 가정 (assumption)\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"ConstraintManager\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"분기 조건에서 생성된 제약 조건 관리\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"불가능한 경로 제거\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"제약이 모순이면 해당 경로는 폐기\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"이 방식으로 path-sensitive analysis 구현함.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"start\":\"5\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"성능 최적화 : 노드 캐싱\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"동일한 (ProgramState, ProgramPoint) 가 다시 생성되면\",\"\\n\",\"$Le\",\"\\n\"]}],\"\\n\",\"$Lf\",\"\\n\"]}],\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\",\"\\n\",\"$L28\",\"\\n\",\"$L29\",\"\\n\",\"$L2a\",\"\\n\",\"$L2b\",\"\\n\",\"$L2c\",\"\\n\",\"$L2d\",\"\\n\",\"$L2e\",\"\\n\",\"$L2f\",\"\\n\",\"$L30\"]}],\"$L31\",\"$L32\"]}]\n"])</script><script>self.__next_f.push([1,"33:I[80852,[\"/blog/_next/static/chunks/796e69ae18b2784c.js\",\"/blog/_next/static/chunks/631eeae4923b8465.js\"],\"default\"]\ne:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"새 노드를 생성하지 않고\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"기존 노드를 재사용함 (cache out)\"}],\"\\n\"]}]\nf:[\"$\",\"li\",null,{\"children\":\"지수 폭발 (exponential blow-up) 방지\"}]\n10:[\"$\",\"ol\",null,{\"start\":\"6\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"불변성과 효율성\"}],\"\\n\"]}]\n11:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"ProgramState와 ExplodedNode는 불변\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"내부 구현은 함수형 자료구조\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"(ex) ImmutableMap\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"상태 간 데이터 공유로 메모리 효율을 유지함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n12:[\"$\",\"p\",null,{\"children\":\"3) Checker 의 역할과 동작\"}]\n13:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Analyzer 엔진과 Checker 는 Visitor 패턴으로 통신함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"예시로는 PreVisitCallExper()\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"함수 호출 전 호출됨\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"체커가 사전 조건(precondition) 을 검사함\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n14:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Checker 가 할 수 있는 것은\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"아무것도 안하거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"새로운 ProgramState를 생성하거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"ExplodedNode를 생성하거나\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"버그 발견 시 BugReporter 에 보고함.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n15:[\"$\",\"p\",null,{\"children\":\"4) C++ 관련 특이사항\"}]\n16:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"객체 생성 처리\"}],\"\\n\"]}]\n17:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"생성자는 CFG에서 변수 선언보다 먼저 등장함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"임시 객체 region을 생성하여 생성 대상을 저장함\"}],\"\\n\"]}]\n18:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"CXXConstructExpr 처리\"}],\"\\n\"]}]\n19:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"processCallExit()\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"생성된 객체 region을 CXXConstructExpr 결과로 바인딩\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"VisitDeclStmt()\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"비참조 변수는 lazy compound value를 사용함\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"참조 변수는 객체 region을 직접 사용함\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n1a:[\"$\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"this 포인터 처리\"}],\"\\n\"]}]\n1b:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"메서드/생성자/소멸자 진입 시\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"'this' region 을 객체 region에 바인딩\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n1c:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"생성자의 경우 CXXREcordDecl* (타입 qualifier 무시)\\n일반 메서드의 경우 CXXMethodDecl* (타입 qualifier 고려)\\n\"}]}]\n1d:[\"$\",\"p\",null,{\"children\":\"메서드 호출 단위 내에서만 일관성을 유지하면 문제가 없음.\"}]\n1e:[\"$\",\"p\",null,{\"children\":\"5) Analyzer 개발 가이드\"}]\n1f:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"엔진 개발 (표현식 지원 추가)\"}],\"\\n\"]}]\n20:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"ExprEngine의 visitation 로직을 확인\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다양한 표현식 처리 예제가 이미 존재\"}],\"\\n\"]}]\n21:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Checker 개발\"}],\"\\n\"]}]\n22:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Checker.h, CheckerVisitor.h를 참고\"}],\"\\n\",[\"$\",\"li\",null,{\"ch"])</script><script>self.__next_f.push([1,"ildren\":\"기존 *Checker.cpp 파일들이 좋은 예제임\"}],\"\\n\"]}]\n23:[\"$\",\"p\",null,{\"children\":\"6) 디버깅 도구 (Debugging)\\n유용한 옵션들\"}]\n24:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"clang -cc1 -help | grep analyze\\n\"}]}]\n25:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"-analyze-function\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"특정 함수만 분석\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"-analyzer-display-progress\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"현재 분석 중인 함수 출력\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"-analyzer-viz-egraph-graphviz\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"ExplodedGraph를 GraphViz로 출력\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}]\n26:[\"$\",\"p\",null,{\"children\":\"CFG 디버깅\"}]\n27:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"clang -cc1 -analyzer-checker=debug.DumpCFG\\nclang -cc1 -analyzer-checker=debug.ViewCFG\\n\"}]}]\n28:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"DumpCFG : 텍스트 출력\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"ViewCFG : GraphViz 시각화\"}],\"\\n\"]}]\n29:[\"$\",\"p\",null,{\"children\":\"7) References\"}]\n2a:[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Reps et al., 1995\"}],\"\\n\"]}]\n2b:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"그래프 도달성 기반 정밀 데이터플로우 분석\"}],\"\\n\"]}]\n2c:[\"$\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Xu, Kremenek, Zhang\"}],\"\\n\"]}]\n2d:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"C 프로그램 정적 분석을 위한 메모리 모델\"}],\"\\n\"]}]\n2e:[\"$\",\"p\",null,{\"children\":\"=====================================================================\"}]\n2f:[\"$\",\"p\",null,{\"children\":\"요약해 보자면\"}]\n30:[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Clang Static Analyzer는 CFG 기반 경로 민감 시뮬레이션 분석기로\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"불변 상태 + 제약 기반 분기 + 노드 캐싱을 통해 정확성과 성능을 동시에 달성하며\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Checker는 엔진 위에서 버그 조건만 정의하도록 분리된 구조를 가진다\"}],\"\\n\"]}]\n31:[\"$\",\"hr\",null,{\"style\":{\"border\":0,\"borderTop\":\"1px solid #eee\",\"margin\":\"36px 0\"}}]\n32:[\"$\",\"$L33\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"34:I[27201,[\"/blog/_next/static/chunks/ff1a16fafef87110.js\",\"/blog/_next/static/chunks/247eb132b7f7b574.js\"],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"LLVM Static Analyzer - CPIST's blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Clang Static Analyzer Basic Information\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/blog/favicon.ico?favicon.0b3bf435.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"}],[\"$\",\"$L34\",\"3\",{}]]\n8:null\n"])</script></body></html>