---
title: "MLIR Tutorial DataFlow Analysis 에 대하여"
date: "2025-12-14"
summary: "Quickstart tutorial to adding MLIR graph rewrite"
tags: ["mlir", "Graph rewrite"]
draft: false
---

1) MLIR 에서 그래프 rewrite(변환) 은 어떻게 추가할 수 있을까?

일반적인 흐름은 다음과 같음
```
1. Operation(연산) 정의
2. Rewrite 패턴 정의 (TableGen / C++)
3. 패턴 등록
4. Rewrite 방식의 종류
5. 테스트 방법
6. 필요 시 일반 최적화 패스 작성

원칙적으로는 패턴 + Rewrite Engine 사용이 권장됨.
그래프 워커 방식은 어디까지나 개념을 설명하기 위한 것
```

2) MLIR Operation 정의 (TableGen)
MLIR의 연산(Operation) 은 TableGen(.td) 파일로 정의가 된다.
Operation 정의에 필요한 요소는 아래와 같음.
- Operation 이름
  - Dialect 내에서 유일함
  - tfl.leaky_relu
- Traits
  - 연산의 성질 (부작용이 없고, 타입이 동일함)
  - C++ 검증 로직과 연결됨
- Arguments
  - Operands : 런타임 입력 값
  - Attributes : 컴파일 타임 상수 값 (반드시 이름이 필요함)
- Results
  - 출력 값 (여러 개 가능)
- 문서화
  - Summary + 상세 설명
- Dialect 전용 메타데이터
  - ex) TFLite FlatBuffer 생성 옵션

추가 기능으로서 Operation은 필요에 따라 다음을 가질 수 있음.
- Custom parser / printer
- Builder
- Verifier
- Constant folder
- Canonicalizer
상수 폴딩은 fold() 메서드로 구현함.

3) Rewrite(그래프 변환) 개념
MLIR에서 가장 일반적인 변환은 DAG `->` DAG 변환임.
이를 표현하는 가장 중요한 수단이 계속 말하는 Rewrite Pattern 이다.

4) TableGen 기반의 Rewrite 패턴
- 기본 패턴 (Pat)
  - Source DAG `->` Result DAG 형태
  - Source에서 캡처한 값 / 속성을 Result 에서 재사용 가능
  - 단순 1:1 변환에 매우 적합
- tf.LeakyRelu 를 tfl.LeakyRelu 로 바꾸는게 예시
```
%y = "tf.LeakyRelu"(%x) {alpha: 0.1} : (tensor<1xf32>) -> tensor<1xf32>

에서

%y = "tfl.leaky_relu"(%x) {alpha: 1.000000e-01} : (tensor<1xf32>) -> tensor<1xf32>
로 바뀜.
```
IR 의미상으로는 프런트엔드 (TF) 를 백엔드/타겟(TFLite) op로 'legalize' 하는 단계임
추가 변환이 없으면 alpha 변환 / 클램프 같은건 안하고 그냥 복사를 함.

* 이제 NativeCodeCall 같은 복잡한 케이스에 대해서는
- 즉 TableGen으로 표현하기 어려운 경우가 있음
- 이럴 때는 C++ 함수로 직접 연산을 생성함.
- 임의로 복잡한 로직이 가능함
- 다만 제약은 있는데 입력 패턴에서 다중 operand / attribute 간 제약 포현은 제한적이다.

5) 패턴은 어떻게 등록하는가?
1. .td 파일을 mlir-tblgen -gen-rewriters로 처리한다.
2. CMake 설징이 필요함
3. 생성된 .inc 파일을 포함해서
4. populateWithGenerated(RewritePatternSet&) 을 호출한다.
생성된 패턴을 Pass에서 사용이 가능하다.

6) C++ 기반의 Rewrite 방식들
1. matchAndRewrite 함수 스타일
- 간단한 변환에 적합함
- 함수 하나로 패턴 + 리라이트를 구현함
- 직접 RewritePatternSet 에 추가함
ODS 에서는 hasCanonicalizeMethod = 1 로 연산별 canonicalization 도 지원함.

2. Canonicalization 메서드
- Operation 자체에 귀속된 간단한 최적화
- mul(x, power_of_2) 를 shl(x, log2) 로
- 당연히 복잡한 패턴이나 다중 연산 매칭에는 한계가 있음

3. 일반 RewritePattern 클래스
- 가장 강력하고 범용적인 방식임
- 직접
  - 매칭 로직
  - 리라이트 로직
  - 우선순위(benefit) 지정이 가능함
- 복잡한 경우에는
  - PatternState를 사용해 match 단계의 정보를 전달함.
matchAndRewrite는 단일 단계 변환에 특히 편리함.

7) Rewrite 우선 순위 (Benefit)
- C++ RewritePattern은 명시적으로 benefit을 지정함
- TableGen 패턴은 매칭 / 대체 op 수 기반의 휴리스틱 방식임.

8) 테스트는 lit + FileCheck를 이용함
MLIR의 경우 IR 기반 테스트를 중심으로 한다.
테스트 방식은 
```
입력 MLIR을 작성하고 -> mlir-opt로 특정 패스를 실행한 뒤 -> FileCheck로 결과를 검증한다.
```
장점으로는 
- 바이너리 테스트를 최소화하고
- IR 표현 자체를 명확히 검증하며
- 독립적이고 단순한 테스트 구성이 가능하다는 것이다.

9) 최적화 패스 작성
- 패턴 기반으로 표현하기 어려운 경우
- 모듈/함수 단위 순회 패스로 구현이 가능함
- MLIR Pass Infrastructure 사용

=====================================================================

요약해 보자면
MLIR Graph Rewrite는 아래와 같은 흐름으로 구성된다.
```
Operation 정의 → Rewrite 패턴(TableGen/C++) → 패턴 등록 → lit 기반 IR 테스트
```
왠만하면 패턴 기반의 Rewrite Engine을 쓰자!