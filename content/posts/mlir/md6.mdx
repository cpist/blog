---
title: "MLIR Toy Tutorial Ch 6 에 대하여"
date: "2025-11-09"
summary: "Lowering to LLVM and code generation. Here we'll
    target LLVM IR for code generation, and detail more of the lowering
    framework."
tags: ["mlir", "dialect"]
draft: false
---

1) 이제 Toy 언어 -> MLIR -> LLVM -> 실제 실행되는 코드 (JIT) 로 간다.
진짜 프로그램을 돌리는 것.

여기서 LLVM으로 낮춘다는 말을 쓰느데
LLVM은 컴파일러 인프라이고, MLIR이 LLVM이 사용할 수 있는 IR을 만들어 주는 것이다.
즉 LLVM 인프라가 처리할 수 있는 IR 형태로 바꿔주는 것이 MLIR

```
Toy / TensorFlow / PyTorch / DSL
        ↓
     MLIR (여러 dialect)
        ↓
   MLIR LLVM dialect
        ↓
     LLVM IR (.ll)
        ↓
   LLVM Optimizer + Backend
        ↓
    실행 파일 / JIT 실행
```

그리고 LLVM의 구성요소도 짤막하게 정리해 보자면

- LLVM IR : 저수준 중간 표현
- Optimizer : IR 최적화
- CodeGen : IR `->` 머신 코드
- JIT : 즉석 컴파일
- Backend : x86, ARM 등 타깃 아키텍쳐에 맞게 LLVM IR 을 머신 코드로 변환

2) Step 1 : Toy -> LLVM (Lowering)
이전 장에서 다룬 내용을 통해 toy 연산은 이미 affine / scf / arith 같은 표준 MLIR로 바꿔놓았다.
남은건 toy.print 이다.

toy.print 는 
- 내부적으로 C의 printf를 부르거나
- 배열을 이중 for-loop 로 돌면서 하나씩 출력하거나
- MLIR의 transitive lowering 덕분에 바로 LLVM을 만들지 않더라도, 중간 단계를 거쳐 자동으로 LLVM 까지 갈수 있다.

* printf 함수는 어디에서 오는가?
필요한 경우 LLVM 모듈 안에서 printf 선언을 자동으로 추가함

```
i32 printf(i8*, ...)
```

- 이미 있으면 재사용
- 없으면 새로 만들어 넣기
- 필요한 외부함수는 알아서 미리 준비한다.

3) Step 2 : Conversion 설정
(1) Conversion target
- 목표는 LLVM dialect 만 남기기
- ModuleOp + LLVMDialect 만 허용

(2) Type Converter
- memref `->` LLVM 포인터 구조체로 변환
- Toy 전용 타입이 없어서 기본 LLVMTypeConverter면 충분

(3) Conversion Patterns
- affine -> std
- scf -> control flow
- arith -> LLVM
- func -> LLVM
- cf -> LLVM
- toy.print 전용 lowering 패턴
즉 모든 연산을 LLVM으로 변환 가능하다는 것.
이 것들은 dialect를 다른 dialect로 바꾸는 변환 패턴임.
dialect 는 연산(op) 와 타입(type) 의 언어 묶음 이었음. (아래 예시와 같이)

```
affine dialect → affine.for, affine.load
scf dialect → scf.for, scf.if
arith dialect → arith.addf, arith.mulf
llvm dialect → llvm.load, llvm.call
```

즉 어떤 연산들이 있는지를 정의하는 것.
그리고 이 연산을 다른 연산으로 바꾸는 것이 바로 Conversion pattern (Rewrite Pattern)

```
affine.for → scf.for
scf.for → cf.br + 블록
arith.addf → llvm.fadd
func.func → llvm.func

MLIR 코드에서는 아래와 같이 Conversion 레시피 묶음을 등록함.
populateAffineToStdConversionPatterns(...)
populateSCFToControlFlowConversionPatterns(...)
populateArithToLLVMConversionPatterns(...)
populateFuncToLLVMConversionPatterns(...)
```

대부분의 dialect 에서 자기 자신을 LLVM으로 낮추는 변환 패턴을 함께 제공하지만, dialect != conversion pattern이다.

(4) Full Conversion

```
applyFullConversion(...)
```
LLVM 아닌 연산이 하나라도 남으면 실패 
이는 곧 아주 깔끔한 LLVM-only IR 이다.

(5) 예제 결과 : LLVM dialect MLIR
- malloc, free, printf 호출
- 포인터 연산
- GEP, load, call, br 등
- 완전한 저수준 코드
컴파일러가 본격적으로 시작하는 느낌이다.

4) Step 3 : LLVM IR로 변환
MLIR이 끝났기 때문에 LLVM IR(.ll) 로 변환을 한다.

```
translateModuleToLLVMIR(...)
```

- 이 결과를 보면 처음에는 되게 길고 복잡한 IR 처럼 보이지만
- 최적화를 켜면 반복문도 사라지고, 상수가 계산되고, printf만 쭉 남게 된다.
- 이는 컴파일러가 계산을 미리 다 해버리기 때문이다.

5) Step 4 : JIT로 바로 실행
이는 MLIR의 ExecutionEngine을 사용해서 가능하다.
(1) LLVM 타겟을 초기화하고
(2) 최적화 파이프라인을 설정하고
(3) JIT 컴파일을 진행하고
(4) main() 을 호출한다.

```
engine->invoke("main");
```

파일을 바로 저장하는 것이 아닌 바로 메모리에서 실행을 한다.

```
$ echo 'def main() { print([[1, 2], [3, 4]]); }' | ./toyc-ch6 -emit=jit

했을때 출력 결과는

1.000000 2.000000
3.000000 4.000000
```

Toy 언어가 실제 프로그램 처럼 실행된다.

=====================================================================

이 장의 내용을 요약해 보자면
- MLIR은 단계적으로 LLVM 까지 낮츨 수 있고
- Dialect Conversion + Transitive Lowering = 자동 변환이고
- toy.print `->` printf
- LLVM IR `->` 최적화 `->` JIT 실행
- Toy 를 실행 가능한 언어로 만들었다.







