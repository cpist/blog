---
title: "MLIR Tutorial md6 에 대하여"
date: "2025-11-09"
summary: "Lowering to LLVM and code generation. Here we'll
    target LLVM IR for code generation, and detail more of the lowering
    framework."
tags: ["mlir", "dialect"]
draft: false
---

1) 이제 Toy 언어 -> MLIR -> LLVM -> 실제 실행되는 코드 (JIT) 로 간다.
진짜 프로그램을 돌리는 것.

2) Step 1 : Toy -> LLVM (Lowering)
이전 장에서 다룬 내용을 통해 toy 연산은 이미 affine / scf / arith 같은 표준 MLIR로 바꿔놓았다.
남은건 toy.print 이다.

toy.print 는 
- 내부적으로 C의 printf를 부르거나
- 배열을 이중 for-loop 로 돌면서 하나씩 출력하거나
- MLIR의 transitive lowering 덕분에 바로 LLVM을 만들지 않더라도, 중간 단계를 거쳐 자동으로 LLVM 까지 갈수 있다.

* printf 함수는 어디에서 오는가?
필요한 경우 LLVM 모듈 안에서 printf 선언을 자동으로 추가함

```
i32 printf(i8*, ...)
```

- 이미 있으면 재사용
- 없으면 새로 만들어 넣기
- 필요한 외부함수는 알아서 미리 준비한다.

3) Step 2 : Conversion 설정
(1) Conversion target
- 목표는 LLVM dialect 만 남기기
- ModuleOp + LLVMDialect 만 허용

(2) Type Converter
- memref `->` LLVM 포인터 구조체로 변환
- Toy 전용 타입이 없어서 기본 LLVMTypeConverter면 충분

(3) Conversion Patterns
- affine -> std
- scf -> control flow
- arith -> LLVM
- func -> LLVM
- cf -> LLVM
- toy.print 전용 lowering 패턴
즉 모든 연산을 LLVM으로 변환 가능하다는 것.

(4) Full Conversion

```
applyFullConversion(...)
```
LLVM 아닌 연산이 하나라도 남으면 실패 
이는 곧 아주 깔끔한 LLVM-only IR 이다.

(5) 예제 결과 : LLVM dialect MLIR
- malloc, free, printf 호출
- 포인터 연산
- GEP, load, call, br 등
- 완전한 저수준 코드
컴파일러가 본격적으로 시작하는 느낌이다.

4) Step 3 : LLVM IR로 변환
MLIR이 끝났기 때문에 LLVM IR(.ll) 로 변환을 한다.

```
translateModuleToLLVMIR(...)
```

- 이 결과를 보면 처음에는 되게 길고 복잡한 IR 처럼 보이지만
- 최적화를 켜면 반복문도 사라지고, 상수가 계산되고, printf만 쭉 남게 된다.
- 이는 컴파일러가 계산을 미리 다 해버리기 때문이다.

5) Step 4 : JIT로 바로 실행
이는 MLIR의 ExecutionEngine을 사용해서 가능하다.
(1) LLVM 타겟을 초기화하고
(2) 최적화 파이프라인을 설정하고
(3) JIT 컴파일을 진행하고
(4) main() 을 호출한다.

```
engine->invoke("main");
```

파일을 바로 저장하는 것이 아닌 바로 메모리에서 실행을 한다.

```
$ echo 'def main() { print([[1, 2], [3, 4]]); }' | ./toyc-ch6 -emit=jit

했을때 출력 결과는

1.000000 2.000000
3.000000 4.000000
```

Toy 언어가 실제 프로그램 처럼 실행된다.

=====================================================================

이 장의 내용을 요약해 보자면
- MLIR은 단계적으로 LLVM 까지 낮츨 수 있고
- Dialect Conversion + Transitive Lowering = 자동 변환이고
- toy.print `->` printf
- LLVM IR `->` 최적화 `->` JIT 실행
- Toy 를 실행 가능한 언어로 만들었다.







