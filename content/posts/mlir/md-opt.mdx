---
title: "MLIR Tutorial mlir-opt 에 대하여"
date: "2025-12-07"
summary: "Using mlir-opt"
tags: ["mlir", "mlir-opt"]
draft: false
---

1) mlir-opt란?
- MLIR IR을 로드 `->` 패스 실행 `->` 다시 IR 로 출력하는 CLI 도구
- 주 용도:
  - 패스 테스트
  - IR 변환 디버깅
  - Lowering 테스트
- Input / Output :
  - 기본 Input : textual MLIR or bytecode
  - 기본 Output : textual MLIR
- 검증기 (verifier) 가 항상 실행 됨 `->` IR 유효성 검사 가능
- 빌드 후 위치 : build/bin/mlir-opt

```
mlir-opt < input.mlir > output.mlir
```
- IR이 잘 파싱되는지 확인하는 가장 간단한 방법

2) 기본 사용법 핵심
도움말
```
mlir-opt --help
```
- 옵션 약 1000개 이상
- 각 패스마다 플래그가 있지만 권장 방식은 --pass-pipeline

3) 패스 실행 (--pass-pipeline)
기본 구조는
```
<anchor-op>(pass1,pass2,...)
```
- anchor-op : 패스가 적용되는 IR 노드 타입
  - 예: builtin.module, func.func
- 패스는 anchor 가 맞지 않으면 실행되지 않음

ex) math `->` llvm 변환
```
mlir-opt \
  --pass-pipeline="builtin.module(convert-math-to-llvm)" \
  input.mlir
```
- 결과는 MLIR의 llvm dialect
- 실제 LLVM IR 생성은 mlir-translate 가 필요함.

4) 옵션을 갖는 패스 실행
패스 옵션 문법
```
pass-name{option1=value1 option2=value2}
```
- 공백으로 구분
- {} 안에서 key=vaule 형태

예시: affine loop fusion
```
mlir-opt \
  --pass-pipeline="builtin.module(affine-loop-fusion{fusion-compute-tolerance=0})" \
  loop_fusion.mlir
```
이 옵션의 의미는 fusion-compute-tolerance : 루프 퓨전 시 허용되는 추가 연산 비율을 의미한다. (추가 연산량을 얼마나 허용할지)
따라서 0이라는 것은 퓨전 비활성화를 의미한다.
참고로 비율(fraction으로) 주는 거라 0.1, 0.25 같이 줌. (각각 10%, 25% 증가 까지 허용) 
```
(퓨전 후 추가 연산량) / (기존 연산량)
```

5) 여러 패스를 조합한 파이프라인
단순 체이닝
```
--pass-pipeline="builtin.module(pass1,pass2,pass3)"
```
- 순서대로 실행된다.

6) 중첩된 패스 앵커링
이 개념이 진짜 중요함.
필요한 이유는 
- 패스는 특정 IR 레벨에서만 동작하고
- 올바른 nesting을 안 쓰면 패스가 아예 실행되지 않기 때문
예시 구조는 아래와 같음
```
module {
  module {
    func.func ...
  }
  gpu.module {
    gpu.func ...
  }
}
```

func.func 에만 CSE + canonicalize 적용
```
mlir-opt --pass-pipeline='
  builtin.module(
    builtin.module(
      func.func(cse,canonicalize),
      convert-to-llvm
    )
  )'
```

결과
- func.func 만 최적화 됨
- gpu.module은 그대로 유지가 됨

이러한 중첩 앵커링은 성능적으로 장점이 있음.
- 패스가 IR 서브셋 단위로 병렬 실행이 가능함.
- 캐시 지역성 개선
```
builtin.module(func.func(...))

가

builtin.module(...)
보다 효율적임.
```

7) 자주 쓰는 CLI 플래그들
디버깅 에서는 
- --debug
- --debug-only="tag"
  - "greedy-rewriter" 나 "dialect-conversion"

IR 출력
- --mlir-print-ir-after-all
- --mlir-print-ir-after-change
- --mlir-print-ir-after-failure
- `--mlir-print-ir-tree-dir=<dir>` (IR을 파일 트리로 저장함. 대규모 IR 디버깅 하려면 사실상 필수)

통계 / 성능 관련해서는
- --mlir-pass-statistics
- --mlir-timing

기타
- --emit-bytecode : MLIR bytecode를 출력함.\

=====================================================================

요약해 보자면
- mlir-opt는 MLIR 패스 실행의 표준 테스트 도구
- 패스 실행은 --pass-pipeline 사용이 정석임
- 패스 앵커링 (op-level) 개념을 이해해야 제대로 동작함
- 패스 옵션은 {key=value} 문법
- 중첩 파이프라인은 정확성 + 성능 모두에 중요함
- 디버깅시 --debug-only, --mlir-print-ir-*는 필수 도구임.