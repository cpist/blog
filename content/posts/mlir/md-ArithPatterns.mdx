---
title: "MLIR ArithPatterns"
date: "2026-01-02"
summary: "MLIR IR - ArithPatterns"
tags: ["mlir", "DRR"]
draft: false
---
MLIR의 Arith Dialect에서 산술 연산을 최적화하고 단순화하기 위한 DRR(Declarative Rewrite Patterns) 정의서
단순한 계산 식이 아니라 정적 분석 및 정규화(Canonicalization) 과정에서 그래프를 어떻게 변형하는지에 초점을 맞춰야 한다.

1) 핵심 설계 구조
패턴 정의에 앞서 효율적인 변환을 위한 유틸리티들이 선언되어 있음
- NativeCodeCall : TableGen만으로 처리하기 복잡한 C++ 로직(속성 값 계산, 오버플로우 플래그 병합 등)을 호출
  - ex) AddIntAttrs, MergeOverflow, invertPredicate
- Constraints : 패턴 매칭 조건(Predicate)을 정의
  - ex) IsScalarOrSplatNegativeOne (값이 -1인지 확인), ValueWiderThan (비트 폭 비교)
- Overflow Handline: none을 기본값으로 하며, 연산 병합 시 상호 간의 오버플로우 플래그를 보수적으로 유지하도록 설계

2) 주요 최적화 패턴
1. 상수 폴딩 및 재결합 (Constant Folding & Reassociation)
연속된 상수 연산을 하나의 연산으로 합쳐 연산 횟수를 줄임. 
addi는 가환성(Commutative)을 가지므로 상수가 항상 두 번째 피연산자로 오도록 정규화됨을 전제로 함.

- Add / Sub / Mul 합치기
  - addi(addi(x, c0), c1) $\rightarrow$ addi(x, c0 + c1)
  - subi(subi(x, c0), c1) $\rightarrow$ subi(x, c0 + c1)
  - muli(muli(x, c0), c1) $\rightarrow$ muli(x, c0 * c1)

2. 연산 단순화 (Strength Reduction)
더 복잡하거나 비용이 큰 연산을 단순한 연산으로 대체
- 곱셈을 뺄셈으로: addi(x, muli(y, -1)) $\rightarrow$ subi(x, y)
- 부호 반전 활용: subi(subi(a, b), a) $\rightarrow$ subi(0, b)
- 확장 연산 제거: addui_extended나 mulsi_extended에서 상위 비트(Overflow/High) 결과가 사용되지 않으면 일반 addi/muli로 대체

3. 캐스트 및 비트 조작 (Cast & Bit Manipulation)
형변환 연산이 중첩될 때 발생하는 중복을 제거
- Idempotency (멱등성): index_cast(index_cast(x)) $\rightarrow$ x (타입이 같을 경우)
- Extension 합치기
  - extsi(extui(x)) $\rightarrow$ extui(x) (부호 없는 확장이 우선됨)
  - and/or/xor(extui(x), extui(y)) $\rightarrow$ extui(and/or/xor(x, y)) (연산 후 확장)
- Truncation 최적화: trunci(extsi(x))에서 잘려 나가는 부분이 부호 확장 비트뿐이라면 extsi(x)로 바로 연결

4. 비교 및 선택문 (Comparison & Select)
논리 흐름을 정규화하여 제어 흐름 최적화를 도움
- 비교 연산 반전: not(cmpi(pred, a, b)) $\rightarrow$ cmpi(~pred, a, b)
- Select 중복 제거
  - select(pred, select(pred, a, b), c) $\rightarrow$ select(pred, a, c)
  - select(pred, false, true) $\rightarrow$ not(pred) (i1 타입인 경우)

5. 부동 소수점 (Floating Point)
- 부호 반전 상쇄: mulf(negf(x), negf(y)) $\rightarrow$ mulf(x, y)
- Rounding Mode 고려: truncf(sitofp(x))에서 기본 라운딩 모드일 경우 연산을 단순함

3) 컴파일러 엔지니어링 관점의 포인트
1. Pattern Priority: TableGen에 정의된 순서대로 매칭을 시도하므로, 더 구체적인 패턴이 일반적인 패턴보다 앞에 위치
2. Type Safety: `Constraint<CPred<"$0.getType() == $1.getType()">>`와 같이 타입 일치 여부를 엄격히 체크하여 잘못된 IR 생성을 방지
3. TODO Flags: 코드 곳곳에 `// TODO: overflow flags`가 적혀 있음 
  - 이는 현재 패턴이 오버플로우 플래그(nsw, nuw 등)를 완벽하게 전파하지 못하고 있음을 의미
  - 실제 컴파일러 구현 시 이 부분의 정밀도가 최적화 성능을 좌우