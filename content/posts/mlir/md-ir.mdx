---
title: "MLIR Tutorial IR structure 에 대하여"
date: "2025-12-08"
summary: "Understanding the IR Structure"
tags: ["mlir", "IR structure"]
draft: false
---
MLIR IR은 dialect 기반으로 여러 단계의 IR을 표현하는 프레임워크임.
즉 MLIR IR 자체는 하나의 고정된 최종 IR이 아니고, 여러 dialect IR 들이 공존, 변환되는 플랫폼임.
```
// All dialect-specific operations are MLIR Operations
Dialect IR ⊆ MLIR IR

즉 MLIR IR을 프로그래밍 언어의 AST 프레임워크라면
Dialect는 그 AST 로 정의한 특정 언어들임.
```

1) MLIR IR의 기본 구조
- 모든 IR은 Operation을 루트로 가짐.
  - 대부분 최상위는 ModuleOp
  - PassManager는 최상위 ModuleOp에서 시작됨.
- Pass의 시작점은
```
Operation *op = getOperation();
```

2) IR의 계층적 중첩 구조 (Nesting)
MLIR IR은 재귀적 트리 구조임.
```
Operation
 └─ Region (0개 이상)
     └─ Block (0개 이상)
         └─ Operation (여러 개)
```
이를 순회하기 위해 3가지 함수를 사용함
1. printOperation(Operation *)
- 출력 내용
  - Operation 이름
  - operand 개수
  - result 개수
  - attribute 목록
  - 포함된 region 개수
- 이후 각 Region으로 재귀 진입

2. printRegion (Region &)
- Region은 Block 들의 리스트만 보유
- 출력 내용
  - block 개수
- 이후 각 Block 으로 재귀 진입

3. printBlock(Block &)
- Block 의 정보
- 출력 내용
  - argument 개수
  - successor 개수
  - operation 개수
- 이후 Block 안의 모든 Operation 순회

3) 예제 IR과 출력 결과의 의미
  - 실제 MLIR 예제를 mlir-opt -test-print-nesting 으로 실행
  - 출력은 IR 트리 구조를 깊이별로 그대로 시각화
  - `Operation -> Region -> Block -> Operation` 흐름이 명확히 드러남

4) IR 순회를 돕는 다른 방법들
1. 필터링된 `iterator: getOps<OpTy>()`
  - 특정 타입의 Operation만 순회
  - 사용 위치:
    - `Block::getOps<OpTy>()`
    - `Region::getOps<OpTy>()`
  - 예:
```
for (spirv::GlobalVariableOp gvOp : block.getOps<spirv::GlobalVariableOp>())
```
  - 즉시 포함된 operation 만 대상 (중첩 X)

2. Walker: walk()
  - 중첩 구조 전체를 재귀적으로 순회
  - 사용 가능 대상
    - Operation
    - Region
    - Block 

```
// 기본 사용
op->walk([&](Operation *op) { ... });

// 특정 타입만 필터링
op->walk([](LinalgOp linalgOp) { ... });

// 순회 중단 가능
return WalkResult::interrupt();

wasInterrupted() 로 중단 여부 확인이 가능함.
이것은 중첩 IR 분석 시 가장 많이 쓰이는 방식
```

5) Def-Use Chain (값의 생산자-사용자 관계)
1. Value의 정의
- Value는 두 가지 중 하나
  - BlockArgument
  - Operation의 Result
- Operation은 여러 Result (Value) 를 가질 수 있음

2. `Operand -> Producer` 추적
- 각 Operand(Value)에 대해
  - getDefiningOp() 가 있으면 Operation이 생산자이고
  - 없으면 BlockArgument 임.
```
operand.getDefiningOp()
```

3. `Result -> User` 추적
- Operation의 각 result에 대해
  - 사용자가 없는지 (use_empty)
  - 하나인지 (hasOneUse)
  - 여러 개인지 (getNumUses)
- getUsers() 로 사용자 Operation 순회

6) Use-list 구조와 RAUW
- Value의 use 들은 doubly linked list로 관리됨
- 이 구조 덕분에
  - 모든 사용처를 효율적으로 교체 가능
  - RAUW (Replace All Uses With) 가 빠름

=====================================================================

요약해 보자면
- MLIR IR은 Operation을 루트로 하는 계층적 트리 구조이고
- Region-Block-Operation 순회, walk 기반 재귀 탐색
- Value의 def-use 체인 분석이 IR 분석과 변환의 핵심이라는 것이다.