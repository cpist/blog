---
title: "알아두면 쓸데있는 기초 지식들"
date: "2026-01-03"
summary: "Simple Questions"
tags: ["etc", "Tip"]
draft: false
---

1) 툴체인(Toolchain) 이라는게 정확히 무엇일까?
툴체인은 소프트웨어 개발 과정에서 소스 코드가 실행 가능한 바이너리가 되기까지 필요한 **도구들의 연결 고리(Chain)**를 의미
- 컴파일러 하나만을 지칭하는 것이 아닌, 다음의 구성요소들이 유기적으로 엮여 있음.
    - Compiler (Frontend/Backend): 소스 코드를 중간 표현(IR)이나 어셈블리로 변환 (Clang, LLVM 등)
    - Assembler: 어셈블리 코드를 기계어(Object File)로 변환
    - Linker: 여러 개의 오브젝트 파일과 라이브러리를 하나로 묶어 실행 파일 생성 (lld, gold 등)
    - C/C++ Runtime Libraries: libc++, libstdc++ 등 기본 기능을 제공하는 라이브러리
    - Debugger/Profiler: 디버깅과 성능 분석 도구 (LLDB, GDB)
이 도구들이 서로의 출력을 입력으로 받으며 체인처럼 이어져 있기 때문에 툴체인이라고 부름.

2) 프로젝트 정적 검증의 원리
기본적으로 컴파일러 기반의 정적 검증 도구(Clang Static Analyzer 등)는 번역 단위(Translation Unit, TU) 별로 동작함
    - 보통 .c나 .cpp 파일 하나가 하나의 TU가 됨.
    - 개별 검증: 파일 A를 검증할 때 파일 B의 내부 로직은 알지 못하는 것이 기본
    - 전역 검증 (Inter-procedural Analysis): 최근에는 여러 파일 간의 호출 관계를 분석하기 위해 'Cross-Translation Unit (CTU) Analysis' 기능을 사용하기도 한다. 
        - 이 경우 프로젝트 전체의 인덱스를 먼저 생성한 뒤 검증을 수행

* 그렇다면 Import(Include) 파일은 어떻게 처리 할까?
C/C++에서 #include는 **전처리기(Preprocessor)**가 처리
    - 텍스트 치환: 검증 도구가 돌아가기 전, 전처리기는 #include 문을 해당 헤더 파일의 실제 내용으로 통째로 복사해 넣음
    - 거대 파일화: 결과적으로 검증 도구는 헤더 내용이 모두 포함된 하나의 커다란 소스 코드(Preprocessed source)를 읽게 됨
    - 의존성 해결: 따라서 헤더 파일에 선언된 함수나 클래스 정보는 이미 하나의 파일 안에 합쳐진 상태이므로, 검증 도구는 이를 자연스럽게 인식 가능

3) LLVM과 MLIR의 처리 flow (Flow comparison)
두 기술의 가장 큰 차이점은 **"추상화의 단계(Level of Abstraction)"** 임.

1. [LLVM Flow: 전통적인 3단계 구조]
LLVM은 보통 단일 수준의 IR(LLVM IR)을 중심으로 동작
    - Frontend (Clang): C/C++ 코드를 읽어 구문 분석(AST) 후 LLVM IR로 변환
    - Optimizer (LLVM Opt): 생성된 LLVM IR을 대상으로 하드웨어 독립적인 최적화(Dead code elimination, Loop unrolling 등)를 수행
    - Backend (LLVM CodeGen): LLVM IR을 특정 타겟(x86, ARM, RISC-V 등)의 기계어로 변환

2. [MLIR Flow: 다중 계층 구조]
MLIR은 LLVM IR 하나로 모든 것을 표현하기엔 너무 정보 손실이 크다는 문제에서 출발
    - Frontend: 소스 코드를 읽어 가장 높은 수준의 Dialect(예: Toy, TOSA, Linalg 등)로 변환
    - Progressive Lowering (점진적 하향): * 한 번에 기계어로 가는 게 아니라, High-level Dialect $\rightarrow$ Mid-level Dialect $\rightarrow$ Low-level Dialect 순서로 단계적으로 변환
        - 예: "행렬 곱셈" 연산이 있다면, 이를 처음엔 'Matmul'이라는 고수준 개념으로 최적화하고, 다음 단계에서 'Loop'로 풀고, 마지막에 'LLVM Dialect'로 내림
    - Conversion to LLVM IR: 최종적으로 LLVM Dialect가 된 코드를 LLVM IR로 Export 함.
    - LLVM Backend: 이후는 기존 LLVM flow를 타고 기계어가 생성

* 정리해 보자면
- LLVM은 "모든 언어를 하나의 공통 IR로 모아서 최적화하자"는 주의
- MLIR은 "도메인에 맞는 여러 단계의 IR(Dialect)을 거치며 단계별로 최적화하자"는 주의

