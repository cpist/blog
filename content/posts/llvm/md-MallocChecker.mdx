---
title: "LLVM MallocChecker"
date: "2025-12-29"
summary: "Clang Static Analyzer - MallocCheckeranalyze"
tags: ["llvm", "Static Analyzer", "MallocChecker"]
draft: false
---
LLVM / Clang Static Analyzer 의 핵심 구성 요소 중 하나이다.
이 파일은 C/C++ 프로그램에서 발생할 수 있는 동적 메모리 관리 오류를 탐지하는 로직을 담고 있음.

1) 개요 및 목적
- MallocChecker는 이름과 달리 malloc / free 뿐만 아니라 C++의 new / delete, 각종 OS 커널 함수, 사용자 정의 메모리 할당 함수까지 모두 다룸.
- 주요 탐지 오류는 아래와 같음
  - Leak(메모리 누수) : 할당된 메모리가 해제되지 않고 포인터가 소멸됨
  - Double Free (이중 해제) : 이미 해제된 메모리를 다시 해제함
  - Use-After-Free (UAF, 해제 후 사용) : 해제된 메모리 영역에 접근함
  - Mismatched Deallocator : malloc으로 할당하고 delete 로 해제하는 등의 부적절한 쌍 사용
  - Tainted Allocation : 외부 입력값 (Tainted data)을 검증 없이 할당 크기로 사용함.

2) 핵심 데이터 구조
- AllocationFamily
메모리가 어떤 계열로 할당되었는지 정의함. 
이를 통해 할당-해제 쌍이 맞는지 검사함.
  - AF_Malloc: malloc, free 계열.
  - AF_CXXNew/AF_CXXNewArray: C++ new, delete 계열.
  - AF_Alloca: 스택 할당(alloca). 해제하면 안 됨.
  - AF_Custom: __attribute((ownership_returns(malloc))) 등 사용자 정의 속성.

- RefState (메모리의 상태)
분석기는 각 메모리 심볼(SymbolRef)의 상태를 추적합니다.
  - Allocated: 메모리가 성공적으로 할당됨.
  - Released: 메모리가 해제됨.
  - Escaped: 포인터가 분석 범위를 벗어남 (다른 함수로 전달 등). 더 이상 추적하지 않음.
  - Relinquished: 소유권이 이전됨 (스마트 포인터 등).

3) 주요 동작 메커니즘
- evalCall: 함수 호출 모델링
분석기가 malloc이나 free 같은 함수 호출을 만났을 때 실제 코드를 실행하는 대신, 추상적으로 메모리 상태를 변경함.
  - AllocatingMemFnMap 등에 등록된 함수(malloc, calloc 등)를 만나면 새로운 심볼을 생성하고 상태를 Allocated로 바꿈.
  - FreeingMemFnMap에 등록된 함수(free, g_free 등)를 만나면 FreeMemAux를 호출하여 해제 로직을 수행함.

- checkDeadSymbols: 누수(Leak) 탐지
  - 분석이 진행되면서 특정 포인터 변수가 더 이상 사용되지 않게 될 때(DeadSymbols), 해당 심볼이 여전히 Allocated 상태라면 Memory Leak으로 보고함.

- ReallocMemAux: realloc의 복잡성 처리
  - realloc은 성공 시 기존 메모리 해제 + 새 메모리 할당, 실패 시 기존 메모리 유지라는 복잡한 경로를 가짐.
  - 코드는 이 두 가지 경로(Path)를 모두 시뮬레이션하여 잠재적인 오류를 찾음.

4) 특이 사항 및 고급 기능
- 스마트 포인터 대응 (handleSmartPointerRelatedCalls)
  - 최신 C++ 코드에서는 std::unique_ptr 등을 사용함. 
  - 분석기는 포인터가 스마트 포인터 생성자에 전달되면 이를 Escaped 또는 **Relinquished**로 처리하여, 스마트 포인터가 대신 관리하게 되었음을 인식하고 가짜 누수 보고(False Positive)를 방지함.

- 커널 메모리 모델링 (performKernelMalloc)
  - Linux나 BSD 커널에서 사용하는 kmalloc이나 M_ZERO 플래그를 인식함. 
  - 특정 플래그가 설정된 경우 메모리가 0으로 초기화된 것으로 간주(calloc처럼 동작)함.

- 오염 분석 (checkTaintedness)
  - 사용자로부터 입력받은 값이 할당 크기(size)로 들어올 경우, 매우 큰 값이 입력되어 정수 오버플로나 서비스 거부(DoS) 공격으로 이어질 수 있음을 경고함.

5) 상태 전이 모델링 (State Machine Implementation)
메모리 심볼의 상태를 단순히 저장하는 것이 아닌 Immutable Map을 통해 관리함

```
REGISTER_MAP_WITH_PROGRAMSTATE(RegionState, SymbolRef, RefState)
```

이 매크로는 ProgramState 내부에 SymbolRef(포인터 심볼) 와 RefState(상태 정보)를 매핑하는 테이블을 생성함.
분석기가 경로를 탐색할 때 마다 Map이 복사되는 것이 아니라, 변경된 부분만 공유(Persistent Data Structure) 되어 효율성을 극대화 함.

상태 전이의 핵심 로직
- 할당 때는 (MallocUpdateRefState): 심볼을 Allocated 상태로 등록.
- 해제 때는 (FreeMemAux): 상태를 Released로 변경. 만약 이미 Released라면 HandleDoubleFree 호출.
- 사용 때는 (checkUseAfterFree): 상태가 Released인 심볼에 접근하면 에러 보고.

6) evalCall vs checkPreCall/checkPostCall
코드에서 함수 호출을 처리하는 방식이 두 가지로 나뉨. 
이 차이를 아는 것이 정적 분석기 코드 분석의 핵심

- evalCall (모델링): malloc, realloc 같은 시스템 함수를 만났을 때, 분석기가 "이 함수의 동작은 내가 직접 정의하겠다"라고 선언하는 것. 
  - 실제 함수의 본문을 분석하는 대신, 리턴값으로 가상의 심볼을 생성함.

- checkPreCall (검증): 함수가 실행되기 직전에 인자값이 유효한지(예: 이미 해제된 포인터를 free에 넘기지는 않는지) 검사함.

- checkPostCall (사후 처리): 함수 실행 직후에 상태를 업데이트함. (예: 스마트 포인터 생성자가 호출된 후 소유권 이전 처리)

7) 정교한 예외 처리 (False Positive Suppression)
정적 분석기에서 가장 어려운 것은 "버그가 아닌데 버그라고 하는 것"을 막는 일임. 
이 코드에는 이를 위한 고도의 기교가 숨어 있음.

1. 스마트 포인터와 임시 객체 (isRvalueByValueRecord)
C++에서 임시 객체가 값으로 전달될 때 소멸자가 호출되는 시점이 복잡함. 
이 코드는 해당 객체 내부에 스마트 포인터 필드가 있는지 검사하고, 있다면 메모리 누수 보고를 일시적으로 유예하거나 Escaped 처리하여 오탐을 줄임.

2. 아토믹 연산과 참조 카운팅
```
if (isReferenceCountingPointerDestructor(DD)) { ... }
```
참조 카운팅 기반의 객체(shared_ptr 등)는 참조 횟수가 0이 될 때만 메모리를 해제함. 
이 체커는 소멸자 내부에 fetch_add나 fetch_sub 같은 아토믹 연산이 있다면, 이는 참조 카운팅 로직일 확률이 높다고 보고 분석의 엄격함을 조절함.

8) BugVisitor를 통한 원인 추적
버그 리포트가 단순히 "여기서 메모리 누수임"이라고 말하면 개발자는 이해하기 어려움. 
이 코드의 MallocBugVisitor는 Exploded Graph(분석기가 지나온 경로 그래프)를 역추적함.

- 역추적 로직: 현재 에러가 난 지점에서 뒤로 가면서 "이 메모리가 어디서 할당되었는가?"를 찾아내어 리포트에 **"메모리가 여기서 할당되었습니다"**라는 노트를 추가해줌. (getAllocationSite 함수)

9) 테인드 데이터 분석 (checkTaintedness)
```
void MallocChecker::checkTaintedness(..., const SVal SizeSVal, ...) const
```

이 부분은 보안 분석의 핵심임. 
외부에서 들어온 값(SizeSVal)이 malloc의 인자로 쓰일 때, 이 값이 너무 크지는 않은지 검사함. 
만약 사용자가 제어 가능한 값이 검증 없이 할당 크기로 쓰인다면 이를 **"Tainted Memory Allocation"**으로 분류하여 보안 취약점으로 보고함.

=====================================================================

요약해 보자면 이 파일은 상태 머신(State Machine) 기반의 분석 엔진임. 
포인터의 생애 주기(`할당 → 사용 → 해제`)를 추적하며 각 단계에서 정의된 규칙(ex: "해제된 상태에서 사용 금지")을 위반하는지 감시합니다.
