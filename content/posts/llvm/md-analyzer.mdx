---
title: "LLVM Static Analyzer"
date: "2025-12-27"
summary: "Clang Static Analyzer Basic Information"
tags: ["llvm", "Static Analyzer"]
draft: false
---
clang은 LLVM 기반의 C/C++/Objective-C 컴파일러 프론트엔드이자 분석 인프라임.

1) 라이브러리 구조 (Library Structure)
Clang Static Analyzer 는 2계층 구조로 구성되어 있음.
- 정적 분석 엔진 (low-level engine)
  - 핵심 파일 : ExprEngine.cpp
  - 프로그램을 실제로 시뮬레이션 하면서 분석을 수행함.
- 체커 (Checkers)
  - 파일 : *Checker.cpp
  - 인터페이스: Checker, CheckerVisitor
  - 엔진 위에서 동작하며 버그 조건을 정의
  - 체커 작성자가 내부 엔진의 복잡한 구현을 몰라도 되도록 설계됨

2) 기본 동작 원리
1. 핵심 아이디어
Clang Static Analyzer는 소스 코드 실행 경로를 시뮬레이션 하는 분석기임.
  - 실제 실행은 하지 않음
  - 가능한 모든 실행 경로를 정적 분석으로 추적함

2. 핵심 개념
  - ProgramState
    - 프로그램의 상태
    - 변수, 표현식 값, 제약 조건을 포함
    - 불변(immutable) 객체
    - 변경 시 항상 새 ProgramState 생성
  - ProgramPoint
    - 프로그램 내의 특정 위치
    - CFG 상의 위치를 의미
  - ExplodedNode
    - (ProgramState, ProgramPoint) 의 쌍
    - 분석 그래프의 노드
  - ExplodedGraph
    - 모든 ExplodedNode 로 구성된 그래프
    - CFG의 각 엣지를 폭발(explode) 시켜서 만든 그래프
    - DAG가 아님, 루프 때문에 사이클이 가능

3. 분석 방식
  - 우선 Entry point 에서 시작함
    - 초기 ProgramState + 시작 ProgramPoint
  - 표현식 단위로 시뮬레이션
    - 각 표현식 분석 시
      - 상태 변경 가능
      - 새로운 ExplodedNode 생성
  - 버그 발견
    - 특정 ExplodedNode가 버그 조건을 만족하면 발견함.

* 참고로 Explode(Exploded Graph) 의 개념에 대해 살펴보자면
Explode 란 하나의 CFG 노드를 프로그램 상태별로 분해하여 여러 분석 노드로 확장하는 것임.

```
if (x > 0) {
  y = 1;
} else {
  y = -1;
}

* CFG 관점에서는
if 하나
y=1, y=-1 두 경로

* 반면 ExplodedGraph 관점:
if 지점에서 상태가 두 개로 explode
상태 A: x > 0 가정
상태 B: x <= 0 가정
이후 각 상태가 서로 다른 ProgramState로 독립 전파
즉, 하나의 코드 지점이 여러 “의미 있는 상태 노드”로 폭발(explode)됨
```

4. 경로 민감 분석 (Path Sensitivity)
  - 분기(if, while) 을 만나면
    - true 경로 / false 경로로 분기
    - 각 경로마다 조건을 가정 (assumption)
  - ConstraintManager
    - 분기 조건에서 생성된 제약 조건 관리
  - 불가능한 경로 제거
    - 제약이 모순이면 해당 경로는 폐기
  - 이 방식으로 path-sensitive analysis 구현함.

5. 성능 최적화 : 노드 캐싱
  - 동일한 (ProgramState, ProgramPoint) 가 다시 생성되면
    - 새 노드를 생성하지 않고
    - 기존 노드를 재사용함 (cache out)
  - 지수 폭발 (exponential blow-up) 방지

6. 불변성과 효율성
  - ProgramState와 ExplodedNode는 불변
  - 내부 구현은 함수형 자료구조
    - (ex) ImmutableMap
    - 상태 간 데이터 공유로 메모리 효율을 유지함.

3) Checker 의 역할과 동작
- Analyzer 엔진과 Checker 는 Visitor 패턴으로 통신함
- 예시로는 PreVisitCallExper()
  - 함수 호출 전 호출됨
  - 체커가 사전 조건(precondition) 을 검사함
* Checker 가 할 수 있는 것은
  - 아무것도 안하거나
  - 새로운 ProgramState를 생성하거나
  - ExplodedNode를 생성하거나
  - 버그 발견 시 BugReporter 에 보고함.

4) C++ 관련 특이사항
1. 객체 생성 처리
  - 생성자는 CFG에서 변수 선언보다 먼저 등장함
  - 임시 객체 region을 생성하여 생성 대상을 저장함
2. CXXConstructExpr 처리
  - processCallExit()
    - 생성된 객체 region을 CXXConstructExpr 결과로 바인딩
  - VisitDeclStmt()
    - 비참조 변수는 lazy compound value를 사용함
    - 참조 변수는 객체 region을 직접 사용함
3. this 포인터 처리
  - 메서드/생성자/소멸자 진입 시
    - 'this' region 을 객체 region에 바인딩
```
생성자의 경우 CXXREcordDecl* (타입 qualifier 무시)
일반 메서드의 경우 CXXMethodDecl* (타입 qualifier 고려)
```
메서드 호출 단위 내에서만 일관성을 유지하면 문제가 없음.

5) Analyzer 개발 가이드
1. 엔진 개발 (표현식 지원 추가)
  - ExprEngine의 visitation 로직을 확인
  - 다양한 표현식 처리 예제가 이미 존재
2. Checker 개발
  - Checker.h, CheckerVisitor.h를 참고
  - 기존 *Checker.cpp 파일들이 좋은 예제임

6) 디버깅 도구 (Debugging)
유용한 옵션들
```
clang -cc1 -help | grep analyze
```
- -analyze-function
  - 특정 함수만 분석
- -analyzer-display-progress
  - 현재 분석 중인 함수 출력
- -analyzer-viz-egraph-graphviz
  - ExplodedGraph를 GraphViz로 출력

CFG 디버깅
```
clang -cc1 -analyzer-checker=debug.DumpCFG
clang -cc1 -analyzer-checker=debug.ViewCFG
```
- DumpCFG : 텍스트 출력
- ViewCFG : GraphViz 시각화

7) References
1. Reps et al., 1995
  - 그래프 도달성 기반 정밀 데이터플로우 분석
2. Xu, Kremenek, Zhang
  - C 프로그램 정적 분석을 위한 메모리 모델

=====================================================================

요약해 보자면
- Clang Static Analyzer는 CFG 기반 경로 민감 시뮬레이션 분석기로
- 불변 상태 + 제약 기반 분기 + 노드 캐싱을 통해 정확성과 성능을 동시에 달성하며
- Checker는 엔진 위에서 버그 조건만 정의하도록 분리된 구조를 가진다