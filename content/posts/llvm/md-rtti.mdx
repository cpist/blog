---
title: "MLIR에서 RTTI이 의미하는 것"
date: "2026-01-08"
summary: "RTTI Stands For"
tags: ["llvm", "Basic"]
draft: false
---

1) LLVM에서 **RTTI(Run-Time Type Information)**는 객체의 타입을 런타임에 식별하고 안전하게 다운캐스팅(Downcasting)하기 위한 메커니즘
But, LLVM은 표준 C++에서 제공하는 dynamic_cast나 typeid 같은 표준 RTTI를 사용하지 않음.
대신 **'LLVM-style RTTI'**라고 불리는 자체적인 경량 시스템을 구축하여 사용.

2) LLVM이 표준 RTTI를 버린 이유
표준 C++의 RTTI는 편리하지만, 컴파일러와 같은 거대한 프레임워크에서는 다음과 같은 단점이 있음
    - 바이너리 크기 증가: 모든 다형성 클래스에 대해 타입 정보(Type Info)와 VTable을 생성해야 하므로 실행 파일이 매우 커짐
    - 성능 저하: dynamic_cast는 런타임에 클래스 계층 구조를 순회하며 타입을 체크하므로 오버헤드가 큼
    - 의존성: 표준 RTTI는 특정 컴파일러 플래그(-fno-rtti)로 꺼버리는 경우가 많아, 라이브러리 간 호환성 문제를 일으킬 수 있음
이 때문에 LLVM은 성능을 극대화하기 위해 표준 RTTI를 끄고(-fno-rtti), 수동으로 구현한 커스텀 RTTI를 사용

3) LLVM-style RTTI의 핵심 구조
이 시스템의 핵심은 **"객체 스스로가 자신이 누구인지 알고 있게 만드는 것"**
이를 위해 두 가지 장치가 필요
    - Type Kind (Enum): 베이스 클래스에 자신이 어떤 서브 클래스인지 나타내는 열거형 값을 저장
    - classof(): 각 서브 클래스에 "이 객체가 내 타입이 맞는가?"를 판단하는 정적 메서드를 구현
```
#include <iostream>
#include <llvm/Support/Casting.h> // isa, cast, dyn_cast 정의

// 1. 베이스 클래스 정의
class Shape {
public:
  enum ShapeKind { SK_Circle, SK_Square }; // 서브 클래스 식별자

private:
  const ShapeKind Kind; // 객체의 실제 타입을 저장

public:
  ShapeKind getKind() const { return Kind; }
  Shape(ShapeKind K) : Kind(K) {}
  virtual ~Shape() {}
};

// 2. 서브 클래스 정의
class Circle : public Shape {
public:
  Circle() : Shape(SK_Circle) {}

  // LLVM RTTI의 핵심: classof 구현
  static bool classof(const Shape *S) {
    return S->getKind() == SK_Circle;
  }
};

class Square : public Shape {
public:
  Square() : Shape(SK_Square) {}

  static bool classof(const Shape *S) {
    return S->getKind() == SK_Square;
  }
};
```

4) 어떻게 사용하나? (Casting.h)
classof가 구현되어 있다면, LLVM이 제공하는 강력한 캐스팅 도구들을 사용 가능
    - `isa<T>(ptr)`: 객체가 특정 타입인지 확인 (bool 반환)
    - `cast<T>(ptr)`: 특정 타입으로 강제 캐스팅 (타입이 다르면 Assertion Error 발생)
    - `dyn_cast<T>(ptr)`: dynamic_cast와 유사. 타입이 맞으면 포인터 반환, 틀리면 nullptr 반환

```
void processShape(Shape *S) {
  if (llvm::isa<Circle>(S)) {
    // S가 Circle임을 확인
  }

  if (Circle *C = llvm::dyn_cast<Circle>(S)) {
    // 안전하게 Circle의 멤버에 접근
    std::cout << "This is a circle!" << std::endl;
  }
}
```

5) 구현의 원리 
`llvm::dyn_cast<T>(val)` 내부적으로는 대략 다음과 같은 템플릿 로직이 동작
    - 입력받은 val의 타입에서 T::classof(val)가 존재하는지 확인
    - T::classof(val)를 호출하여 true가 나오면 `static_cast<T*>(val)`를 수행
    - false라면 nullptr를 반환
이 방식은 단순히 정수값(Enum) 비교만 수행하므로 dynamic_cast보다 훨씬 빠르고, VTable 이외의 추가적인 메타데이터를 생성하지 않아 효율적

* LLVM이나 MLIR 코드를 보실 때 classof라는 함수가 보인다면, 대충 LLVM 스타일의 RTTI를 지원한다고 이해하면 됨.

6) llvm::dyn_cast 내부에 classof를 쓴다.
일단 llvm-project/llvm/include/llvm/Support/Casting.h 를 들어가보면
```
template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(const From &Val) {
  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
  return CastInfo<To, const From>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(From &Val) {
  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
  return CastInfo<To, From>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {
  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
  return CastInfo<To, From *>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr<From> &Val) {
  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
  return CastInfo<To, std::unique_ptr<From>>::doCastIfPossible(Val);
}
```

요런식으로 구현 되어있음.
Interface 부분에서는 classof가 없고
CastInfo 라는 Trait 구조체 뒤로 구현 상세가 숨겨져 있음.

즉 CastInfo `->` isa `->` classof 로 가는데
함수로 보자면 doCastIfPossible `->` isPossible `->` doit 으로 가고
가장 마지막 바닥에 있는 isa_impl 에서

```
template <typename To, typename From, typename Enabler = void> struct isa_impl {
  static inline bool doit(const From &Val) { return To::classof(&Val); }
};
```

classof가 있음.